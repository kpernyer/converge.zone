// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ortools/sat/cp_model.proto
// Protobuf C++ Version: 6.33.1

#ifndef ortools_2fsat_2fcp_5fmodel_2eproto_2epb_2eh
#define ortools_2fsat_2fcp_5fmodel_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ortools_2fsat_2fcp_5fmodel_2eproto OR_PROTO_DLL

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct OR_PROTO_DLL TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
OR_PROTO_DLL extern const ::google::protobuf::internal::DescriptorTable descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto;
}  // extern "C"
namespace operations_research {
namespace sat {
enum CpSolverStatus : int;
OR_PROTO_DLL extern const uint32_t CpSolverStatus_internal_data_[];
enum DecisionStrategyProto_DomainReductionStrategy : int;
OR_PROTO_DLL extern const uint32_t DecisionStrategyProto_DomainReductionStrategy_internal_data_[];
enum DecisionStrategyProto_VariableSelectionStrategy : int;
OR_PROTO_DLL extern const uint32_t DecisionStrategyProto_VariableSelectionStrategy_internal_data_[];
class AllDifferentConstraintProto;
struct AllDifferentConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern AllDifferentConstraintProtoDefaultTypeInternal _AllDifferentConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull AllDifferentConstraintProto_class_data_;
class AutomatonConstraintProto;
struct AutomatonConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern AutomatonConstraintProtoDefaultTypeInternal _AutomatonConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull AutomatonConstraintProto_class_data_;
class BoolArgumentProto;
struct BoolArgumentProtoDefaultTypeInternal;
OR_PROTO_DLL extern BoolArgumentProtoDefaultTypeInternal _BoolArgumentProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull BoolArgumentProto_class_data_;
class CircuitConstraintProto;
struct CircuitConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern CircuitConstraintProtoDefaultTypeInternal _CircuitConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CircuitConstraintProto_class_data_;
class ConstraintProto;
struct ConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern ConstraintProtoDefaultTypeInternal _ConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ConstraintProto_class_data_;
class CpModelProto;
struct CpModelProtoDefaultTypeInternal;
OR_PROTO_DLL extern CpModelProtoDefaultTypeInternal _CpModelProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpModelProto_class_data_;
class CpObjectiveProto;
struct CpObjectiveProtoDefaultTypeInternal;
OR_PROTO_DLL extern CpObjectiveProtoDefaultTypeInternal _CpObjectiveProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpObjectiveProto_class_data_;
class CpSolverResponse;
struct CpSolverResponseDefaultTypeInternal;
OR_PROTO_DLL extern CpSolverResponseDefaultTypeInternal _CpSolverResponse_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpSolverResponse_class_data_;
class CpSolverSolution;
struct CpSolverSolutionDefaultTypeInternal;
OR_PROTO_DLL extern CpSolverSolutionDefaultTypeInternal _CpSolverSolution_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpSolverSolution_class_data_;
class CumulativeConstraintProto;
struct CumulativeConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern CumulativeConstraintProtoDefaultTypeInternal _CumulativeConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CumulativeConstraintProto_class_data_;
class DecisionStrategyProto;
struct DecisionStrategyProtoDefaultTypeInternal;
OR_PROTO_DLL extern DecisionStrategyProtoDefaultTypeInternal _DecisionStrategyProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull DecisionStrategyProto_class_data_;
class DenseMatrixProto;
struct DenseMatrixProtoDefaultTypeInternal;
OR_PROTO_DLL extern DenseMatrixProtoDefaultTypeInternal _DenseMatrixProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull DenseMatrixProto_class_data_;
class ElementConstraintProto;
struct ElementConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern ElementConstraintProtoDefaultTypeInternal _ElementConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ElementConstraintProto_class_data_;
class FloatObjectiveProto;
struct FloatObjectiveProtoDefaultTypeInternal;
OR_PROTO_DLL extern FloatObjectiveProtoDefaultTypeInternal _FloatObjectiveProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull FloatObjectiveProto_class_data_;
class IntegerVariableProto;
struct IntegerVariableProtoDefaultTypeInternal;
OR_PROTO_DLL extern IntegerVariableProtoDefaultTypeInternal _IntegerVariableProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull IntegerVariableProto_class_data_;
class IntervalConstraintProto;
struct IntervalConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern IntervalConstraintProtoDefaultTypeInternal _IntervalConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull IntervalConstraintProto_class_data_;
class InverseConstraintProto;
struct InverseConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern InverseConstraintProtoDefaultTypeInternal _InverseConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull InverseConstraintProto_class_data_;
class LinearArgumentProto;
struct LinearArgumentProtoDefaultTypeInternal;
OR_PROTO_DLL extern LinearArgumentProtoDefaultTypeInternal _LinearArgumentProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearArgumentProto_class_data_;
class LinearConstraintProto;
struct LinearConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern LinearConstraintProtoDefaultTypeInternal _LinearConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearConstraintProto_class_data_;
class LinearExpressionProto;
struct LinearExpressionProtoDefaultTypeInternal;
OR_PROTO_DLL extern LinearExpressionProtoDefaultTypeInternal _LinearExpressionProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearExpressionProto_class_data_;
class ListOfVariablesProto;
struct ListOfVariablesProtoDefaultTypeInternal;
OR_PROTO_DLL extern ListOfVariablesProtoDefaultTypeInternal _ListOfVariablesProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ListOfVariablesProto_class_data_;
class NoOverlap2DConstraintProto;
struct NoOverlap2DConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern NoOverlap2DConstraintProtoDefaultTypeInternal _NoOverlap2DConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NoOverlap2DConstraintProto_class_data_;
class NoOverlapConstraintProto;
struct NoOverlapConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern NoOverlapConstraintProtoDefaultTypeInternal _NoOverlapConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NoOverlapConstraintProto_class_data_;
class PartialVariableAssignment;
struct PartialVariableAssignmentDefaultTypeInternal;
OR_PROTO_DLL extern PartialVariableAssignmentDefaultTypeInternal _PartialVariableAssignment_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull PartialVariableAssignment_class_data_;
class ReservoirConstraintProto;
struct ReservoirConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern ReservoirConstraintProtoDefaultTypeInternal _ReservoirConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ReservoirConstraintProto_class_data_;
class RoutesConstraintProto;
struct RoutesConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern RoutesConstraintProtoDefaultTypeInternal _RoutesConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_class_data_;
class RoutesConstraintProto_NodeExpressions;
struct RoutesConstraintProto_NodeExpressionsDefaultTypeInternal;
OR_PROTO_DLL extern RoutesConstraintProto_NodeExpressionsDefaultTypeInternal _RoutesConstraintProto_NodeExpressions_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_NodeExpressions_class_data_;
class SparsePermutationProto;
struct SparsePermutationProtoDefaultTypeInternal;
OR_PROTO_DLL extern SparsePermutationProtoDefaultTypeInternal _SparsePermutationProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull SparsePermutationProto_class_data_;
class SymmetryProto;
struct SymmetryProtoDefaultTypeInternal;
OR_PROTO_DLL extern SymmetryProtoDefaultTypeInternal _SymmetryProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull SymmetryProto_class_data_;
class TableConstraintProto;
struct TableConstraintProtoDefaultTypeInternal;
OR_PROTO_DLL extern TableConstraintProtoDefaultTypeInternal _TableConstraintProto_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull TableConstraintProto_class_data_;
}  // namespace sat
}  // namespace operations_research
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::operations_research::sat::CpSolverStatus_internal_data_>
    internal::EnumTraitsImpl::value<::operations_research::sat::CpSolverStatus>;
template <>
internal::EnumTraitsT<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy_internal_data_>
    internal::EnumTraitsImpl::value<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy>;
template <>
internal::EnumTraitsT<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy_internal_data_>
    internal::EnumTraitsImpl::value<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy>;
}  // namespace protobuf
}  // namespace google

namespace operations_research {
namespace sat {
enum DecisionStrategyProto_VariableSelectionStrategy : int {
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_FIRST = 0,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_LOWEST_MIN = 1,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_HIGHEST_MAX = 2,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MIN_DOMAIN_SIZE = 3,
  DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MAX_DOMAIN_SIZE = 4,
  DecisionStrategyProto_VariableSelectionStrategy_DecisionStrategyProto_VariableSelectionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DecisionStrategyProto_VariableSelectionStrategy_DecisionStrategyProto_VariableSelectionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

OR_PROTO_DLL extern const uint32_t DecisionStrategyProto_VariableSelectionStrategy_internal_data_[];
inline constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MIN =
    static_cast<DecisionStrategyProto_VariableSelectionStrategy>(0);
inline constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MAX =
    static_cast<DecisionStrategyProto_VariableSelectionStrategy>(4);
inline bool DecisionStrategyProto_VariableSelectionStrategy_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_ARRAYSIZE = 4 + 1;
OR_PROTO_DLL const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DecisionStrategyProto_VariableSelectionStrategy_descriptor();
template <typename T>
const ::std::string& DecisionStrategyProto_VariableSelectionStrategy_Name(T value) {
  static_assert(::std::is_same<T, DecisionStrategyProto_VariableSelectionStrategy>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to VariableSelectionStrategy_Name().");
  return DecisionStrategyProto_VariableSelectionStrategy_Name(static_cast<DecisionStrategyProto_VariableSelectionStrategy>(value));
}
template <>
inline const ::std::string& DecisionStrategyProto_VariableSelectionStrategy_Name(DecisionStrategyProto_VariableSelectionStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DecisionStrategyProto_VariableSelectionStrategy_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool DecisionStrategyProto_VariableSelectionStrategy_Parse(
    ::absl::string_view name, DecisionStrategyProto_VariableSelectionStrategy* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecisionStrategyProto_VariableSelectionStrategy>(DecisionStrategyProto_VariableSelectionStrategy_descriptor(), name,
                                           value);
}
enum DecisionStrategyProto_DomainReductionStrategy : int {
  DecisionStrategyProto_DomainReductionStrategy_SELECT_MIN_VALUE = 0,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_MAX_VALUE = 1,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_LOWER_HALF = 2,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_UPPER_HALF = 3,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_MEDIAN_VALUE = 4,
  DecisionStrategyProto_DomainReductionStrategy_SELECT_RANDOM_HALF = 5,
  DecisionStrategyProto_DomainReductionStrategy_DecisionStrategyProto_DomainReductionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  DecisionStrategyProto_DomainReductionStrategy_DecisionStrategyProto_DomainReductionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

OR_PROTO_DLL extern const uint32_t DecisionStrategyProto_DomainReductionStrategy_internal_data_[];
inline constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MIN =
    static_cast<DecisionStrategyProto_DomainReductionStrategy>(0);
inline constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MAX =
    static_cast<DecisionStrategyProto_DomainReductionStrategy>(5);
inline bool DecisionStrategyProto_DomainReductionStrategy_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_ARRAYSIZE = 5 + 1;
OR_PROTO_DLL const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DecisionStrategyProto_DomainReductionStrategy_descriptor();
template <typename T>
const ::std::string& DecisionStrategyProto_DomainReductionStrategy_Name(T value) {
  static_assert(::std::is_same<T, DecisionStrategyProto_DomainReductionStrategy>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DomainReductionStrategy_Name().");
  return DecisionStrategyProto_DomainReductionStrategy_Name(static_cast<DecisionStrategyProto_DomainReductionStrategy>(value));
}
template <>
inline const ::std::string& DecisionStrategyProto_DomainReductionStrategy_Name(DecisionStrategyProto_DomainReductionStrategy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DecisionStrategyProto_DomainReductionStrategy_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool DecisionStrategyProto_DomainReductionStrategy_Parse(
    ::absl::string_view name, DecisionStrategyProto_DomainReductionStrategy* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecisionStrategyProto_DomainReductionStrategy>(DecisionStrategyProto_DomainReductionStrategy_descriptor(), name,
                                           value);
}
enum CpSolverStatus : int {
  UNKNOWN = 0,
  MODEL_INVALID = 1,
  FEASIBLE = 2,
  INFEASIBLE = 3,
  OPTIMAL = 4,
  CpSolverStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  CpSolverStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

OR_PROTO_DLL extern const uint32_t CpSolverStatus_internal_data_[];
inline constexpr CpSolverStatus CpSolverStatus_MIN =
    static_cast<CpSolverStatus>(0);
inline constexpr CpSolverStatus CpSolverStatus_MAX =
    static_cast<CpSolverStatus>(4);
inline bool CpSolverStatus_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int CpSolverStatus_ARRAYSIZE = 4 + 1;
OR_PROTO_DLL const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CpSolverStatus_descriptor();
template <typename T>
const ::std::string& CpSolverStatus_Name(T value) {
  static_assert(::std::is_same<T, CpSolverStatus>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CpSolverStatus_Name().");
  return CpSolverStatus_Name(static_cast<CpSolverStatus>(value));
}
template <>
inline const ::std::string& CpSolverStatus_Name(CpSolverStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CpSolverStatus_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool CpSolverStatus_Parse(
    ::absl::string_view name, CpSolverStatus* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<CpSolverStatus>(CpSolverStatus_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class OR_PROTO_DLL SparsePermutationProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.SparsePermutationProto) */ {
 public:
  inline SparsePermutationProto() : SparsePermutationProto(nullptr) {}
  ~SparsePermutationProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SparsePermutationProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SparsePermutationProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SparsePermutationProto(::google::protobuf::internal::ConstantInitialized);

  inline SparsePermutationProto(const SparsePermutationProto& from) : SparsePermutationProto(nullptr, from) {}
  inline SparsePermutationProto(SparsePermutationProto&& from) noexcept
      : SparsePermutationProto(nullptr, ::std::move(from)) {}
  inline SparsePermutationProto& operator=(const SparsePermutationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparsePermutationProto& operator=(SparsePermutationProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparsePermutationProto& default_instance() {
    return *reinterpret_cast<const SparsePermutationProto*>(
        &_SparsePermutationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(SparsePermutationProto& a, SparsePermutationProto& b) { a.Swap(&b); }
  inline void Swap(SparsePermutationProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparsePermutationProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparsePermutationProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SparsePermutationProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SparsePermutationProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SparsePermutationProto& from) { SparsePermutationProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SparsePermutationProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.SparsePermutationProto"; }

  explicit SparsePermutationProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SparsePermutationProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SparsePermutationProto& from);
  SparsePermutationProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SparsePermutationProto&& from) noexcept
      : SparsePermutationProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSupportFieldNumber = 1,
    kCycleSizesFieldNumber = 2,
  };
  // repeated int32 support = 1;
  int support_size() const;
  private:
  int _internal_support_size() const;

  public:
  void clear_support() ;
  ::int32_t support(int index) const;
  void set_support(int index, ::int32_t value);
  void add_support(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& support() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_support();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_support() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_support();

  public:
  // repeated int32 cycle_sizes = 2;
  int cycle_sizes_size() const;
  private:
  int _internal_cycle_sizes_size() const;

  public:
  void clear_cycle_sizes() ;
  ::int32_t cycle_sizes(int index) const;
  void set_cycle_sizes(int index, ::int32_t value);
  void add_cycle_sizes(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& cycle_sizes() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_cycle_sizes();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_cycle_sizes() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_cycle_sizes();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.SparsePermutationProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SparsePermutationProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> support_;
    ::google::protobuf::internal::CachedSize _support_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> cycle_sizes_;
    ::google::protobuf::internal::CachedSize _cycle_sizes_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull SparsePermutationProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL PartialVariableAssignment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.PartialVariableAssignment) */ {
 public:
  inline PartialVariableAssignment() : PartialVariableAssignment(nullptr) {}
  ~PartialVariableAssignment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PartialVariableAssignment* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PartialVariableAssignment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartialVariableAssignment(::google::protobuf::internal::ConstantInitialized);

  inline PartialVariableAssignment(const PartialVariableAssignment& from) : PartialVariableAssignment(nullptr, from) {}
  inline PartialVariableAssignment(PartialVariableAssignment&& from) noexcept
      : PartialVariableAssignment(nullptr, ::std::move(from)) {}
  inline PartialVariableAssignment& operator=(const PartialVariableAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartialVariableAssignment& operator=(PartialVariableAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartialVariableAssignment& default_instance() {
    return *reinterpret_cast<const PartialVariableAssignment*>(
        &_PartialVariableAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(PartialVariableAssignment& a, PartialVariableAssignment& b) { a.Swap(&b); }
  inline void Swap(PartialVariableAssignment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartialVariableAssignment* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartialVariableAssignment* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PartialVariableAssignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartialVariableAssignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartialVariableAssignment& from) { PartialVariableAssignment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PartialVariableAssignment* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.PartialVariableAssignment"; }

  explicit PartialVariableAssignment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PartialVariableAssignment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PartialVariableAssignment& from);
  PartialVariableAssignment(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PartialVariableAssignment&& from) noexcept
      : PartialVariableAssignment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kValuesFieldNumber = 2,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated int64 values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.PartialVariableAssignment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PartialVariableAssignment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> values_;
    ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull PartialVariableAssignment_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL NoOverlapConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.NoOverlapConstraintProto) */ {
 public:
  inline NoOverlapConstraintProto() : NoOverlapConstraintProto(nullptr) {}
  ~NoOverlapConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NoOverlapConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NoOverlapConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoOverlapConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline NoOverlapConstraintProto(const NoOverlapConstraintProto& from) : NoOverlapConstraintProto(nullptr, from) {}
  inline NoOverlapConstraintProto(NoOverlapConstraintProto&& from) noexcept
      : NoOverlapConstraintProto(nullptr, ::std::move(from)) {}
  inline NoOverlapConstraintProto& operator=(const NoOverlapConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoOverlapConstraintProto& operator=(NoOverlapConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoOverlapConstraintProto& default_instance() {
    return *reinterpret_cast<const NoOverlapConstraintProto*>(
        &_NoOverlapConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(NoOverlapConstraintProto& a, NoOverlapConstraintProto& b) { a.Swap(&b); }
  inline void Swap(NoOverlapConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoOverlapConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoOverlapConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NoOverlapConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoOverlapConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NoOverlapConstraintProto& from) { NoOverlapConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NoOverlapConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.NoOverlapConstraintProto"; }

  explicit NoOverlapConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NoOverlapConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NoOverlapConstraintProto& from);
  NoOverlapConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NoOverlapConstraintProto&& from) noexcept
      : NoOverlapConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIntervalsFieldNumber = 1,
  };
  // repeated int32 intervals = 1;
  int intervals_size() const;
  private:
  int _internal_intervals_size() const;

  public:
  void clear_intervals() ;
  ::int32_t intervals(int index) const;
  void set_intervals(int index, ::int32_t value);
  void add_intervals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_intervals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_intervals();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.NoOverlapConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NoOverlapConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> intervals_;
    ::google::protobuf::internal::CachedSize _intervals_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NoOverlapConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL NoOverlap2DConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.NoOverlap2DConstraintProto) */ {
 public:
  inline NoOverlap2DConstraintProto() : NoOverlap2DConstraintProto(nullptr) {}
  ~NoOverlap2DConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NoOverlap2DConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NoOverlap2DConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoOverlap2DConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline NoOverlap2DConstraintProto(const NoOverlap2DConstraintProto& from) : NoOverlap2DConstraintProto(nullptr, from) {}
  inline NoOverlap2DConstraintProto(NoOverlap2DConstraintProto&& from) noexcept
      : NoOverlap2DConstraintProto(nullptr, ::std::move(from)) {}
  inline NoOverlap2DConstraintProto& operator=(const NoOverlap2DConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoOverlap2DConstraintProto& operator=(NoOverlap2DConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoOverlap2DConstraintProto& default_instance() {
    return *reinterpret_cast<const NoOverlap2DConstraintProto*>(
        &_NoOverlap2DConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(NoOverlap2DConstraintProto& a, NoOverlap2DConstraintProto& b) { a.Swap(&b); }
  inline void Swap(NoOverlap2DConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoOverlap2DConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoOverlap2DConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NoOverlap2DConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoOverlap2DConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NoOverlap2DConstraintProto& from) { NoOverlap2DConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NoOverlap2DConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.NoOverlap2DConstraintProto"; }

  explicit NoOverlap2DConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NoOverlap2DConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NoOverlap2DConstraintProto& from);
  NoOverlap2DConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NoOverlap2DConstraintProto&& from) noexcept
      : NoOverlap2DConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXIntervalsFieldNumber = 1,
    kYIntervalsFieldNumber = 2,
  };
  // repeated int32 x_intervals = 1;
  int x_intervals_size() const;
  private:
  int _internal_x_intervals_size() const;

  public:
  void clear_x_intervals() ;
  ::int32_t x_intervals(int index) const;
  void set_x_intervals(int index, ::int32_t value);
  void add_x_intervals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& x_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_x_intervals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_x_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_x_intervals();

  public:
  // repeated int32 y_intervals = 2;
  int y_intervals_size() const;
  private:
  int _internal_y_intervals_size() const;

  public:
  void clear_y_intervals() ;
  ::int32_t y_intervals(int index) const;
  void set_y_intervals(int index, ::int32_t value);
  void add_y_intervals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& y_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_y_intervals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_y_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_y_intervals();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.NoOverlap2DConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NoOverlap2DConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> x_intervals_;
    ::google::protobuf::internal::CachedSize _x_intervals_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> y_intervals_;
    ::google::protobuf::internal::CachedSize _y_intervals_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NoOverlap2DConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL ListOfVariablesProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.ListOfVariablesProto) */ {
 public:
  inline ListOfVariablesProto() : ListOfVariablesProto(nullptr) {}
  ~ListOfVariablesProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListOfVariablesProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListOfVariablesProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListOfVariablesProto(::google::protobuf::internal::ConstantInitialized);

  inline ListOfVariablesProto(const ListOfVariablesProto& from) : ListOfVariablesProto(nullptr, from) {}
  inline ListOfVariablesProto(ListOfVariablesProto&& from) noexcept
      : ListOfVariablesProto(nullptr, ::std::move(from)) {}
  inline ListOfVariablesProto& operator=(const ListOfVariablesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListOfVariablesProto& operator=(ListOfVariablesProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListOfVariablesProto& default_instance() {
    return *reinterpret_cast<const ListOfVariablesProto*>(
        &_ListOfVariablesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ListOfVariablesProto& a, ListOfVariablesProto& b) { a.Swap(&b); }
  inline void Swap(ListOfVariablesProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListOfVariablesProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListOfVariablesProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListOfVariablesProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListOfVariablesProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListOfVariablesProto& from) { ListOfVariablesProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListOfVariablesProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.ListOfVariablesProto"; }

  explicit ListOfVariablesProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ListOfVariablesProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ListOfVariablesProto& from);
  ListOfVariablesProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ListOfVariablesProto&& from) noexcept
      : ListOfVariablesProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.ListOfVariablesProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ListOfVariablesProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ListOfVariablesProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL LinearExpressionProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.LinearExpressionProto) */ {
 public:
  inline LinearExpressionProto() : LinearExpressionProto(nullptr) {}
  ~LinearExpressionProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LinearExpressionProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LinearExpressionProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearExpressionProto(::google::protobuf::internal::ConstantInitialized);

  inline LinearExpressionProto(const LinearExpressionProto& from) : LinearExpressionProto(nullptr, from) {}
  inline LinearExpressionProto(LinearExpressionProto&& from) noexcept
      : LinearExpressionProto(nullptr, ::std::move(from)) {}
  inline LinearExpressionProto& operator=(const LinearExpressionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearExpressionProto& operator=(LinearExpressionProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearExpressionProto& default_instance() {
    return *reinterpret_cast<const LinearExpressionProto*>(
        &_LinearExpressionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LinearExpressionProto& a, LinearExpressionProto& b) { a.Swap(&b); }
  inline void Swap(LinearExpressionProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearExpressionProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearExpressionProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LinearExpressionProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearExpressionProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearExpressionProto& from) { LinearExpressionProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LinearExpressionProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.LinearExpressionProto"; }

  explicit LinearExpressionProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LinearExpressionProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LinearExpressionProto& from);
  LinearExpressionProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LinearExpressionProto&& from) noexcept
      : LinearExpressionProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kCoeffsFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated int64 coeffs = 2;
  int coeffs_size() const;
  private:
  int _internal_coeffs_size() const;

  public:
  void clear_coeffs() ;
  ::int64_t coeffs(int index) const;
  void set_coeffs(int index, ::int64_t value);
  void add_coeffs(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_coeffs();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_coeffs();

  public:
  // int64 offset = 3;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.LinearExpressionProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LinearExpressionProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> coeffs_;
    ::google::protobuf::internal::CachedSize _coeffs_cached_byte_size_;
    ::int64_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearExpressionProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL LinearConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.LinearConstraintProto) */ {
 public:
  inline LinearConstraintProto() : LinearConstraintProto(nullptr) {}
  ~LinearConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LinearConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LinearConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline LinearConstraintProto(const LinearConstraintProto& from) : LinearConstraintProto(nullptr, from) {}
  inline LinearConstraintProto(LinearConstraintProto&& from) noexcept
      : LinearConstraintProto(nullptr, ::std::move(from)) {}
  inline LinearConstraintProto& operator=(const LinearConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearConstraintProto& operator=(LinearConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearConstraintProto& default_instance() {
    return *reinterpret_cast<const LinearConstraintProto*>(
        &_LinearConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(LinearConstraintProto& a, LinearConstraintProto& b) { a.Swap(&b); }
  inline void Swap(LinearConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LinearConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearConstraintProto& from) { LinearConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LinearConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.LinearConstraintProto"; }

  explicit LinearConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LinearConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LinearConstraintProto& from);
  LinearConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LinearConstraintProto&& from) noexcept
      : LinearConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kCoeffsFieldNumber = 2,
    kDomainFieldNumber = 3,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated int64 coeffs = 2;
  int coeffs_size() const;
  private:
  int _internal_coeffs_size() const;

  public:
  void clear_coeffs() ;
  ::int64_t coeffs(int index) const;
  void set_coeffs(int index, ::int64_t value);
  void add_coeffs(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_coeffs();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_coeffs();

  public:
  // repeated int64 domain = 3;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  ::int64_t domain(int index) const;
  void set_domain(int index, ::int64_t value);
  void add_domain(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_domain();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_domain();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.LinearConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LinearConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> coeffs_;
    ::google::protobuf::internal::CachedSize _coeffs_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> domain_;
    ::google::protobuf::internal::CachedSize _domain_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL InverseConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.InverseConstraintProto) */ {
 public:
  inline InverseConstraintProto() : InverseConstraintProto(nullptr) {}
  ~InverseConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InverseConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InverseConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InverseConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline InverseConstraintProto(const InverseConstraintProto& from) : InverseConstraintProto(nullptr, from) {}
  inline InverseConstraintProto(InverseConstraintProto&& from) noexcept
      : InverseConstraintProto(nullptr, ::std::move(from)) {}
  inline InverseConstraintProto& operator=(const InverseConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InverseConstraintProto& operator=(InverseConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InverseConstraintProto& default_instance() {
    return *reinterpret_cast<const InverseConstraintProto*>(
        &_InverseConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(InverseConstraintProto& a, InverseConstraintProto& b) { a.Swap(&b); }
  inline void Swap(InverseConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InverseConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InverseConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InverseConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InverseConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InverseConstraintProto& from) { InverseConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InverseConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.InverseConstraintProto"; }

  explicit InverseConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InverseConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InverseConstraintProto& from);
  InverseConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InverseConstraintProto&& from) noexcept
      : InverseConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFDirectFieldNumber = 1,
    kFInverseFieldNumber = 2,
  };
  // repeated int32 f_direct = 1;
  int f_direct_size() const;
  private:
  int _internal_f_direct_size() const;

  public:
  void clear_f_direct() ;
  ::int32_t f_direct(int index) const;
  void set_f_direct(int index, ::int32_t value);
  void add_f_direct(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& f_direct() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_f_direct();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_f_direct() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_f_direct();

  public:
  // repeated int32 f_inverse = 2;
  int f_inverse_size() const;
  private:
  int _internal_f_inverse_size() const;

  public:
  void clear_f_inverse() ;
  ::int32_t f_inverse(int index) const;
  void set_f_inverse(int index, ::int32_t value);
  void add_f_inverse(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& f_inverse() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_f_inverse();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_f_inverse() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_f_inverse();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.InverseConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InverseConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> f_direct_;
    ::google::protobuf::internal::CachedSize _f_direct_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> f_inverse_;
    ::google::protobuf::internal::CachedSize _f_inverse_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull InverseConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL IntegerVariableProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.IntegerVariableProto) */ {
 public:
  inline IntegerVariableProto() : IntegerVariableProto(nullptr) {}
  ~IntegerVariableProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IntegerVariableProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IntegerVariableProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntegerVariableProto(::google::protobuf::internal::ConstantInitialized);

  inline IntegerVariableProto(const IntegerVariableProto& from) : IntegerVariableProto(nullptr, from) {}
  inline IntegerVariableProto(IntegerVariableProto&& from) noexcept
      : IntegerVariableProto(nullptr, ::std::move(from)) {}
  inline IntegerVariableProto& operator=(const IntegerVariableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerVariableProto& operator=(IntegerVariableProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerVariableProto& default_instance() {
    return *reinterpret_cast<const IntegerVariableProto*>(
        &_IntegerVariableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(IntegerVariableProto& a, IntegerVariableProto& b) { a.Swap(&b); }
  inline void Swap(IntegerVariableProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerVariableProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerVariableProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IntegerVariableProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntegerVariableProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IntegerVariableProto& from) { IntegerVariableProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IntegerVariableProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.IntegerVariableProto"; }

  explicit IntegerVariableProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IntegerVariableProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IntegerVariableProto& from);
  IntegerVariableProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IntegerVariableProto&& from) noexcept
      : IntegerVariableProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDomainFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated int64 domain = 2;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  ::int64_t domain(int index) const;
  void set_domain(int index, ::int64_t value);
  void add_domain(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_domain();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_domain();

  public:
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.IntegerVariableProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IntegerVariableProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> domain_;
    ::google::protobuf::internal::CachedSize _domain_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull IntegerVariableProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL FloatObjectiveProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.FloatObjectiveProto) */ {
 public:
  inline FloatObjectiveProto() : FloatObjectiveProto(nullptr) {}
  ~FloatObjectiveProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FloatObjectiveProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FloatObjectiveProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FloatObjectiveProto(::google::protobuf::internal::ConstantInitialized);

  inline FloatObjectiveProto(const FloatObjectiveProto& from) : FloatObjectiveProto(nullptr, from) {}
  inline FloatObjectiveProto(FloatObjectiveProto&& from) noexcept
      : FloatObjectiveProto(nullptr, ::std::move(from)) {}
  inline FloatObjectiveProto& operator=(const FloatObjectiveProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatObjectiveProto& operator=(FloatObjectiveProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatObjectiveProto& default_instance() {
    return *reinterpret_cast<const FloatObjectiveProto*>(
        &_FloatObjectiveProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(FloatObjectiveProto& a, FloatObjectiveProto& b) { a.Swap(&b); }
  inline void Swap(FloatObjectiveProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatObjectiveProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatObjectiveProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FloatObjectiveProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatObjectiveProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FloatObjectiveProto& from) { FloatObjectiveProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FloatObjectiveProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.FloatObjectiveProto"; }

  explicit FloatObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FloatObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FloatObjectiveProto& from);
  FloatObjectiveProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FloatObjectiveProto&& from) noexcept
      : FloatObjectiveProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kCoeffsFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kMaximizeFieldNumber = 4,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated double coeffs = 2;
  int coeffs_size() const;
  private:
  int _internal_coeffs_size() const;

  public:
  void clear_coeffs() ;
  double coeffs(int index) const;
  void set_coeffs(int index, double value);
  void add_coeffs(double value);
  const ::google::protobuf::RepeatedField<double>& coeffs() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_coeffs();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_coeffs() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_coeffs();

  public:
  // double offset = 3;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // bool maximize = 4;
  void clear_maximize() ;
  bool maximize() const;
  void set_maximize(bool value);

  private:
  bool _internal_maximize() const;
  void _internal_set_maximize(bool value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.FloatObjectiveProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FloatObjectiveProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> coeffs_;
    double offset_;
    bool maximize_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull FloatObjectiveProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL DenseMatrixProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.DenseMatrixProto) */ {
 public:
  inline DenseMatrixProto() : DenseMatrixProto(nullptr) {}
  ~DenseMatrixProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DenseMatrixProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DenseMatrixProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DenseMatrixProto(::google::protobuf::internal::ConstantInitialized);

  inline DenseMatrixProto(const DenseMatrixProto& from) : DenseMatrixProto(nullptr, from) {}
  inline DenseMatrixProto(DenseMatrixProto&& from) noexcept
      : DenseMatrixProto(nullptr, ::std::move(from)) {}
  inline DenseMatrixProto& operator=(const DenseMatrixProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenseMatrixProto& operator=(DenseMatrixProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenseMatrixProto& default_instance() {
    return *reinterpret_cast<const DenseMatrixProto*>(
        &_DenseMatrixProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DenseMatrixProto& a, DenseMatrixProto& b) { a.Swap(&b); }
  inline void Swap(DenseMatrixProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenseMatrixProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DenseMatrixProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DenseMatrixProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DenseMatrixProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DenseMatrixProto& from) { DenseMatrixProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DenseMatrixProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.DenseMatrixProto"; }

  explicit DenseMatrixProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DenseMatrixProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DenseMatrixProto& from);
  DenseMatrixProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DenseMatrixProto&& from) noexcept
      : DenseMatrixProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 3,
    kNumRowsFieldNumber = 1,
    kNumColsFieldNumber = 2,
  };
  // repeated int32 entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::int32_t entries(int index) const;
  void set_entries(int index, ::int32_t value);
  void add_entries(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& entries() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_entries();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_entries() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_entries();

  public:
  // int32 num_rows = 1;
  void clear_num_rows() ;
  ::int32_t num_rows() const;
  void set_num_rows(::int32_t value);

  private:
  ::int32_t _internal_num_rows() const;
  void _internal_set_num_rows(::int32_t value);

  public:
  // int32 num_cols = 2;
  void clear_num_cols() ;
  ::int32_t num_cols() const;
  void set_num_cols(::int32_t value);

  private:
  ::int32_t _internal_num_cols() const;
  void _internal_set_num_cols(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.DenseMatrixProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DenseMatrixProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> entries_;
    ::google::protobuf::internal::CachedSize _entries_cached_byte_size_;
    ::int32_t num_rows_;
    ::int32_t num_cols_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull DenseMatrixProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CpSolverSolution final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CpSolverSolution) */ {
 public:
  inline CpSolverSolution() : CpSolverSolution(nullptr) {}
  ~CpSolverSolution() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CpSolverSolution* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CpSolverSolution));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CpSolverSolution(::google::protobuf::internal::ConstantInitialized);

  inline CpSolverSolution(const CpSolverSolution& from) : CpSolverSolution(nullptr, from) {}
  inline CpSolverSolution(CpSolverSolution&& from) noexcept
      : CpSolverSolution(nullptr, ::std::move(from)) {}
  inline CpSolverSolution& operator=(const CpSolverSolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpSolverSolution& operator=(CpSolverSolution&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpSolverSolution& default_instance() {
    return *reinterpret_cast<const CpSolverSolution*>(
        &_CpSolverSolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(CpSolverSolution& a, CpSolverSolution& b) { a.Swap(&b); }
  inline void Swap(CpSolverSolution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpSolverSolution* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpSolverSolution* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CpSolverSolution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CpSolverSolution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CpSolverSolution& from) { CpSolverSolution::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CpSolverSolution* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CpSolverSolution"; }

  explicit CpSolverSolution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CpSolverSolution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CpSolverSolution& from);
  CpSolverSolution(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CpSolverSolution&& from) noexcept
      : CpSolverSolution(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CpSolverSolution)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CpSolverSolution& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> values_;
    ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpSolverSolution_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CpObjectiveProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CpObjectiveProto) */ {
 public:
  inline CpObjectiveProto() : CpObjectiveProto(nullptr) {}
  ~CpObjectiveProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CpObjectiveProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CpObjectiveProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CpObjectiveProto(::google::protobuf::internal::ConstantInitialized);

  inline CpObjectiveProto(const CpObjectiveProto& from) : CpObjectiveProto(nullptr, from) {}
  inline CpObjectiveProto(CpObjectiveProto&& from) noexcept
      : CpObjectiveProto(nullptr, ::std::move(from)) {}
  inline CpObjectiveProto& operator=(const CpObjectiveProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpObjectiveProto& operator=(CpObjectiveProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpObjectiveProto& default_instance() {
    return *reinterpret_cast<const CpObjectiveProto*>(
        &_CpObjectiveProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CpObjectiveProto& a, CpObjectiveProto& b) { a.Swap(&b); }
  inline void Swap(CpObjectiveProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpObjectiveProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpObjectiveProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CpObjectiveProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CpObjectiveProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CpObjectiveProto& from) { CpObjectiveProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CpObjectiveProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CpObjectiveProto"; }

  explicit CpObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CpObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CpObjectiveProto& from);
  CpObjectiveProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CpObjectiveProto&& from) noexcept
      : CpObjectiveProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kCoeffsFieldNumber = 4,
    kDomainFieldNumber = 5,
    kOffsetFieldNumber = 2,
    kScalingFactorFieldNumber = 3,
    kIntegerBeforeOffsetFieldNumber = 7,
    kIntegerScalingFactorFieldNumber = 8,
    kIntegerAfterOffsetFieldNumber = 9,
    kScalingWasExactFieldNumber = 6,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated int64 coeffs = 4;
  int coeffs_size() const;
  private:
  int _internal_coeffs_size() const;

  public:
  void clear_coeffs() ;
  ::int64_t coeffs(int index) const;
  void set_coeffs(int index, ::int64_t value);
  void add_coeffs(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_coeffs();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_coeffs() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_coeffs();

  public:
  // repeated int64 domain = 5;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  ::int64_t domain(int index) const;
  void set_domain(int index, ::int64_t value);
  void add_domain(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_domain();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_domain() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_domain();

  public:
  // double offset = 2;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // double scaling_factor = 3;
  void clear_scaling_factor() ;
  double scaling_factor() const;
  void set_scaling_factor(double value);

  private:
  double _internal_scaling_factor() const;
  void _internal_set_scaling_factor(double value);

  public:
  // int64 integer_before_offset = 7;
  void clear_integer_before_offset() ;
  ::int64_t integer_before_offset() const;
  void set_integer_before_offset(::int64_t value);

  private:
  ::int64_t _internal_integer_before_offset() const;
  void _internal_set_integer_before_offset(::int64_t value);

  public:
  // int64 integer_scaling_factor = 8;
  void clear_integer_scaling_factor() ;
  ::int64_t integer_scaling_factor() const;
  void set_integer_scaling_factor(::int64_t value);

  private:
  ::int64_t _internal_integer_scaling_factor() const;
  void _internal_set_integer_scaling_factor(::int64_t value);

  public:
  // int64 integer_after_offset = 9;
  void clear_integer_after_offset() ;
  ::int64_t integer_after_offset() const;
  void set_integer_after_offset(::int64_t value);

  private:
  ::int64_t _internal_integer_after_offset() const;
  void _internal_set_integer_after_offset(::int64_t value);

  public:
  // bool scaling_was_exact = 6;
  void clear_scaling_was_exact() ;
  bool scaling_was_exact() const;
  void set_scaling_was_exact(bool value);

  private:
  bool _internal_scaling_was_exact() const;
  void _internal_set_scaling_was_exact(bool value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CpObjectiveProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CpObjectiveProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> coeffs_;
    ::google::protobuf::internal::CachedSize _coeffs_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> domain_;
    ::google::protobuf::internal::CachedSize _domain_cached_byte_size_;
    double offset_;
    double scaling_factor_;
    ::int64_t integer_before_offset_;
    ::int64_t integer_scaling_factor_;
    ::int64_t integer_after_offset_;
    bool scaling_was_exact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpObjectiveProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CircuitConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CircuitConstraintProto) */ {
 public:
  inline CircuitConstraintProto() : CircuitConstraintProto(nullptr) {}
  ~CircuitConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CircuitConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CircuitConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CircuitConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline CircuitConstraintProto(const CircuitConstraintProto& from) : CircuitConstraintProto(nullptr, from) {}
  inline CircuitConstraintProto(CircuitConstraintProto&& from) noexcept
      : CircuitConstraintProto(nullptr, ::std::move(from)) {}
  inline CircuitConstraintProto& operator=(const CircuitConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircuitConstraintProto& operator=(CircuitConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircuitConstraintProto& default_instance() {
    return *reinterpret_cast<const CircuitConstraintProto*>(
        &_CircuitConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CircuitConstraintProto& a, CircuitConstraintProto& b) { a.Swap(&b); }
  inline void Swap(CircuitConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircuitConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircuitConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CircuitConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CircuitConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CircuitConstraintProto& from) { CircuitConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CircuitConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CircuitConstraintProto"; }

  explicit CircuitConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CircuitConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CircuitConstraintProto& from);
  CircuitConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CircuitConstraintProto&& from) noexcept
      : CircuitConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTailsFieldNumber = 3,
    kHeadsFieldNumber = 4,
    kLiteralsFieldNumber = 5,
  };
  // repeated int32 tails = 3;
  int tails_size() const;
  private:
  int _internal_tails_size() const;

  public:
  void clear_tails() ;
  ::int32_t tails(int index) const;
  void set_tails(int index, ::int32_t value);
  void add_tails(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& tails() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_tails();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_tails() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_tails();

  public:
  // repeated int32 heads = 4;
  int heads_size() const;
  private:
  int _internal_heads_size() const;

  public:
  void clear_heads() ;
  ::int32_t heads(int index) const;
  void set_heads(int index, ::int32_t value);
  void add_heads(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& heads() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_heads();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_heads() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_heads();

  public:
  // repeated int32 literals = 5;
  int literals_size() const;
  private:
  int _internal_literals_size() const;

  public:
  void clear_literals() ;
  ::int32_t literals(int index) const;
  void set_literals(int index, ::int32_t value);
  void add_literals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_literals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_literals();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CircuitConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CircuitConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> tails_;
    ::google::protobuf::internal::CachedSize _tails_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> heads_;
    ::google::protobuf::internal::CachedSize _heads_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> literals_;
    ::google::protobuf::internal::CachedSize _literals_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CircuitConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL BoolArgumentProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.BoolArgumentProto) */ {
 public:
  inline BoolArgumentProto() : BoolArgumentProto(nullptr) {}
  ~BoolArgumentProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BoolArgumentProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BoolArgumentProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BoolArgumentProto(::google::protobuf::internal::ConstantInitialized);

  inline BoolArgumentProto(const BoolArgumentProto& from) : BoolArgumentProto(nullptr, from) {}
  inline BoolArgumentProto(BoolArgumentProto&& from) noexcept
      : BoolArgumentProto(nullptr, ::std::move(from)) {}
  inline BoolArgumentProto& operator=(const BoolArgumentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolArgumentProto& operator=(BoolArgumentProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolArgumentProto& default_instance() {
    return *reinterpret_cast<const BoolArgumentProto*>(
        &_BoolArgumentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(BoolArgumentProto& a, BoolArgumentProto& b) { a.Swap(&b); }
  inline void Swap(BoolArgumentProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolArgumentProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolArgumentProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BoolArgumentProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolArgumentProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BoolArgumentProto& from) { BoolArgumentProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BoolArgumentProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.BoolArgumentProto"; }

  explicit BoolArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BoolArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BoolArgumentProto& from);
  BoolArgumentProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BoolArgumentProto&& from) noexcept
      : BoolArgumentProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLiteralsFieldNumber = 1,
  };
  // repeated int32 literals = 1;
  int literals_size() const;
  private:
  int _internal_literals_size() const;

  public:
  void clear_literals() ;
  ::int32_t literals(int index) const;
  void set_literals(int index, ::int32_t value);
  void add_literals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_literals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_literals();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.BoolArgumentProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BoolArgumentProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> literals_;
    ::google::protobuf::internal::CachedSize _literals_cached_byte_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull BoolArgumentProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL TableConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.TableConstraintProto) */ {
 public:
  inline TableConstraintProto() : TableConstraintProto(nullptr) {}
  ~TableConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TableConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TableConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TableConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline TableConstraintProto(const TableConstraintProto& from) : TableConstraintProto(nullptr, from) {}
  inline TableConstraintProto(TableConstraintProto&& from) noexcept
      : TableConstraintProto(nullptr, ::std::move(from)) {}
  inline TableConstraintProto& operator=(const TableConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableConstraintProto& operator=(TableConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableConstraintProto& default_instance() {
    return *reinterpret_cast<const TableConstraintProto*>(
        &_TableConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(TableConstraintProto& a, TableConstraintProto& b) { a.Swap(&b); }
  inline void Swap(TableConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TableConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TableConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TableConstraintProto& from) { TableConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TableConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.TableConstraintProto"; }

  explicit TableConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TableConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TableConstraintProto& from);
  TableConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TableConstraintProto&& from) noexcept
      : TableConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 1,
    kValuesFieldNumber = 2,
    kExprsFieldNumber = 4,
    kNegatedFieldNumber = 3,
  };
  // repeated int32 vars = 1;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated int64 values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_values();

  public:
  // repeated .operations_research.sat.LinearExpressionProto exprs = 4;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // bool negated = 3;
  void clear_negated() ;
  bool negated() const;
  void set_negated(bool value);

  private:
  bool _internal_negated() const;
  void _internal_set_negated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.TableConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TableConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> values_;
    ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    bool negated_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull TableConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL SymmetryProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.SymmetryProto) */ {
 public:
  inline SymmetryProto() : SymmetryProto(nullptr) {}
  ~SymmetryProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SymmetryProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SymmetryProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SymmetryProto(::google::protobuf::internal::ConstantInitialized);

  inline SymmetryProto(const SymmetryProto& from) : SymmetryProto(nullptr, from) {}
  inline SymmetryProto(SymmetryProto&& from) noexcept
      : SymmetryProto(nullptr, ::std::move(from)) {}
  inline SymmetryProto& operator=(const SymmetryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymmetryProto& operator=(SymmetryProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymmetryProto& default_instance() {
    return *reinterpret_cast<const SymmetryProto*>(
        &_SymmetryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SymmetryProto& a, SymmetryProto& b) { a.Swap(&b); }
  inline void Swap(SymmetryProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymmetryProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymmetryProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SymmetryProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SymmetryProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SymmetryProto& from) { SymmetryProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SymmetryProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.SymmetryProto"; }

  explicit SymmetryProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SymmetryProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SymmetryProto& from);
  SymmetryProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SymmetryProto&& from) noexcept
      : SymmetryProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPermutationsFieldNumber = 1,
    kOrbitopesFieldNumber = 2,
  };
  // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
  int permutations_size() const;
  private:
  int _internal_permutations_size() const;

  public:
  void clear_permutations() ;
  ::operations_research::sat::SparsePermutationProto* PROTOBUF_NONNULL mutable_permutations(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>* PROTOBUF_NONNULL mutable_permutations();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>& _internal_permutations() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>* PROTOBUF_NONNULL _internal_mutable_permutations();
  public:
  const ::operations_research::sat::SparsePermutationProto& permutations(int index) const;
  ::operations_research::sat::SparsePermutationProto* PROTOBUF_NONNULL add_permutations();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>& permutations() const;
  // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
  int orbitopes_size() const;
  private:
  int _internal_orbitopes_size() const;

  public:
  void clear_orbitopes() ;
  ::operations_research::sat::DenseMatrixProto* PROTOBUF_NONNULL mutable_orbitopes(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>* PROTOBUF_NONNULL mutable_orbitopes();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>& _internal_orbitopes() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>* PROTOBUF_NONNULL _internal_mutable_orbitopes();
  public:
  const ::operations_research::sat::DenseMatrixProto& orbitopes(int index) const;
  ::operations_research::sat::DenseMatrixProto* PROTOBUF_NONNULL add_orbitopes();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>& orbitopes() const;
  // @@protoc_insertion_point(class_scope:operations_research.sat.SymmetryProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SymmetryProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::SparsePermutationProto > permutations_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DenseMatrixProto > orbitopes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull SymmetryProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL RoutesConstraintProto_NodeExpressions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.RoutesConstraintProto.NodeExpressions) */ {
 public:
  inline RoutesConstraintProto_NodeExpressions() : RoutesConstraintProto_NodeExpressions(nullptr) {}
  ~RoutesConstraintProto_NodeExpressions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoutesConstraintProto_NodeExpressions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutesConstraintProto_NodeExpressions(::google::protobuf::internal::ConstantInitialized);

  inline RoutesConstraintProto_NodeExpressions(const RoutesConstraintProto_NodeExpressions& from) : RoutesConstraintProto_NodeExpressions(nullptr, from) {}
  inline RoutesConstraintProto_NodeExpressions(RoutesConstraintProto_NodeExpressions&& from) noexcept
      : RoutesConstraintProto_NodeExpressions(nullptr, ::std::move(from)) {}
  inline RoutesConstraintProto_NodeExpressions& operator=(const RoutesConstraintProto_NodeExpressions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutesConstraintProto_NodeExpressions& operator=(RoutesConstraintProto_NodeExpressions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutesConstraintProto_NodeExpressions& default_instance() {
    return *reinterpret_cast<const RoutesConstraintProto_NodeExpressions*>(
        &_RoutesConstraintProto_NodeExpressions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RoutesConstraintProto_NodeExpressions& a, RoutesConstraintProto_NodeExpressions& b) { a.Swap(&b); }
  inline void Swap(RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoutesConstraintProto_NodeExpressions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutesConstraintProto_NodeExpressions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutesConstraintProto_NodeExpressions& from) { RoutesConstraintProto_NodeExpressions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.RoutesConstraintProto.NodeExpressions"; }

  explicit RoutesConstraintProto_NodeExpressions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoutesConstraintProto_NodeExpressions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoutesConstraintProto_NodeExpressions& from);
  RoutesConstraintProto_NodeExpressions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoutesConstraintProto_NodeExpressions&& from) noexcept
      : RoutesConstraintProto_NodeExpressions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExprsFieldNumber = 1,
  };
  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // @@protoc_insertion_point(class_scope:operations_research.sat.RoutesConstraintProto.NodeExpressions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoutesConstraintProto_NodeExpressions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_NodeExpressions_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL ReservoirConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.ReservoirConstraintProto) */ {
 public:
  inline ReservoirConstraintProto() : ReservoirConstraintProto(nullptr) {}
  ~ReservoirConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReservoirConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReservoirConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReservoirConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline ReservoirConstraintProto(const ReservoirConstraintProto& from) : ReservoirConstraintProto(nullptr, from) {}
  inline ReservoirConstraintProto(ReservoirConstraintProto&& from) noexcept
      : ReservoirConstraintProto(nullptr, ::std::move(from)) {}
  inline ReservoirConstraintProto& operator=(const ReservoirConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReservoirConstraintProto& operator=(ReservoirConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReservoirConstraintProto& default_instance() {
    return *reinterpret_cast<const ReservoirConstraintProto*>(
        &_ReservoirConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ReservoirConstraintProto& a, ReservoirConstraintProto& b) { a.Swap(&b); }
  inline void Swap(ReservoirConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReservoirConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReservoirConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReservoirConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReservoirConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReservoirConstraintProto& from) { ReservoirConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReservoirConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.ReservoirConstraintProto"; }

  explicit ReservoirConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ReservoirConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ReservoirConstraintProto& from);
  ReservoirConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ReservoirConstraintProto&& from) noexcept
      : ReservoirConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeExprsFieldNumber = 3,
    kActiveLiteralsFieldNumber = 5,
    kLevelChangesFieldNumber = 6,
    kMinLevelFieldNumber = 1,
    kMaxLevelFieldNumber = 2,
  };
  // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
  int time_exprs_size() const;
  private:
  int _internal_time_exprs_size() const;

  public:
  void clear_time_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_time_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_time_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_time_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_time_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& time_exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_time_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& time_exprs() const;
  // repeated int32 active_literals = 5;
  int active_literals_size() const;
  private:
  int _internal_active_literals_size() const;

  public:
  void clear_active_literals() ;
  ::int32_t active_literals(int index) const;
  void set_active_literals(int index, ::int32_t value);
  void add_active_literals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& active_literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_active_literals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_active_literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_active_literals();

  public:
  // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
  int level_changes_size() const;
  private:
  int _internal_level_changes_size() const;

  public:
  void clear_level_changes() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_level_changes(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_level_changes();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_level_changes() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_level_changes();
  public:
  const ::operations_research::sat::LinearExpressionProto& level_changes(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_level_changes();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& level_changes() const;
  // int64 min_level = 1;
  void clear_min_level() ;
  ::int64_t min_level() const;
  void set_min_level(::int64_t value);

  private:
  ::int64_t _internal_min_level() const;
  void _internal_set_min_level(::int64_t value);

  public:
  // int64 max_level = 2;
  void clear_max_level() ;
  ::int64_t max_level() const;
  void set_max_level(::int64_t value);

  private:
  ::int64_t _internal_max_level() const;
  void _internal_set_max_level(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.ReservoirConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ReservoirConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > time_exprs_;
    ::google::protobuf::RepeatedField<::int32_t> active_literals_;
    ::google::protobuf::internal::CachedSize _active_literals_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > level_changes_;
    ::int64_t min_level_;
    ::int64_t max_level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ReservoirConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL LinearArgumentProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.LinearArgumentProto) */ {
 public:
  inline LinearArgumentProto() : LinearArgumentProto(nullptr) {}
  ~LinearArgumentProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LinearArgumentProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LinearArgumentProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LinearArgumentProto(::google::protobuf::internal::ConstantInitialized);

  inline LinearArgumentProto(const LinearArgumentProto& from) : LinearArgumentProto(nullptr, from) {}
  inline LinearArgumentProto(LinearArgumentProto&& from) noexcept
      : LinearArgumentProto(nullptr, ::std::move(from)) {}
  inline LinearArgumentProto& operator=(const LinearArgumentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearArgumentProto& operator=(LinearArgumentProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearArgumentProto& default_instance() {
    return *reinterpret_cast<const LinearArgumentProto*>(
        &_LinearArgumentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LinearArgumentProto& a, LinearArgumentProto& b) { a.Swap(&b); }
  inline void Swap(LinearArgumentProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearArgumentProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearArgumentProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LinearArgumentProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LinearArgumentProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LinearArgumentProto& from) { LinearArgumentProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LinearArgumentProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.LinearArgumentProto"; }

  explicit LinearArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LinearArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LinearArgumentProto& from);
  LinearArgumentProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LinearArgumentProto&& from) noexcept
      : LinearArgumentProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExprsFieldNumber = 2,
    kTargetFieldNumber = 1,
  };
  // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // .operations_research.sat.LinearExpressionProto target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::operations_research::sat::LinearExpressionProto& target() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_target();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_target();
  void set_allocated_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_target();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_target() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.LinearArgumentProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LinearArgumentProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull LinearArgumentProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL IntervalConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.IntervalConstraintProto) */ {
 public:
  inline IntervalConstraintProto() : IntervalConstraintProto(nullptr) {}
  ~IntervalConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IntervalConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IntervalConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IntervalConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline IntervalConstraintProto(const IntervalConstraintProto& from) : IntervalConstraintProto(nullptr, from) {}
  inline IntervalConstraintProto(IntervalConstraintProto&& from) noexcept
      : IntervalConstraintProto(nullptr, ::std::move(from)) {}
  inline IntervalConstraintProto& operator=(const IntervalConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntervalConstraintProto& operator=(IntervalConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntervalConstraintProto& default_instance() {
    return *reinterpret_cast<const IntervalConstraintProto*>(
        &_IntervalConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(IntervalConstraintProto& a, IntervalConstraintProto& b) { a.Swap(&b); }
  inline void Swap(IntervalConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntervalConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntervalConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IntervalConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntervalConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IntervalConstraintProto& from) { IntervalConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IntervalConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.IntervalConstraintProto"; }

  explicit IntervalConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  IntervalConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const IntervalConstraintProto& from);
  IntervalConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, IntervalConstraintProto&& from) noexcept
      : IntervalConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kSizeFieldNumber = 6,
  };
  // .operations_research.sat.LinearExpressionProto start = 4;
  bool has_start() const;
  void clear_start() ;
  const ::operations_research::sat::LinearExpressionProto& start() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_start();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_start();
  void set_allocated_start(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_start(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_start();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_start() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_start();

  public:
  // .operations_research.sat.LinearExpressionProto end = 5;
  bool has_end() const;
  void clear_end() ;
  const ::operations_research::sat::LinearExpressionProto& end() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_end();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_end();
  void set_allocated_end(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_end(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_end();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_end() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_end();

  public:
  // .operations_research.sat.LinearExpressionProto size = 6;
  bool has_size() const;
  void clear_size() ;
  const ::operations_research::sat::LinearExpressionProto& size() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_size();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_size();
  void set_allocated_size(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_size(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_size();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_size() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_size();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.IntervalConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const IntervalConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE start_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE end_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull IntervalConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL ElementConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.ElementConstraintProto) */ {
 public:
  inline ElementConstraintProto() : ElementConstraintProto(nullptr) {}
  ~ElementConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ElementConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ElementConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ElementConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline ElementConstraintProto(const ElementConstraintProto& from) : ElementConstraintProto(nullptr, from) {}
  inline ElementConstraintProto(ElementConstraintProto&& from) noexcept
      : ElementConstraintProto(nullptr, ::std::move(from)) {}
  inline ElementConstraintProto& operator=(const ElementConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConstraintProto& operator=(ElementConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElementConstraintProto& default_instance() {
    return *reinterpret_cast<const ElementConstraintProto*>(
        &_ElementConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ElementConstraintProto& a, ElementConstraintProto& b) { a.Swap(&b); }
  inline void Swap(ElementConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ElementConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ElementConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ElementConstraintProto& from) { ElementConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ElementConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.ElementConstraintProto"; }

  explicit ElementConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ElementConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ElementConstraintProto& from);
  ElementConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ElementConstraintProto&& from) noexcept
      : ElementConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVarsFieldNumber = 3,
    kExprsFieldNumber = 6,
    kLinearIndexFieldNumber = 4,
    kLinearTargetFieldNumber = 5,
    kIndexFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated int32 vars = 3;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated .operations_research.sat.LinearExpressionProto exprs = 6;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // .operations_research.sat.LinearExpressionProto linear_index = 4;
  bool has_linear_index() const;
  void clear_linear_index() ;
  const ::operations_research::sat::LinearExpressionProto& linear_index() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_linear_index();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_linear_index();
  void set_allocated_linear_index(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_linear_index(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_linear_index();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_linear_index() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_linear_index();

  public:
  // .operations_research.sat.LinearExpressionProto linear_target = 5;
  bool has_linear_target() const;
  void clear_linear_target() ;
  const ::operations_research::sat::LinearExpressionProto& linear_target() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_linear_target();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_linear_target();
  void set_allocated_linear_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_linear_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_linear_target();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_linear_target() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_linear_target();

  public:
  // int32 index = 1;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // int32 target = 2;
  void clear_target() ;
  ::int32_t target() const;
  void set_target(::int32_t value);

  private:
  ::int32_t _internal_target() const;
  void _internal_set_target(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.ElementConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ElementConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE linear_index_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE linear_target_;
    ::int32_t index_;
    ::int32_t target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ElementConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL DecisionStrategyProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.DecisionStrategyProto) */ {
 public:
  inline DecisionStrategyProto() : DecisionStrategyProto(nullptr) {}
  ~DecisionStrategyProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DecisionStrategyProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DecisionStrategyProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DecisionStrategyProto(::google::protobuf::internal::ConstantInitialized);

  inline DecisionStrategyProto(const DecisionStrategyProto& from) : DecisionStrategyProto(nullptr, from) {}
  inline DecisionStrategyProto(DecisionStrategyProto&& from) noexcept
      : DecisionStrategyProto(nullptr, ::std::move(from)) {}
  inline DecisionStrategyProto& operator=(const DecisionStrategyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionStrategyProto& operator=(DecisionStrategyProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecisionStrategyProto& default_instance() {
    return *reinterpret_cast<const DecisionStrategyProto*>(
        &_DecisionStrategyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(DecisionStrategyProto& a, DecisionStrategyProto& b) { a.Swap(&b); }
  inline void Swap(DecisionStrategyProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionStrategyProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecisionStrategyProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DecisionStrategyProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DecisionStrategyProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DecisionStrategyProto& from) { DecisionStrategyProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DecisionStrategyProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.DecisionStrategyProto"; }

  explicit DecisionStrategyProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DecisionStrategyProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DecisionStrategyProto& from);
  DecisionStrategyProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DecisionStrategyProto&& from) noexcept
      : DecisionStrategyProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using VariableSelectionStrategy = DecisionStrategyProto_VariableSelectionStrategy;
  static constexpr VariableSelectionStrategy CHOOSE_FIRST = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_FIRST;
  static constexpr VariableSelectionStrategy CHOOSE_LOWEST_MIN = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_LOWEST_MIN;
  static constexpr VariableSelectionStrategy CHOOSE_HIGHEST_MAX = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_HIGHEST_MAX;
  static constexpr VariableSelectionStrategy CHOOSE_MIN_DOMAIN_SIZE = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MIN_DOMAIN_SIZE;
  static constexpr VariableSelectionStrategy CHOOSE_MAX_DOMAIN_SIZE = DecisionStrategyProto_VariableSelectionStrategy_CHOOSE_MAX_DOMAIN_SIZE;
  static inline bool VariableSelectionStrategy_IsValid(int value) {
    return DecisionStrategyProto_VariableSelectionStrategy_IsValid(value);
  }
  static constexpr VariableSelectionStrategy VariableSelectionStrategy_MIN = DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MIN;
  static constexpr VariableSelectionStrategy VariableSelectionStrategy_MAX = DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_MAX;
  static constexpr int VariableSelectionStrategy_ARRAYSIZE = DecisionStrategyProto_VariableSelectionStrategy_VariableSelectionStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL VariableSelectionStrategy_descriptor() {
    return DecisionStrategyProto_VariableSelectionStrategy_descriptor();
  }
  template <typename T>
  static inline const ::std::string& VariableSelectionStrategy_Name(T value) {
    return DecisionStrategyProto_VariableSelectionStrategy_Name(value);
  }
  static inline bool VariableSelectionStrategy_Parse(
      ::absl::string_view name, VariableSelectionStrategy* PROTOBUF_NONNULL value) {
    return DecisionStrategyProto_VariableSelectionStrategy_Parse(name, value);
  }
  using DomainReductionStrategy = DecisionStrategyProto_DomainReductionStrategy;
  static constexpr DomainReductionStrategy SELECT_MIN_VALUE = DecisionStrategyProto_DomainReductionStrategy_SELECT_MIN_VALUE;
  static constexpr DomainReductionStrategy SELECT_MAX_VALUE = DecisionStrategyProto_DomainReductionStrategy_SELECT_MAX_VALUE;
  static constexpr DomainReductionStrategy SELECT_LOWER_HALF = DecisionStrategyProto_DomainReductionStrategy_SELECT_LOWER_HALF;
  static constexpr DomainReductionStrategy SELECT_UPPER_HALF = DecisionStrategyProto_DomainReductionStrategy_SELECT_UPPER_HALF;
  static constexpr DomainReductionStrategy SELECT_MEDIAN_VALUE = DecisionStrategyProto_DomainReductionStrategy_SELECT_MEDIAN_VALUE;
  static constexpr DomainReductionStrategy SELECT_RANDOM_HALF = DecisionStrategyProto_DomainReductionStrategy_SELECT_RANDOM_HALF;
  static inline bool DomainReductionStrategy_IsValid(int value) {
    return DecisionStrategyProto_DomainReductionStrategy_IsValid(value);
  }
  static constexpr DomainReductionStrategy DomainReductionStrategy_MIN = DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MIN;
  static constexpr DomainReductionStrategy DomainReductionStrategy_MAX = DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_MAX;
  static constexpr int DomainReductionStrategy_ARRAYSIZE = DecisionStrategyProto_DomainReductionStrategy_DomainReductionStrategy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DomainReductionStrategy_descriptor() {
    return DecisionStrategyProto_DomainReductionStrategy_descriptor();
  }
  template <typename T>
  static inline const ::std::string& DomainReductionStrategy_Name(T value) {
    return DecisionStrategyProto_DomainReductionStrategy_Name(value);
  }
  static inline bool DomainReductionStrategy_Parse(
      ::absl::string_view name, DomainReductionStrategy* PROTOBUF_NONNULL value) {
    return DecisionStrategyProto_DomainReductionStrategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kVariablesFieldNumber = 1,
    kExprsFieldNumber = 5,
    kVariableSelectionStrategyFieldNumber = 2,
    kDomainReductionStrategyFieldNumber = 3,
  };
  // repeated int32 variables = 1;
  int variables_size() const;
  private:
  int _internal_variables_size() const;

  public:
  void clear_variables() ;
  ::int32_t variables(int index) const;
  void set_variables(int index, ::int32_t value);
  void add_variables(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& variables() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_variables();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_variables() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_variables();

  public:
  // repeated .operations_research.sat.LinearExpressionProto exprs = 5;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
  void clear_variable_selection_strategy() ;
  ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy variable_selection_strategy() const;
  void set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value);

  private:
  ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy _internal_variable_selection_strategy() const;
  void _internal_set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value);

  public:
  // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
  void clear_domain_reduction_strategy() ;
  ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy domain_reduction_strategy() const;
  void set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value);

  private:
  ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy _internal_domain_reduction_strategy() const;
  void _internal_set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.DecisionStrategyProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DecisionStrategyProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> variables_;
    ::google::protobuf::internal::CachedSize _variables_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    int variable_selection_strategy_;
    int domain_reduction_strategy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull DecisionStrategyProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CumulativeConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CumulativeConstraintProto) */ {
 public:
  inline CumulativeConstraintProto() : CumulativeConstraintProto(nullptr) {}
  ~CumulativeConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CumulativeConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CumulativeConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CumulativeConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline CumulativeConstraintProto(const CumulativeConstraintProto& from) : CumulativeConstraintProto(nullptr, from) {}
  inline CumulativeConstraintProto(CumulativeConstraintProto&& from) noexcept
      : CumulativeConstraintProto(nullptr, ::std::move(from)) {}
  inline CumulativeConstraintProto& operator=(const CumulativeConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CumulativeConstraintProto& operator=(CumulativeConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CumulativeConstraintProto& default_instance() {
    return *reinterpret_cast<const CumulativeConstraintProto*>(
        &_CumulativeConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CumulativeConstraintProto& a, CumulativeConstraintProto& b) { a.Swap(&b); }
  inline void Swap(CumulativeConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CumulativeConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CumulativeConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CumulativeConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CumulativeConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CumulativeConstraintProto& from) { CumulativeConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CumulativeConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CumulativeConstraintProto"; }

  explicit CumulativeConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CumulativeConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CumulativeConstraintProto& from);
  CumulativeConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CumulativeConstraintProto&& from) noexcept
      : CumulativeConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIntervalsFieldNumber = 2,
    kDemandsFieldNumber = 3,
    kCapacityFieldNumber = 1,
  };
  // repeated int32 intervals = 2;
  int intervals_size() const;
  private:
  int _internal_intervals_size() const;

  public:
  void clear_intervals() ;
  ::int32_t intervals(int index) const;
  void set_intervals(int index, ::int32_t value);
  void add_intervals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_intervals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_intervals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_intervals();

  public:
  // repeated .operations_research.sat.LinearExpressionProto demands = 3;
  int demands_size() const;
  private:
  int _internal_demands_size() const;

  public:
  void clear_demands() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_demands(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_demands();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_demands() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_demands();
  public:
  const ::operations_research::sat::LinearExpressionProto& demands(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_demands();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& demands() const;
  // .operations_research.sat.LinearExpressionProto capacity = 1;
  bool has_capacity() const;
  void clear_capacity() ;
  const ::operations_research::sat::LinearExpressionProto& capacity() const;
  [[nodiscard]] ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE release_capacity();
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_capacity();
  void set_allocated_capacity(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_capacity(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE unsafe_arena_release_capacity();

  private:
  const ::operations_research::sat::LinearExpressionProto& _internal_capacity() const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL _internal_mutable_capacity();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CumulativeConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CumulativeConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> intervals_;
    ::google::protobuf::internal::CachedSize _intervals_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > demands_;
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CumulativeConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CpSolverResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CpSolverResponse) */ {
 public:
  inline CpSolverResponse() : CpSolverResponse(nullptr) {}
  ~CpSolverResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CpSolverResponse* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CpSolverResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CpSolverResponse(::google::protobuf::internal::ConstantInitialized);

  inline CpSolverResponse(const CpSolverResponse& from) : CpSolverResponse(nullptr, from) {}
  inline CpSolverResponse(CpSolverResponse&& from) noexcept
      : CpSolverResponse(nullptr, ::std::move(from)) {}
  inline CpSolverResponse& operator=(const CpSolverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpSolverResponse& operator=(CpSolverResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpSolverResponse& default_instance() {
    return *reinterpret_cast<const CpSolverResponse*>(
        &_CpSolverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(CpSolverResponse& a, CpSolverResponse& b) { a.Swap(&b); }
  inline void Swap(CpSolverResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpSolverResponse* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpSolverResponse* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CpSolverResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CpSolverResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CpSolverResponse& from) { CpSolverResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CpSolverResponse* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CpSolverResponse"; }

  explicit CpSolverResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CpSolverResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CpSolverResponse& from);
  CpSolverResponse(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CpSolverResponse&& from) noexcept
      : CpSolverResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSolutionFieldNumber = 2,
    kTightenedVariablesFieldNumber = 21,
    kSufficientAssumptionsForInfeasibilityFieldNumber = 23,
    kAdditionalSolutionsFieldNumber = 27,
    kSolutionInfoFieldNumber = 20,
    kSolveLogFieldNumber = 26,
    kIntegerObjectiveFieldNumber = 28,
    kObjectiveValueFieldNumber = 3,
    kBestObjectiveBoundFieldNumber = 4,
    kNumBooleansFieldNumber = 10,
    kNumConflictsFieldNumber = 11,
    kNumBranchesFieldNumber = 12,
    kNumBinaryPropagationsFieldNumber = 13,
    kNumIntegerPropagationsFieldNumber = 14,
    kWallTimeFieldNumber = 15,
    kUserTimeFieldNumber = 16,
    kDeterministicTimeFieldNumber = 17,
    kGapIntegralFieldNumber = 22,
    kNumRestartsFieldNumber = 24,
    kNumLpIterationsFieldNumber = 25,
    kInnerObjectiveLowerBoundFieldNumber = 29,
    kNumIntegersFieldNumber = 30,
    kNumFixedBooleansFieldNumber = 31,
    kStatusFieldNumber = 1,
  };
  // repeated int64 solution = 2;
  int solution_size() const;
  private:
  int _internal_solution_size() const;

  public:
  void clear_solution() ;
  ::int64_t solution(int index) const;
  void set_solution(int index, ::int64_t value);
  void add_solution(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& solution() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_solution();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_solution() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_solution();

  public:
  // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
  int tightened_variables_size() const;
  private:
  int _internal_tightened_variables_size() const;

  public:
  void clear_tightened_variables() ;
  ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL mutable_tightened_variables(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL mutable_tightened_variables();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& _internal_tightened_variables() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL _internal_mutable_tightened_variables();
  public:
  const ::operations_research::sat::IntegerVariableProto& tightened_variables(int index) const;
  ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL add_tightened_variables();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& tightened_variables() const;
  // repeated int32 sufficient_assumptions_for_infeasibility = 23;
  int sufficient_assumptions_for_infeasibility_size() const;
  private:
  int _internal_sufficient_assumptions_for_infeasibility_size() const;

  public:
  void clear_sufficient_assumptions_for_infeasibility() ;
  ::int32_t sufficient_assumptions_for_infeasibility(int index) const;
  void set_sufficient_assumptions_for_infeasibility(int index, ::int32_t value);
  void add_sufficient_assumptions_for_infeasibility(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& sufficient_assumptions_for_infeasibility() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_sufficient_assumptions_for_infeasibility();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_sufficient_assumptions_for_infeasibility() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_sufficient_assumptions_for_infeasibility();

  public:
  // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
  int additional_solutions_size() const;
  private:
  int _internal_additional_solutions_size() const;

  public:
  void clear_additional_solutions() ;
  ::operations_research::sat::CpSolverSolution* PROTOBUF_NONNULL mutable_additional_solutions(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>* PROTOBUF_NONNULL mutable_additional_solutions();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>& _internal_additional_solutions() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>* PROTOBUF_NONNULL _internal_mutable_additional_solutions();
  public:
  const ::operations_research::sat::CpSolverSolution& additional_solutions(int index) const;
  ::operations_research::sat::CpSolverSolution* PROTOBUF_NONNULL add_additional_solutions();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>& additional_solutions() const;
  // string solution_info = 20;
  void clear_solution_info() ;
  const ::std::string& solution_info() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_solution_info(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_solution_info();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_solution_info();
  void set_allocated_solution_info(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_solution_info() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_solution_info(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_solution_info();

  public:
  // string solve_log = 26;
  void clear_solve_log() ;
  const ::std::string& solve_log() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_solve_log(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_solve_log();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_solve_log();
  void set_allocated_solve_log(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_solve_log() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_solve_log(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_solve_log();

  public:
  // .operations_research.sat.CpObjectiveProto integer_objective = 28;
  bool has_integer_objective() const;
  void clear_integer_objective() ;
  const ::operations_research::sat::CpObjectiveProto& integer_objective() const;
  [[nodiscard]] ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE release_integer_objective();
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL mutable_integer_objective();
  void set_allocated_integer_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_integer_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE unsafe_arena_release_integer_objective();

  private:
  const ::operations_research::sat::CpObjectiveProto& _internal_integer_objective() const;
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL _internal_mutable_integer_objective();

  public:
  // double objective_value = 3;
  void clear_objective_value() ;
  double objective_value() const;
  void set_objective_value(double value);

  private:
  double _internal_objective_value() const;
  void _internal_set_objective_value(double value);

  public:
  // double best_objective_bound = 4;
  void clear_best_objective_bound() ;
  double best_objective_bound() const;
  void set_best_objective_bound(double value);

  private:
  double _internal_best_objective_bound() const;
  void _internal_set_best_objective_bound(double value);

  public:
  // int64 num_booleans = 10;
  void clear_num_booleans() ;
  ::int64_t num_booleans() const;
  void set_num_booleans(::int64_t value);

  private:
  ::int64_t _internal_num_booleans() const;
  void _internal_set_num_booleans(::int64_t value);

  public:
  // int64 num_conflicts = 11;
  void clear_num_conflicts() ;
  ::int64_t num_conflicts() const;
  void set_num_conflicts(::int64_t value);

  private:
  ::int64_t _internal_num_conflicts() const;
  void _internal_set_num_conflicts(::int64_t value);

  public:
  // int64 num_branches = 12;
  void clear_num_branches() ;
  ::int64_t num_branches() const;
  void set_num_branches(::int64_t value);

  private:
  ::int64_t _internal_num_branches() const;
  void _internal_set_num_branches(::int64_t value);

  public:
  // int64 num_binary_propagations = 13;
  void clear_num_binary_propagations() ;
  ::int64_t num_binary_propagations() const;
  void set_num_binary_propagations(::int64_t value);

  private:
  ::int64_t _internal_num_binary_propagations() const;
  void _internal_set_num_binary_propagations(::int64_t value);

  public:
  // int64 num_integer_propagations = 14;
  void clear_num_integer_propagations() ;
  ::int64_t num_integer_propagations() const;
  void set_num_integer_propagations(::int64_t value);

  private:
  ::int64_t _internal_num_integer_propagations() const;
  void _internal_set_num_integer_propagations(::int64_t value);

  public:
  // double wall_time = 15;
  void clear_wall_time() ;
  double wall_time() const;
  void set_wall_time(double value);

  private:
  double _internal_wall_time() const;
  void _internal_set_wall_time(double value);

  public:
  // double user_time = 16;
  void clear_user_time() ;
  double user_time() const;
  void set_user_time(double value);

  private:
  double _internal_user_time() const;
  void _internal_set_user_time(double value);

  public:
  // double deterministic_time = 17;
  void clear_deterministic_time() ;
  double deterministic_time() const;
  void set_deterministic_time(double value);

  private:
  double _internal_deterministic_time() const;
  void _internal_set_deterministic_time(double value);

  public:
  // double gap_integral = 22;
  void clear_gap_integral() ;
  double gap_integral() const;
  void set_gap_integral(double value);

  private:
  double _internal_gap_integral() const;
  void _internal_set_gap_integral(double value);

  public:
  // int64 num_restarts = 24;
  void clear_num_restarts() ;
  ::int64_t num_restarts() const;
  void set_num_restarts(::int64_t value);

  private:
  ::int64_t _internal_num_restarts() const;
  void _internal_set_num_restarts(::int64_t value);

  public:
  // int64 num_lp_iterations = 25;
  void clear_num_lp_iterations() ;
  ::int64_t num_lp_iterations() const;
  void set_num_lp_iterations(::int64_t value);

  private:
  ::int64_t _internal_num_lp_iterations() const;
  void _internal_set_num_lp_iterations(::int64_t value);

  public:
  // int64 inner_objective_lower_bound = 29;
  void clear_inner_objective_lower_bound() ;
  ::int64_t inner_objective_lower_bound() const;
  void set_inner_objective_lower_bound(::int64_t value);

  private:
  ::int64_t _internal_inner_objective_lower_bound() const;
  void _internal_set_inner_objective_lower_bound(::int64_t value);

  public:
  // int64 num_integers = 30;
  void clear_num_integers() ;
  ::int64_t num_integers() const;
  void set_num_integers(::int64_t value);

  private:
  ::int64_t _internal_num_integers() const;
  void _internal_set_num_integers(::int64_t value);

  public:
  // int64 num_fixed_booleans = 31;
  void clear_num_fixed_booleans() ;
  ::int64_t num_fixed_booleans() const;
  void set_num_fixed_booleans(::int64_t value);

  private:
  ::int64_t _internal_num_fixed_booleans() const;
  void _internal_set_num_fixed_booleans(::int64_t value);

  public:
  // .operations_research.sat.CpSolverStatus status = 1;
  void clear_status() ;
  ::operations_research::sat::CpSolverStatus status() const;
  void set_status(::operations_research::sat::CpSolverStatus value);

  private:
  ::operations_research::sat::CpSolverStatus _internal_status() const;
  void _internal_set_status(::operations_research::sat::CpSolverStatus value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CpSolverResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 24,
                                   3, 95,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CpSolverResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> solution_;
    ::google::protobuf::internal::CachedSize _solution_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto > tightened_variables_;
    ::google::protobuf::RepeatedField<::int32_t> sufficient_assumptions_for_infeasibility_;
    ::google::protobuf::internal::CachedSize _sufficient_assumptions_for_infeasibility_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::CpSolverSolution > additional_solutions_;
    ::google::protobuf::internal::ArenaStringPtr solution_info_;
    ::google::protobuf::internal::ArenaStringPtr solve_log_;
    ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE integer_objective_;
    double objective_value_;
    double best_objective_bound_;
    ::int64_t num_booleans_;
    ::int64_t num_conflicts_;
    ::int64_t num_branches_;
    ::int64_t num_binary_propagations_;
    ::int64_t num_integer_propagations_;
    double wall_time_;
    double user_time_;
    double deterministic_time_;
    double gap_integral_;
    ::int64_t num_restarts_;
    ::int64_t num_lp_iterations_;
    ::int64_t inner_objective_lower_bound_;
    ::int64_t num_integers_;
    ::int64_t num_fixed_booleans_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpSolverResponse_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL AutomatonConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.AutomatonConstraintProto) */ {
 public:
  inline AutomatonConstraintProto() : AutomatonConstraintProto(nullptr) {}
  ~AutomatonConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AutomatonConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AutomatonConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutomatonConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline AutomatonConstraintProto(const AutomatonConstraintProto& from) : AutomatonConstraintProto(nullptr, from) {}
  inline AutomatonConstraintProto(AutomatonConstraintProto&& from) noexcept
      : AutomatonConstraintProto(nullptr, ::std::move(from)) {}
  inline AutomatonConstraintProto& operator=(const AutomatonConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutomatonConstraintProto& operator=(AutomatonConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutomatonConstraintProto& default_instance() {
    return *reinterpret_cast<const AutomatonConstraintProto*>(
        &_AutomatonConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AutomatonConstraintProto& a, AutomatonConstraintProto& b) { a.Swap(&b); }
  inline void Swap(AutomatonConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutomatonConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutomatonConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AutomatonConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutomatonConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutomatonConstraintProto& from) { AutomatonConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AutomatonConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.AutomatonConstraintProto"; }

  explicit AutomatonConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AutomatonConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AutomatonConstraintProto& from);
  AutomatonConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AutomatonConstraintProto&& from) noexcept
      : AutomatonConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFinalStatesFieldNumber = 3,
    kTransitionTailFieldNumber = 4,
    kTransitionHeadFieldNumber = 5,
    kTransitionLabelFieldNumber = 6,
    kVarsFieldNumber = 7,
    kExprsFieldNumber = 8,
    kStartingStateFieldNumber = 2,
  };
  // repeated int64 final_states = 3;
  int final_states_size() const;
  private:
  int _internal_final_states_size() const;

  public:
  void clear_final_states() ;
  ::int64_t final_states(int index) const;
  void set_final_states(int index, ::int64_t value);
  void add_final_states(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& final_states() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_final_states();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_final_states() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_final_states();

  public:
  // repeated int64 transition_tail = 4;
  int transition_tail_size() const;
  private:
  int _internal_transition_tail_size() const;

  public:
  void clear_transition_tail() ;
  ::int64_t transition_tail(int index) const;
  void set_transition_tail(int index, ::int64_t value);
  void add_transition_tail(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& transition_tail() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_transition_tail();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_transition_tail() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_transition_tail();

  public:
  // repeated int64 transition_head = 5;
  int transition_head_size() const;
  private:
  int _internal_transition_head_size() const;

  public:
  void clear_transition_head() ;
  ::int64_t transition_head(int index) const;
  void set_transition_head(int index, ::int64_t value);
  void add_transition_head(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& transition_head() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_transition_head();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_transition_head() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_transition_head();

  public:
  // repeated int64 transition_label = 6;
  int transition_label_size() const;
  private:
  int _internal_transition_label_size() const;

  public:
  void clear_transition_label() ;
  ::int64_t transition_label(int index) const;
  void set_transition_label(int index, ::int64_t value);
  void add_transition_label(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& transition_label() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_transition_label();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_transition_label() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_transition_label();

  public:
  // repeated int32 vars = 7;
  int vars_size() const;
  private:
  int _internal_vars_size() const;

  public:
  void clear_vars() ;
  ::int32_t vars(int index) const;
  void set_vars(int index, ::int32_t value);
  void add_vars(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_vars();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_vars() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_vars();

  public:
  // repeated .operations_research.sat.LinearExpressionProto exprs = 8;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // int64 starting_state = 2;
  void clear_starting_state() ;
  ::int64_t starting_state() const;
  void set_starting_state(::int64_t value);

  private:
  ::int64_t _internal_starting_state() const;
  void _internal_set_starting_state(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.AutomatonConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AutomatonConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> final_states_;
    ::google::protobuf::internal::CachedSize _final_states_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> transition_tail_;
    ::google::protobuf::internal::CachedSize _transition_tail_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> transition_head_;
    ::google::protobuf::internal::CachedSize _transition_head_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> transition_label_;
    ::google::protobuf::internal::CachedSize _transition_label_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> vars_;
    ::google::protobuf::internal::CachedSize _vars_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    ::int64_t starting_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull AutomatonConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL AllDifferentConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.AllDifferentConstraintProto) */ {
 public:
  inline AllDifferentConstraintProto() : AllDifferentConstraintProto(nullptr) {}
  ~AllDifferentConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AllDifferentConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AllDifferentConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllDifferentConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline AllDifferentConstraintProto(const AllDifferentConstraintProto& from) : AllDifferentConstraintProto(nullptr, from) {}
  inline AllDifferentConstraintProto(AllDifferentConstraintProto&& from) noexcept
      : AllDifferentConstraintProto(nullptr, ::std::move(from)) {}
  inline AllDifferentConstraintProto& operator=(const AllDifferentConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllDifferentConstraintProto& operator=(AllDifferentConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllDifferentConstraintProto& default_instance() {
    return *reinterpret_cast<const AllDifferentConstraintProto*>(
        &_AllDifferentConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AllDifferentConstraintProto& a, AllDifferentConstraintProto& b) { a.Swap(&b); }
  inline void Swap(AllDifferentConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllDifferentConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllDifferentConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AllDifferentConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllDifferentConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AllDifferentConstraintProto& from) { AllDifferentConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AllDifferentConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.AllDifferentConstraintProto"; }

  explicit AllDifferentConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AllDifferentConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AllDifferentConstraintProto& from);
  AllDifferentConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AllDifferentConstraintProto&& from) noexcept
      : AllDifferentConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExprsFieldNumber = 1,
  };
  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  int exprs_size() const;
  private:
  int _internal_exprs_size() const;

  public:
  void clear_exprs() ;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL mutable_exprs();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& _internal_exprs() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL _internal_mutable_exprs();
  public:
  const ::operations_research::sat::LinearExpressionProto& exprs(int index) const;
  ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL add_exprs();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& exprs() const;
  // @@protoc_insertion_point(class_scope:operations_research.sat.AllDifferentConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AllDifferentConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::LinearExpressionProto > exprs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull AllDifferentConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL RoutesConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.RoutesConstraintProto) */ {
 public:
  inline RoutesConstraintProto() : RoutesConstraintProto(nullptr) {}
  ~RoutesConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoutesConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoutesConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoutesConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline RoutesConstraintProto(const RoutesConstraintProto& from) : RoutesConstraintProto(nullptr, from) {}
  inline RoutesConstraintProto(RoutesConstraintProto&& from) noexcept
      : RoutesConstraintProto(nullptr, ::std::move(from)) {}
  inline RoutesConstraintProto& operator=(const RoutesConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutesConstraintProto& operator=(RoutesConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutesConstraintProto& default_instance() {
    return *reinterpret_cast<const RoutesConstraintProto*>(
        &_RoutesConstraintProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(RoutesConstraintProto& a, RoutesConstraintProto& b) { a.Swap(&b); }
  inline void Swap(RoutesConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutesConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoutesConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoutesConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoutesConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoutesConstraintProto& from) { RoutesConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoutesConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.RoutesConstraintProto"; }

  explicit RoutesConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoutesConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoutesConstraintProto& from);
  RoutesConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoutesConstraintProto&& from) noexcept
      : RoutesConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NodeExpressions = RoutesConstraintProto_NodeExpressions;

  // accessors -------------------------------------------------------
  enum : int {
    kTailsFieldNumber = 1,
    kHeadsFieldNumber = 2,
    kLiteralsFieldNumber = 3,
    kDemandsFieldNumber = 4,
    kDimensionsFieldNumber = 6,
    kCapacityFieldNumber = 5,
  };
  // repeated int32 tails = 1;
  int tails_size() const;
  private:
  int _internal_tails_size() const;

  public:
  void clear_tails() ;
  ::int32_t tails(int index) const;
  void set_tails(int index, ::int32_t value);
  void add_tails(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& tails() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_tails();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_tails() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_tails();

  public:
  // repeated int32 heads = 2;
  int heads_size() const;
  private:
  int _internal_heads_size() const;

  public:
  void clear_heads() ;
  ::int32_t heads(int index) const;
  void set_heads(int index, ::int32_t value);
  void add_heads(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& heads() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_heads();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_heads() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_heads();

  public:
  // repeated int32 literals = 3;
  int literals_size() const;
  private:
  int _internal_literals_size() const;

  public:
  void clear_literals() ;
  ::int32_t literals(int index) const;
  void set_literals(int index, ::int32_t value);
  void add_literals(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_literals();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_literals() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_literals();

  public:
  // repeated int32 demands = 4;
  int demands_size() const;
  private:
  int _internal_demands_size() const;

  public:
  void clear_demands() ;
  ::int32_t demands(int index) const;
  void set_demands(int index, ::int32_t value);
  void add_demands(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& demands() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_demands();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_demands() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_demands();

  public:
  // repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;

  public:
  void clear_dimensions() ;
  ::operations_research::sat::RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL mutable_dimensions(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>* PROTOBUF_NONNULL mutable_dimensions();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>& _internal_dimensions() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>* PROTOBUF_NONNULL _internal_mutable_dimensions();
  public:
  const ::operations_research::sat::RoutesConstraintProto_NodeExpressions& dimensions(int index) const;
  ::operations_research::sat::RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL add_dimensions();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>& dimensions() const;
  // int64 capacity = 5;
  void clear_capacity() ;
  ::int64_t capacity() const;
  void set_capacity(::int64_t value);

  private:
  ::int64_t _internal_capacity() const;
  void _internal_set_capacity(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.RoutesConstraintProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoutesConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> tails_;
    ::google::protobuf::internal::CachedSize _tails_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> heads_;
    ::google::protobuf::internal::CachedSize _heads_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> literals_;
    ::google::protobuf::internal::CachedSize _literals_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> demands_;
    ::google::protobuf::internal::CachedSize _demands_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::RoutesConstraintProto_NodeExpressions > dimensions_;
    ::int64_t capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL ConstraintProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.ConstraintProto) */ {
 public:
  inline ConstraintProto() : ConstraintProto(nullptr) {}
  ~ConstraintProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConstraintProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConstraintProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConstraintProto(::google::protobuf::internal::ConstantInitialized);

  inline ConstraintProto(const ConstraintProto& from) : ConstraintProto(nullptr, from) {}
  inline ConstraintProto(ConstraintProto&& from) noexcept
      : ConstraintProto(nullptr, ::std::move(from)) {}
  inline ConstraintProto& operator=(const ConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstraintProto& operator=(ConstraintProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstraintProto& default_instance() {
    return *reinterpret_cast<const ConstraintProto*>(
        &_ConstraintProto_default_instance_);
  }
  enum ConstraintCase {
    kBoolOr = 3,
    kBoolAnd = 4,
    kAtMostOne = 26,
    kExactlyOne = 29,
    kBoolXor = 5,
    kIntDiv = 7,
    kIntMod = 8,
    kIntProd = 11,
    kLinMax = 27,
    kLinear = 12,
    kAllDiff = 13,
    kElement = 14,
    kCircuit = 15,
    kRoutes = 23,
    kTable = 16,
    kAutomaton = 17,
    kInverse = 18,
    kReservoir = 24,
    kInterval = 19,
    kNoOverlap = 20,
    kNoOverlap2D = 21,
    kCumulative = 22,
    kDummyConstraint = 30,
    CONSTRAINT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ConstraintProto& a, ConstraintProto& b) { a.Swap(&b); }
  inline void Swap(ConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstraintProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstraintProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConstraintProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConstraintProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConstraintProto& from) { ConstraintProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConstraintProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.ConstraintProto"; }

  explicit ConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ConstraintProto& from);
  ConstraintProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ConstraintProto&& from) noexcept
      : ConstraintProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnforcementLiteralFieldNumber = 2,
    kNameFieldNumber = 1,
    kBoolOrFieldNumber = 3,
    kBoolAndFieldNumber = 4,
    kAtMostOneFieldNumber = 26,
    kExactlyOneFieldNumber = 29,
    kBoolXorFieldNumber = 5,
    kIntDivFieldNumber = 7,
    kIntModFieldNumber = 8,
    kIntProdFieldNumber = 11,
    kLinMaxFieldNumber = 27,
    kLinearFieldNumber = 12,
    kAllDiffFieldNumber = 13,
    kElementFieldNumber = 14,
    kCircuitFieldNumber = 15,
    kRoutesFieldNumber = 23,
    kTableFieldNumber = 16,
    kAutomatonFieldNumber = 17,
    kInverseFieldNumber = 18,
    kReservoirFieldNumber = 24,
    kIntervalFieldNumber = 19,
    kNoOverlapFieldNumber = 20,
    kNoOverlap2DFieldNumber = 21,
    kCumulativeFieldNumber = 22,
    kDummyConstraintFieldNumber = 30,
  };
  // repeated int32 enforcement_literal = 2;
  int enforcement_literal_size() const;
  private:
  int _internal_enforcement_literal_size() const;

  public:
  void clear_enforcement_literal() ;
  ::int32_t enforcement_literal(int index) const;
  void set_enforcement_literal(int index, ::int32_t value);
  void add_enforcement_literal(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& enforcement_literal() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_enforcement_literal();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_enforcement_literal() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_enforcement_literal();

  public:
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .operations_research.sat.BoolArgumentProto bool_or = 3;
  bool has_bool_or() const;
  private:
  bool _internal_has_bool_or() const;

  public:
  void clear_bool_or() ;
  const ::operations_research::sat::BoolArgumentProto& bool_or() const;
  [[nodiscard]] ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE release_bool_or();
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL mutable_bool_or();
  void set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_bool_or();

  private:
  const ::operations_research::sat::BoolArgumentProto& _internal_bool_or() const;
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL _internal_mutable_bool_or();

  public:
  // .operations_research.sat.BoolArgumentProto bool_and = 4;
  bool has_bool_and() const;
  private:
  bool _internal_has_bool_and() const;

  public:
  void clear_bool_and() ;
  const ::operations_research::sat::BoolArgumentProto& bool_and() const;
  [[nodiscard]] ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE release_bool_and();
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL mutable_bool_and();
  void set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_bool_and();

  private:
  const ::operations_research::sat::BoolArgumentProto& _internal_bool_and() const;
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL _internal_mutable_bool_and();

  public:
  // .operations_research.sat.BoolArgumentProto at_most_one = 26;
  bool has_at_most_one() const;
  private:
  bool _internal_has_at_most_one() const;

  public:
  void clear_at_most_one() ;
  const ::operations_research::sat::BoolArgumentProto& at_most_one() const;
  [[nodiscard]] ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE release_at_most_one();
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL mutable_at_most_one();
  void set_allocated_at_most_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_at_most_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_at_most_one();

  private:
  const ::operations_research::sat::BoolArgumentProto& _internal_at_most_one() const;
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL _internal_mutable_at_most_one();

  public:
  // .operations_research.sat.BoolArgumentProto exactly_one = 29;
  bool has_exactly_one() const;
  private:
  bool _internal_has_exactly_one() const;

  public:
  void clear_exactly_one() ;
  const ::operations_research::sat::BoolArgumentProto& exactly_one() const;
  [[nodiscard]] ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE release_exactly_one();
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL mutable_exactly_one();
  void set_allocated_exactly_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exactly_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_exactly_one();

  private:
  const ::operations_research::sat::BoolArgumentProto& _internal_exactly_one() const;
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL _internal_mutable_exactly_one();

  public:
  // .operations_research.sat.BoolArgumentProto bool_xor = 5;
  bool has_bool_xor() const;
  private:
  bool _internal_has_bool_xor() const;

  public:
  void clear_bool_xor() ;
  const ::operations_research::sat::BoolArgumentProto& bool_xor() const;
  [[nodiscard]] ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE release_bool_xor();
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL mutable_bool_xor();
  void set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_bool_xor();

  private:
  const ::operations_research::sat::BoolArgumentProto& _internal_bool_xor() const;
  ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL _internal_mutable_bool_xor();

  public:
  // .operations_research.sat.LinearArgumentProto int_div = 7;
  bool has_int_div() const;
  private:
  bool _internal_has_int_div() const;

  public:
  void clear_int_div() ;
  const ::operations_research::sat::LinearArgumentProto& int_div() const;
  [[nodiscard]] ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE release_int_div();
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL mutable_int_div();
  void set_allocated_int_div(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_int_div(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_int_div();

  private:
  const ::operations_research::sat::LinearArgumentProto& _internal_int_div() const;
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL _internal_mutable_int_div();

  public:
  // .operations_research.sat.LinearArgumentProto int_mod = 8;
  bool has_int_mod() const;
  private:
  bool _internal_has_int_mod() const;

  public:
  void clear_int_mod() ;
  const ::operations_research::sat::LinearArgumentProto& int_mod() const;
  [[nodiscard]] ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE release_int_mod();
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL mutable_int_mod();
  void set_allocated_int_mod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_int_mod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_int_mod();

  private:
  const ::operations_research::sat::LinearArgumentProto& _internal_int_mod() const;
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL _internal_mutable_int_mod();

  public:
  // .operations_research.sat.LinearArgumentProto int_prod = 11;
  bool has_int_prod() const;
  private:
  bool _internal_has_int_prod() const;

  public:
  void clear_int_prod() ;
  const ::operations_research::sat::LinearArgumentProto& int_prod() const;
  [[nodiscard]] ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE release_int_prod();
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL mutable_int_prod();
  void set_allocated_int_prod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_int_prod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_int_prod();

  private:
  const ::operations_research::sat::LinearArgumentProto& _internal_int_prod() const;
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL _internal_mutable_int_prod();

  public:
  // .operations_research.sat.LinearArgumentProto lin_max = 27;
  bool has_lin_max() const;
  private:
  bool _internal_has_lin_max() const;

  public:
  void clear_lin_max() ;
  const ::operations_research::sat::LinearArgumentProto& lin_max() const;
  [[nodiscard]] ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE release_lin_max();
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL mutable_lin_max();
  void set_allocated_lin_max(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lin_max(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE unsafe_arena_release_lin_max();

  private:
  const ::operations_research::sat::LinearArgumentProto& _internal_lin_max() const;
  ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL _internal_mutable_lin_max();

  public:
  // .operations_research.sat.LinearConstraintProto linear = 12;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;

  public:
  void clear_linear() ;
  const ::operations_research::sat::LinearConstraintProto& linear() const;
  [[nodiscard]] ::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE release_linear();
  ::operations_research::sat::LinearConstraintProto* PROTOBUF_NONNULL mutable_linear();
  void set_allocated_linear(::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_linear(::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_linear();

  private:
  const ::operations_research::sat::LinearConstraintProto& _internal_linear() const;
  ::operations_research::sat::LinearConstraintProto* PROTOBUF_NONNULL _internal_mutable_linear();

  public:
  // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
  bool has_all_diff() const;
  private:
  bool _internal_has_all_diff() const;

  public:
  void clear_all_diff() ;
  const ::operations_research::sat::AllDifferentConstraintProto& all_diff() const;
  [[nodiscard]] ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE release_all_diff();
  ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NONNULL mutable_all_diff();
  void set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_all_diff();

  private:
  const ::operations_research::sat::AllDifferentConstraintProto& _internal_all_diff() const;
  ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NONNULL _internal_mutable_all_diff();

  public:
  // .operations_research.sat.ElementConstraintProto element = 14;
  bool has_element() const;
  private:
  bool _internal_has_element() const;

  public:
  void clear_element() ;
  const ::operations_research::sat::ElementConstraintProto& element() const;
  [[nodiscard]] ::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE release_element();
  ::operations_research::sat::ElementConstraintProto* PROTOBUF_NONNULL mutable_element();
  void set_allocated_element(::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_element(::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_element();

  private:
  const ::operations_research::sat::ElementConstraintProto& _internal_element() const;
  ::operations_research::sat::ElementConstraintProto* PROTOBUF_NONNULL _internal_mutable_element();

  public:
  // .operations_research.sat.CircuitConstraintProto circuit = 15;
  bool has_circuit() const;
  private:
  bool _internal_has_circuit() const;

  public:
  void clear_circuit() ;
  const ::operations_research::sat::CircuitConstraintProto& circuit() const;
  [[nodiscard]] ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE release_circuit();
  ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NONNULL mutable_circuit();
  void set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_circuit();

  private:
  const ::operations_research::sat::CircuitConstraintProto& _internal_circuit() const;
  ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NONNULL _internal_mutable_circuit();

  public:
  // .operations_research.sat.RoutesConstraintProto routes = 23;
  bool has_routes() const;
  private:
  bool _internal_has_routes() const;

  public:
  void clear_routes() ;
  const ::operations_research::sat::RoutesConstraintProto& routes() const;
  [[nodiscard]] ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE release_routes();
  ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NONNULL mutable_routes();
  void set_allocated_routes(::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_routes(::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_routes();

  private:
  const ::operations_research::sat::RoutesConstraintProto& _internal_routes() const;
  ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NONNULL _internal_mutable_routes();

  public:
  // .operations_research.sat.TableConstraintProto table = 16;
  bool has_table() const;
  private:
  bool _internal_has_table() const;

  public:
  void clear_table() ;
  const ::operations_research::sat::TableConstraintProto& table() const;
  [[nodiscard]] ::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE release_table();
  ::operations_research::sat::TableConstraintProto* PROTOBUF_NONNULL mutable_table();
  void set_allocated_table(::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_table(::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_table();

  private:
  const ::operations_research::sat::TableConstraintProto& _internal_table() const;
  ::operations_research::sat::TableConstraintProto* PROTOBUF_NONNULL _internal_mutable_table();

  public:
  // .operations_research.sat.AutomatonConstraintProto automaton = 17;
  bool has_automaton() const;
  private:
  bool _internal_has_automaton() const;

  public:
  void clear_automaton() ;
  const ::operations_research::sat::AutomatonConstraintProto& automaton() const;
  [[nodiscard]] ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE release_automaton();
  ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NONNULL mutable_automaton();
  void set_allocated_automaton(::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_automaton(::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_automaton();

  private:
  const ::operations_research::sat::AutomatonConstraintProto& _internal_automaton() const;
  ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NONNULL _internal_mutable_automaton();

  public:
  // .operations_research.sat.InverseConstraintProto inverse = 18;
  bool has_inverse() const;
  private:
  bool _internal_has_inverse() const;

  public:
  void clear_inverse() ;
  const ::operations_research::sat::InverseConstraintProto& inverse() const;
  [[nodiscard]] ::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE release_inverse();
  ::operations_research::sat::InverseConstraintProto* PROTOBUF_NONNULL mutable_inverse();
  void set_allocated_inverse(::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_inverse(::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_inverse();

  private:
  const ::operations_research::sat::InverseConstraintProto& _internal_inverse() const;
  ::operations_research::sat::InverseConstraintProto* PROTOBUF_NONNULL _internal_mutable_inverse();

  public:
  // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
  bool has_reservoir() const;
  private:
  bool _internal_has_reservoir() const;

  public:
  void clear_reservoir() ;
  const ::operations_research::sat::ReservoirConstraintProto& reservoir() const;
  [[nodiscard]] ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE release_reservoir();
  ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NONNULL mutable_reservoir();
  void set_allocated_reservoir(::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_reservoir(::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_reservoir();

  private:
  const ::operations_research::sat::ReservoirConstraintProto& _internal_reservoir() const;
  ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NONNULL _internal_mutable_reservoir();

  public:
  // .operations_research.sat.IntervalConstraintProto interval = 19;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;

  public:
  void clear_interval() ;
  const ::operations_research::sat::IntervalConstraintProto& interval() const;
  [[nodiscard]] ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE release_interval();
  ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NONNULL mutable_interval();
  void set_allocated_interval(::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_interval(::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_interval();

  private:
  const ::operations_research::sat::IntervalConstraintProto& _internal_interval() const;
  ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NONNULL _internal_mutable_interval();

  public:
  // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
  bool has_no_overlap() const;
  private:
  bool _internal_has_no_overlap() const;

  public:
  void clear_no_overlap() ;
  const ::operations_research::sat::NoOverlapConstraintProto& no_overlap() const;
  [[nodiscard]] ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE release_no_overlap();
  ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NONNULL mutable_no_overlap();
  void set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_no_overlap();

  private:
  const ::operations_research::sat::NoOverlapConstraintProto& _internal_no_overlap() const;
  ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NONNULL _internal_mutable_no_overlap();

  public:
  // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
  bool has_no_overlap_2d() const;
  private:
  bool _internal_has_no_overlap_2d() const;

  public:
  void clear_no_overlap_2d() ;
  const ::operations_research::sat::NoOverlap2DConstraintProto& no_overlap_2d() const;
  [[nodiscard]] ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE release_no_overlap_2d();
  ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NONNULL mutable_no_overlap_2d();
  void set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_no_overlap_2d();

  private:
  const ::operations_research::sat::NoOverlap2DConstraintProto& _internal_no_overlap_2d() const;
  ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NONNULL _internal_mutable_no_overlap_2d();

  public:
  // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
  bool has_cumulative() const;
  private:
  bool _internal_has_cumulative() const;

  public:
  void clear_cumulative() ;
  const ::operations_research::sat::CumulativeConstraintProto& cumulative() const;
  [[nodiscard]] ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE release_cumulative();
  ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NONNULL mutable_cumulative();
  void set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE unsafe_arena_release_cumulative();

  private:
  const ::operations_research::sat::CumulativeConstraintProto& _internal_cumulative() const;
  ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NONNULL _internal_mutable_cumulative();

  public:
  // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
  bool has_dummy_constraint() const;
  private:
  bool _internal_has_dummy_constraint() const;

  public:
  void clear_dummy_constraint() ;
  const ::operations_research::sat::ListOfVariablesProto& dummy_constraint() const;
  [[nodiscard]] ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE release_dummy_constraint();
  ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NONNULL mutable_dummy_constraint();
  void set_allocated_dummy_constraint(::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_dummy_constraint(::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE unsafe_arena_release_dummy_constraint();

  private:
  const ::operations_research::sat::ListOfVariablesProto& _internal_dummy_constraint() const;
  ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NONNULL _internal_mutable_dummy_constraint();

  public:
  void clear_constraint();
  ConstraintCase constraint_case() const;
  // @@protoc_insertion_point(class_scope:operations_research.sat.ConstraintProto)
 private:
  class _Internal;
  void set_has_bool_or();
  void set_has_bool_and();
  void set_has_at_most_one();
  void set_has_exactly_one();
  void set_has_bool_xor();
  void set_has_int_div();
  void set_has_int_mod();
  void set_has_int_prod();
  void set_has_lin_max();
  void set_has_linear();
  void set_has_all_diff();
  void set_has_element();
  void set_has_circuit();
  void set_has_routes();
  void set_has_table();
  void set_has_automaton();
  void set_has_inverse();
  void set_has_reservoir();
  void set_has_interval();
  void set_has_no_overlap();
  void set_has_no_overlap_2d();
  void set_has_cumulative();
  void set_has_dummy_constraint();
  inline bool has_constraint() const;
  inline void clear_has_constraint();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 25,
                                   23, 76,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ConstraintProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> enforcement_literal_;
    ::google::protobuf::internal::CachedSize _enforcement_literal_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    union ConstraintUnion {
      constexpr ConstraintUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bool_or_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bool_and_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE at_most_one_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE exactly_one_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bool_xor_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE int_div_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE int_mod_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE int_prod_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE lin_max_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE linear_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE all_diff_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE element_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE circuit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE routes_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE table_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE automaton_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE inverse_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE reservoir_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE interval_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE no_overlap_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE no_overlap_2d_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE cumulative_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE dummy_constraint_;
    } constraint_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull ConstraintProto_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CpModelProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.sat.CpModelProto) */ {
 public:
  inline CpModelProto() : CpModelProto(nullptr) {}
  ~CpModelProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CpModelProto* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CpModelProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CpModelProto(::google::protobuf::internal::ConstantInitialized);

  inline CpModelProto(const CpModelProto& from) : CpModelProto(nullptr, from) {}
  inline CpModelProto(CpModelProto&& from) noexcept
      : CpModelProto(nullptr, ::std::move(from)) {}
  inline CpModelProto& operator=(const CpModelProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CpModelProto& operator=(CpModelProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CpModelProto& default_instance() {
    return *reinterpret_cast<const CpModelProto*>(
        &_CpModelProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(CpModelProto& a, CpModelProto& b) { a.Swap(&b); }
  inline void Swap(CpModelProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CpModelProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CpModelProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CpModelProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CpModelProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CpModelProto& from) { CpModelProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CpModelProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.sat.CpModelProto"; }

  explicit CpModelProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CpModelProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CpModelProto& from);
  CpModelProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CpModelProto&& from) noexcept
      : CpModelProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVariablesFieldNumber = 2,
    kConstraintsFieldNumber = 3,
    kSearchStrategyFieldNumber = 5,
    kAssumptionsFieldNumber = 7,
    kNameFieldNumber = 1,
    kObjectiveFieldNumber = 4,
    kSolutionHintFieldNumber = 6,
    kSymmetryFieldNumber = 8,
    kFloatingPointObjectiveFieldNumber = 9,
  };
  // repeated .operations_research.sat.IntegerVariableProto variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;

  public:
  void clear_variables() ;
  ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL mutable_variables(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL mutable_variables();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& _internal_variables() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL _internal_mutable_variables();
  public:
  const ::operations_research::sat::IntegerVariableProto& variables(int index) const;
  ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL add_variables();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& variables() const;
  // repeated .operations_research.sat.ConstraintProto constraints = 3;
  int constraints_size() const;
  private:
  int _internal_constraints_size() const;

  public:
  void clear_constraints() ;
  ::operations_research::sat::ConstraintProto* PROTOBUF_NONNULL mutable_constraints(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>* PROTOBUF_NONNULL mutable_constraints();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>& _internal_constraints() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>* PROTOBUF_NONNULL _internal_mutable_constraints();
  public:
  const ::operations_research::sat::ConstraintProto& constraints(int index) const;
  ::operations_research::sat::ConstraintProto* PROTOBUF_NONNULL add_constraints();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>& constraints() const;
  // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
  int search_strategy_size() const;
  private:
  int _internal_search_strategy_size() const;

  public:
  void clear_search_strategy() ;
  ::operations_research::sat::DecisionStrategyProto* PROTOBUF_NONNULL mutable_search_strategy(int index);
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>* PROTOBUF_NONNULL mutable_search_strategy();

  private:
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>& _internal_search_strategy() const;
  ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>* PROTOBUF_NONNULL _internal_mutable_search_strategy();
  public:
  const ::operations_research::sat::DecisionStrategyProto& search_strategy(int index) const;
  ::operations_research::sat::DecisionStrategyProto* PROTOBUF_NONNULL add_search_strategy();
  const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>& search_strategy() const;
  // repeated int32 assumptions = 7;
  int assumptions_size() const;
  private:
  int _internal_assumptions_size() const;

  public:
  void clear_assumptions() ;
  ::int32_t assumptions(int index) const;
  void set_assumptions(int index, ::int32_t value);
  void add_assumptions(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& assumptions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_assumptions();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_assumptions() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_assumptions();

  public:
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // .operations_research.sat.CpObjectiveProto objective = 4;
  bool has_objective() const;
  void clear_objective() ;
  const ::operations_research::sat::CpObjectiveProto& objective() const;
  [[nodiscard]] ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE release_objective();
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL mutable_objective();
  void set_allocated_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE unsafe_arena_release_objective();

  private:
  const ::operations_research::sat::CpObjectiveProto& _internal_objective() const;
  ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL _internal_mutable_objective();

  public:
  // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
  bool has_solution_hint() const;
  void clear_solution_hint() ;
  const ::operations_research::sat::PartialVariableAssignment& solution_hint() const;
  [[nodiscard]] ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE release_solution_hint();
  ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NONNULL mutable_solution_hint();
  void set_allocated_solution_hint(::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_solution_hint(::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE value);
  ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE unsafe_arena_release_solution_hint();

  private:
  const ::operations_research::sat::PartialVariableAssignment& _internal_solution_hint() const;
  ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NONNULL _internal_mutable_solution_hint();

  public:
  // .operations_research.sat.SymmetryProto symmetry = 8;
  bool has_symmetry() const;
  void clear_symmetry() ;
  const ::operations_research::sat::SymmetryProto& symmetry() const;
  [[nodiscard]] ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE release_symmetry();
  ::operations_research::sat::SymmetryProto* PROTOBUF_NONNULL mutable_symmetry();
  void set_allocated_symmetry(::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_symmetry(::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE unsafe_arena_release_symmetry();

  private:
  const ::operations_research::sat::SymmetryProto& _internal_symmetry() const;
  ::operations_research::sat::SymmetryProto* PROTOBUF_NONNULL _internal_mutable_symmetry();

  public:
  // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
  bool has_floating_point_objective() const;
  void clear_floating_point_objective() ;
  const ::operations_research::sat::FloatObjectiveProto& floating_point_objective() const;
  [[nodiscard]] ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE release_floating_point_objective();
  ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NONNULL mutable_floating_point_objective();
  void set_allocated_floating_point_objective(::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_floating_point_objective(::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE value);
  ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE unsafe_arena_release_floating_point_objective();

  private:
  const ::operations_research::sat::FloatObjectiveProto& _internal_floating_point_objective() const;
  ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NONNULL _internal_mutable_floating_point_objective();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.sat.CpModelProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   7, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CpModelProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::IntegerVariableProto > variables_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::ConstraintProto > constraints_;
    ::google::protobuf::RepeatedPtrField< ::operations_research::sat::DecisionStrategyProto > search_strategy_;
    ::google::protobuf::RepeatedField<::int32_t> assumptions_;
    ::google::protobuf::internal::CachedSize _assumptions_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE objective_;
    ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE solution_hint_;
    ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE symmetry_;
    ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE floating_point_objective_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CpModelProto_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// IntegerVariableProto

// string name = 1;
inline void IntegerVariableProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& IntegerVariableProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerVariableProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void IntegerVariableProto::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerVariableProto.name)
}
inline ::std::string* PROTOBUF_NONNULL IntegerVariableProto::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.IntegerVariableProto.name)
  return _s;
}
inline const ::std::string& IntegerVariableProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void IntegerVariableProto::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL IntegerVariableProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE IntegerVariableProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.IntegerVariableProto.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void IntegerVariableProto::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.IntegerVariableProto.name)
}

// repeated int64 domain = 2;
inline int IntegerVariableProto::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int IntegerVariableProto::domain_size() const {
  return _internal_domain_size();
}
inline void IntegerVariableProto::clear_domain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.domain_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t IntegerVariableProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntegerVariableProto.domain)
  return _internal_domain().Get(index);
}
inline void IntegerVariableProto::set_domain(int index, ::int64_t value) {
  _internal_mutable_domain()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.IntegerVariableProto.domain)
}
inline void IntegerVariableProto::add_domain(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_domain()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.IntegerVariableProto.domain)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& IntegerVariableProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.IntegerVariableProto.domain)
  return _internal_domain();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL IntegerVariableProto::mutable_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.IntegerVariableProto.domain)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_domain();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
IntegerVariableProto::_internal_domain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
IntegerVariableProto::_internal_mutable_domain() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// BoolArgumentProto

// repeated int32 literals = 1;
inline int BoolArgumentProto::_internal_literals_size() const {
  return _internal_literals().size();
}
inline int BoolArgumentProto::literals_size() const {
  return _internal_literals_size();
}
inline void BoolArgumentProto::clear_literals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.literals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t BoolArgumentProto::literals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.BoolArgumentProto.literals)
  return _internal_literals().Get(index);
}
inline void BoolArgumentProto::set_literals(int index, ::int32_t value) {
  _internal_mutable_literals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.BoolArgumentProto.literals)
}
inline void BoolArgumentProto::add_literals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_literals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.BoolArgumentProto.literals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& BoolArgumentProto::literals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.BoolArgumentProto.literals)
  return _internal_literals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL BoolArgumentProto::mutable_literals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.BoolArgumentProto.literals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_literals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
BoolArgumentProto::_internal_literals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.literals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
BoolArgumentProto::_internal_mutable_literals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.literals_;
}

// -------------------------------------------------------------------

// LinearExpressionProto

// repeated int32 vars = 1;
inline int LinearExpressionProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int LinearExpressionProto::vars_size() const {
  return _internal_vars_size();
}
inline void LinearExpressionProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t LinearExpressionProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearExpressionProto.vars)
  return _internal_vars().Get(index);
}
inline void LinearExpressionProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearExpressionProto.vars)
}
inline void LinearExpressionProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearExpressionProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& LinearExpressionProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearExpressionProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL LinearExpressionProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearExpressionProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
LinearExpressionProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
LinearExpressionProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated int64 coeffs = 2;
inline int LinearExpressionProto::_internal_coeffs_size() const {
  return _internal_coeffs().size();
}
inline int LinearExpressionProto::coeffs_size() const {
  return _internal_coeffs_size();
}
inline void LinearExpressionProto::clear_coeffs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coeffs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t LinearExpressionProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearExpressionProto.coeffs)
  return _internal_coeffs().Get(index);
}
inline void LinearExpressionProto::set_coeffs(int index, ::int64_t value) {
  _internal_mutable_coeffs()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearExpressionProto.coeffs)
}
inline void LinearExpressionProto::add_coeffs(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_coeffs()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearExpressionProto.coeffs)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& LinearExpressionProto::coeffs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearExpressionProto.coeffs)
  return _internal_coeffs();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL LinearExpressionProto::mutable_coeffs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearExpressionProto.coeffs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_coeffs();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
LinearExpressionProto::_internal_coeffs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coeffs_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
LinearExpressionProto::_internal_mutable_coeffs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.coeffs_;
}

// int64 offset = 3;
inline void LinearExpressionProto::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int64_t LinearExpressionProto::offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearExpressionProto.offset)
  return _internal_offset();
}
inline void LinearExpressionProto::set_offset(::int64_t value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearExpressionProto.offset)
}
inline ::int64_t LinearExpressionProto::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void LinearExpressionProto::_internal_set_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// LinearArgumentProto

// .operations_research.sat.LinearExpressionProto target = 1;
inline bool LinearArgumentProto::has_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void LinearArgumentProto::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::operations_research::sat::LinearExpressionProto& LinearArgumentProto::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& LinearArgumentProto::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearArgumentProto.target)
  return _internal_target();
}
inline void LinearArgumentProto::unsafe_arena_set_allocated_target(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.LinearArgumentProto.target)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE LinearArgumentProto::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE LinearArgumentProto::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.LinearArgumentProto.target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL LinearArgumentProto::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.target_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL LinearArgumentProto::mutable_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.LinearArgumentProto.target)
  return _msg;
}
inline void LinearArgumentProto::set_allocated_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.LinearArgumentProto.target)
}

// repeated .operations_research.sat.LinearExpressionProto exprs = 2;
inline int LinearArgumentProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int LinearArgumentProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void LinearArgumentProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL LinearArgumentProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.LinearArgumentProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL LinearArgumentProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearArgumentProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& LinearArgumentProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearArgumentProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL LinearArgumentProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearArgumentProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& LinearArgumentProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearArgumentProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
LinearArgumentProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
LinearArgumentProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// -------------------------------------------------------------------

// AllDifferentConstraintProto

// repeated .operations_research.sat.LinearExpressionProto exprs = 1;
inline int AllDifferentConstraintProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int AllDifferentConstraintProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void AllDifferentConstraintProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL AllDifferentConstraintProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.AllDifferentConstraintProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL AllDifferentConstraintProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AllDifferentConstraintProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& AllDifferentConstraintProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.AllDifferentConstraintProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL AllDifferentConstraintProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AllDifferentConstraintProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& AllDifferentConstraintProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AllDifferentConstraintProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
AllDifferentConstraintProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
AllDifferentConstraintProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// -------------------------------------------------------------------

// LinearConstraintProto

// repeated int32 vars = 1;
inline int LinearConstraintProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int LinearConstraintProto::vars_size() const {
  return _internal_vars_size();
}
inline void LinearConstraintProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t LinearConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.vars)
  return _internal_vars().Get(index);
}
inline void LinearConstraintProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.vars)
}
inline void LinearConstraintProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& LinearConstraintProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL LinearConstraintProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
LinearConstraintProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
LinearConstraintProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated int64 coeffs = 2;
inline int LinearConstraintProto::_internal_coeffs_size() const {
  return _internal_coeffs().size();
}
inline int LinearConstraintProto::coeffs_size() const {
  return _internal_coeffs_size();
}
inline void LinearConstraintProto::clear_coeffs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coeffs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t LinearConstraintProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.coeffs)
  return _internal_coeffs().Get(index);
}
inline void LinearConstraintProto::set_coeffs(int index, ::int64_t value) {
  _internal_mutable_coeffs()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.coeffs)
}
inline void LinearConstraintProto::add_coeffs(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_coeffs()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.coeffs)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& LinearConstraintProto::coeffs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.coeffs)
  return _internal_coeffs();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL LinearConstraintProto::mutable_coeffs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.coeffs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_coeffs();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
LinearConstraintProto::_internal_coeffs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coeffs_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
LinearConstraintProto::_internal_mutable_coeffs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.coeffs_;
}

// repeated int64 domain = 3;
inline int LinearConstraintProto::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int LinearConstraintProto::domain_size() const {
  return _internal_domain_size();
}
inline void LinearConstraintProto::clear_domain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.domain_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int64_t LinearConstraintProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.LinearConstraintProto.domain)
  return _internal_domain().Get(index);
}
inline void LinearConstraintProto::set_domain(int index, ::int64_t value) {
  _internal_mutable_domain()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.LinearConstraintProto.domain)
}
inline void LinearConstraintProto::add_domain(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_domain()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.LinearConstraintProto.domain)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& LinearConstraintProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.LinearConstraintProto.domain)
  return _internal_domain();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL LinearConstraintProto::mutable_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.LinearConstraintProto.domain)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_domain();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
LinearConstraintProto::_internal_domain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
LinearConstraintProto::_internal_mutable_domain() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// ElementConstraintProto

// int32 index = 1;
inline void ElementConstraintProto::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t ElementConstraintProto::index() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.index)
  return _internal_index();
}
inline void ElementConstraintProto::set_index(::int32_t value) {
  _internal_set_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.index)
}
inline ::int32_t ElementConstraintProto::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void ElementConstraintProto::_internal_set_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// int32 target = 2;
inline void ElementConstraintProto::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int32_t ElementConstraintProto::target() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.target)
  return _internal_target();
}
inline void ElementConstraintProto::set_target(::int32_t value) {
  _internal_set_target(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.target)
}
inline ::int32_t ElementConstraintProto::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void ElementConstraintProto::_internal_set_target(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// repeated int32 vars = 3;
inline int ElementConstraintProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int ElementConstraintProto::vars_size() const {
  return _internal_vars_size();
}
inline void ElementConstraintProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t ElementConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.vars)
  return _internal_vars().Get(index);
}
inline void ElementConstraintProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ElementConstraintProto.vars)
}
inline void ElementConstraintProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ElementConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ElementConstraintProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ElementConstraintProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL ElementConstraintProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ElementConstraintProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ElementConstraintProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
ElementConstraintProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// .operations_research.sat.LinearExpressionProto linear_index = 4;
inline bool ElementConstraintProto::has_linear_index() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.linear_index_ != nullptr);
  return value;
}
inline void ElementConstraintProto::clear_linear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.linear_index_ != nullptr) _impl_.linear_index_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::operations_research::sat::LinearExpressionProto& ElementConstraintProto::_internal_linear_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.linear_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& ElementConstraintProto::linear_index() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.linear_index)
  return _internal_linear_index();
}
inline void ElementConstraintProto::unsafe_arena_set_allocated_linear_index(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_index_);
  }
  _impl_.linear_index_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ElementConstraintProto.linear_index)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE ElementConstraintProto::release_linear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.linear_index_;
  _impl_.linear_index_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE ElementConstraintProto::unsafe_arena_release_linear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.ElementConstraintProto.linear_index)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.linear_index_;
  _impl_.linear_index_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::_internal_mutable_linear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.linear_index_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.linear_index_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.linear_index_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::mutable_linear_index()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_linear_index();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ElementConstraintProto.linear_index)
  return _msg;
}
inline void ElementConstraintProto::set_allocated_linear_index(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_index_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.linear_index_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ElementConstraintProto.linear_index)
}

// .operations_research.sat.LinearExpressionProto linear_target = 5;
inline bool ElementConstraintProto::has_linear_target() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.linear_target_ != nullptr);
  return value;
}
inline void ElementConstraintProto::clear_linear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.linear_target_ != nullptr) _impl_.linear_target_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline const ::operations_research::sat::LinearExpressionProto& ElementConstraintProto::_internal_linear_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.linear_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& ElementConstraintProto::linear_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.linear_target)
  return _internal_linear_target();
}
inline void ElementConstraintProto::unsafe_arena_set_allocated_linear_target(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_target_);
  }
  _impl_.linear_target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ElementConstraintProto.linear_target)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE ElementConstraintProto::release_linear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.linear_target_;
  _impl_.linear_target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE ElementConstraintProto::unsafe_arena_release_linear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.ElementConstraintProto.linear_target)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.linear_target_;
  _impl_.linear_target_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::_internal_mutable_linear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.linear_target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.linear_target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.linear_target_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::mutable_linear_target()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_linear_target();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ElementConstraintProto.linear_target)
  return _msg;
}
inline void ElementConstraintProto::set_allocated_linear_target(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.linear_target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.linear_target_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ElementConstraintProto.linear_target)
}

// repeated .operations_research.sat.LinearExpressionProto exprs = 6;
inline int ElementConstraintProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int ElementConstraintProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void ElementConstraintProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ElementConstraintProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL ElementConstraintProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ElementConstraintProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& ElementConstraintProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ElementConstraintProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ElementConstraintProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ElementConstraintProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& ElementConstraintProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ElementConstraintProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
ElementConstraintProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
ElementConstraintProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// -------------------------------------------------------------------

// IntervalConstraintProto

// .operations_research.sat.LinearExpressionProto start = 4;
inline bool IntervalConstraintProto::has_start() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline void IntervalConstraintProto::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.start)
  return _internal_start();
}
inline void IntervalConstraintProto::unsafe_arena_set_allocated_start(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.IntervalConstraintProto.start)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.start_;
  _impl_.start_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::unsafe_arena_release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.IntervalConstraintProto.start)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::_internal_mutable_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.start_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.start_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::mutable_start()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.IntervalConstraintProto.start)
  return _msg;
}
inline void IntervalConstraintProto::set_allocated_start(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.start_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.IntervalConstraintProto.start)
}

// .operations_research.sat.LinearExpressionProto end = 5;
inline bool IntervalConstraintProto::has_end() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline void IntervalConstraintProto::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.end)
  return _internal_end();
}
inline void IntervalConstraintProto::unsafe_arena_set_allocated_end(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.IntervalConstraintProto.end)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.end_;
  _impl_.end_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::unsafe_arena_release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.IntervalConstraintProto.end)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::_internal_mutable_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.end_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.end_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::mutable_end()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.IntervalConstraintProto.end)
  return _msg;
}
inline void IntervalConstraintProto::set_allocated_end(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.end_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.IntervalConstraintProto.end)
}

// .operations_research.sat.LinearExpressionProto size = 6;
inline bool IntervalConstraintProto::has_size() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.size_ != nullptr);
  return value;
}
inline void IntervalConstraintProto::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.size_ != nullptr) _impl_.size_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& IntervalConstraintProto::size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.IntervalConstraintProto.size)
  return _internal_size();
}
inline void IntervalConstraintProto::unsafe_arena_set_allocated_size(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.IntervalConstraintProto.size)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::release_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.size_;
  _impl_.size_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE IntervalConstraintProto::unsafe_arena_release_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.IntervalConstraintProto.size)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::_internal_mutable_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.size_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.size_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.size_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL IntervalConstraintProto::mutable_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.IntervalConstraintProto.size)
  return _msg;
}
inline void IntervalConstraintProto::set_allocated_size(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.size_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.size_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.IntervalConstraintProto.size)
}

// -------------------------------------------------------------------

// NoOverlapConstraintProto

// repeated int32 intervals = 1;
inline int NoOverlapConstraintProto::_internal_intervals_size() const {
  return _internal_intervals().size();
}
inline int NoOverlapConstraintProto::intervals_size() const {
  return _internal_intervals_size();
}
inline void NoOverlapConstraintProto::clear_intervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intervals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t NoOverlapConstraintProto::intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlapConstraintProto.intervals)
  return _internal_intervals().Get(index);
}
inline void NoOverlapConstraintProto::set_intervals(int index, ::int32_t value) {
  _internal_mutable_intervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlapConstraintProto.intervals)
}
inline void NoOverlapConstraintProto::add_intervals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_intervals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlapConstraintProto.intervals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NoOverlapConstraintProto::intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlapConstraintProto.intervals)
  return _internal_intervals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL NoOverlapConstraintProto::mutable_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlapConstraintProto.intervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_intervals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
NoOverlapConstraintProto::_internal_intervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intervals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
NoOverlapConstraintProto::_internal_mutable_intervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.intervals_;
}

// -------------------------------------------------------------------

// NoOverlap2DConstraintProto

// repeated int32 x_intervals = 1;
inline int NoOverlap2DConstraintProto::_internal_x_intervals_size() const {
  return _internal_x_intervals().size();
}
inline int NoOverlap2DConstraintProto::x_intervals_size() const {
  return _internal_x_intervals_size();
}
inline void NoOverlap2DConstraintProto::clear_x_intervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_intervals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t NoOverlap2DConstraintProto::x_intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  return _internal_x_intervals().Get(index);
}
inline void NoOverlap2DConstraintProto::set_x_intervals(int index, ::int32_t value) {
  _internal_mutable_x_intervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
}
inline void NoOverlap2DConstraintProto::add_x_intervals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_x_intervals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NoOverlap2DConstraintProto::x_intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  return _internal_x_intervals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL NoOverlap2DConstraintProto::mutable_x_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlap2DConstraintProto.x_intervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_x_intervals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
NoOverlap2DConstraintProto::_internal_x_intervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_intervals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
NoOverlap2DConstraintProto::_internal_mutable_x_intervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.x_intervals_;
}

// repeated int32 y_intervals = 2;
inline int NoOverlap2DConstraintProto::_internal_y_intervals_size() const {
  return _internal_y_intervals().size();
}
inline int NoOverlap2DConstraintProto::y_intervals_size() const {
  return _internal_y_intervals_size();
}
inline void NoOverlap2DConstraintProto::clear_y_intervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_intervals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t NoOverlap2DConstraintProto::y_intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  return _internal_y_intervals().Get(index);
}
inline void NoOverlap2DConstraintProto::set_y_intervals(int index, ::int32_t value) {
  _internal_mutable_y_intervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
}
inline void NoOverlap2DConstraintProto::add_y_intervals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_y_intervals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NoOverlap2DConstraintProto::y_intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  return _internal_y_intervals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL NoOverlap2DConstraintProto::mutable_y_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.NoOverlap2DConstraintProto.y_intervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_y_intervals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
NoOverlap2DConstraintProto::_internal_y_intervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_intervals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
NoOverlap2DConstraintProto::_internal_mutable_y_intervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.y_intervals_;
}

// -------------------------------------------------------------------

// CumulativeConstraintProto

// .operations_research.sat.LinearExpressionProto capacity = 1;
inline bool CumulativeConstraintProto::has_capacity() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.capacity_ != nullptr);
  return value;
}
inline void CumulativeConstraintProto::clear_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capacity_ != nullptr) _impl_.capacity_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::operations_research::sat::LinearExpressionProto& CumulativeConstraintProto::_internal_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::LinearExpressionProto* p = _impl_.capacity_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::LinearExpressionProto&>(::operations_research::sat::_LinearExpressionProto_default_instance_);
}
inline const ::operations_research::sat::LinearExpressionProto& CumulativeConstraintProto::capacity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.capacity)
  return _internal_capacity();
}
inline void CumulativeConstraintProto::unsafe_arena_set_allocated_capacity(
    ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacity_);
  }
  _impl_.capacity_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CumulativeConstraintProto.capacity)
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE CumulativeConstraintProto::release_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* released = _impl_.capacity_;
  _impl_.capacity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE CumulativeConstraintProto::unsafe_arena_release_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CumulativeConstraintProto.capacity)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* temp = _impl_.capacity_;
  _impl_.capacity_ = nullptr;
  return temp;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL CumulativeConstraintProto::_internal_mutable_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.capacity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearExpressionProto>(GetArena());
    _impl_.capacity_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(p);
  }
  return _impl_.capacity_;
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL CumulativeConstraintProto::mutable_capacity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::operations_research::sat::LinearExpressionProto* _msg = _internal_mutable_capacity();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CumulativeConstraintProto.capacity)
  return _msg;
}
inline void CumulativeConstraintProto::set_allocated_capacity(::operations_research::sat::LinearExpressionProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.capacity_ = reinterpret_cast<::operations_research::sat::LinearExpressionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CumulativeConstraintProto.capacity)
}

// repeated int32 intervals = 2;
inline int CumulativeConstraintProto::_internal_intervals_size() const {
  return _internal_intervals().size();
}
inline int CumulativeConstraintProto::intervals_size() const {
  return _internal_intervals_size();
}
inline void CumulativeConstraintProto::clear_intervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.intervals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t CumulativeConstraintProto::intervals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.intervals)
  return _internal_intervals().Get(index);
}
inline void CumulativeConstraintProto::set_intervals(int index, ::int32_t value) {
  _internal_mutable_intervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CumulativeConstraintProto.intervals)
}
inline void CumulativeConstraintProto::add_intervals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_intervals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CumulativeConstraintProto.intervals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CumulativeConstraintProto::intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CumulativeConstraintProto.intervals)
  return _internal_intervals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CumulativeConstraintProto::mutable_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CumulativeConstraintProto.intervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_intervals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CumulativeConstraintProto::_internal_intervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.intervals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CumulativeConstraintProto::_internal_mutable_intervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.intervals_;
}

// repeated .operations_research.sat.LinearExpressionProto demands = 3;
inline int CumulativeConstraintProto::_internal_demands_size() const {
  return _internal_demands().size();
}
inline int CumulativeConstraintProto::demands_size() const {
  return _internal_demands_size();
}
inline void CumulativeConstraintProto::clear_demands() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.demands_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL CumulativeConstraintProto::mutable_demands(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CumulativeConstraintProto.demands)
  return _internal_mutable_demands()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL CumulativeConstraintProto::mutable_demands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CumulativeConstraintProto.demands)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_demands();
}
inline const ::operations_research::sat::LinearExpressionProto& CumulativeConstraintProto::demands(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CumulativeConstraintProto.demands)
  return _internal_demands().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL CumulativeConstraintProto::add_demands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_demands()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CumulativeConstraintProto.demands)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& CumulativeConstraintProto::demands() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CumulativeConstraintProto.demands)
  return _internal_demands();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
CumulativeConstraintProto::_internal_demands() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.demands_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
CumulativeConstraintProto::_internal_mutable_demands() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.demands_;
}

// -------------------------------------------------------------------

// ReservoirConstraintProto

// int64 min_level = 1;
inline void ReservoirConstraintProto::clear_min_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_level_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int64_t ReservoirConstraintProto::min_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ReservoirConstraintProto.min_level)
  return _internal_min_level();
}
inline void ReservoirConstraintProto::set_min_level(::int64_t value) {
  _internal_set_min_level(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:operations_research.sat.ReservoirConstraintProto.min_level)
}
inline ::int64_t ReservoirConstraintProto::_internal_min_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_level_;
}
inline void ReservoirConstraintProto::_internal_set_min_level(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_level_ = value;
}

// int64 max_level = 2;
inline void ReservoirConstraintProto::clear_max_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_level_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int64_t ReservoirConstraintProto::max_level() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ReservoirConstraintProto.max_level)
  return _internal_max_level();
}
inline void ReservoirConstraintProto::set_max_level(::int64_t value) {
  _internal_set_max_level(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:operations_research.sat.ReservoirConstraintProto.max_level)
}
inline ::int64_t ReservoirConstraintProto::_internal_max_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_level_;
}
inline void ReservoirConstraintProto::_internal_set_max_level(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_level_ = value;
}

// repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
inline int ReservoirConstraintProto::_internal_time_exprs_size() const {
  return _internal_time_exprs().size();
}
inline int ReservoirConstraintProto::time_exprs_size() const {
  return _internal_time_exprs_size();
}
inline void ReservoirConstraintProto::clear_time_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ReservoirConstraintProto::mutable_time_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ReservoirConstraintProto.time_exprs)
  return _internal_mutable_time_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL ReservoirConstraintProto::mutable_time_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ReservoirConstraintProto.time_exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_time_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& ReservoirConstraintProto::time_exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ReservoirConstraintProto.time_exprs)
  return _internal_time_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ReservoirConstraintProto::add_time_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_time_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ReservoirConstraintProto.time_exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& ReservoirConstraintProto::time_exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ReservoirConstraintProto.time_exprs)
  return _internal_time_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
ReservoirConstraintProto::_internal_time_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
ReservoirConstraintProto::_internal_mutable_time_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.time_exprs_;
}

// repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
inline int ReservoirConstraintProto::_internal_level_changes_size() const {
  return _internal_level_changes().size();
}
inline int ReservoirConstraintProto::level_changes_size() const {
  return _internal_level_changes_size();
}
inline void ReservoirConstraintProto::clear_level_changes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_changes_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ReservoirConstraintProto::mutable_level_changes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ReservoirConstraintProto.level_changes)
  return _internal_mutable_level_changes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL ReservoirConstraintProto::mutable_level_changes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ReservoirConstraintProto.level_changes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_level_changes();
}
inline const ::operations_research::sat::LinearExpressionProto& ReservoirConstraintProto::level_changes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ReservoirConstraintProto.level_changes)
  return _internal_level_changes().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL ReservoirConstraintProto::add_level_changes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_level_changes()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ReservoirConstraintProto.level_changes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& ReservoirConstraintProto::level_changes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ReservoirConstraintProto.level_changes)
  return _internal_level_changes();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
ReservoirConstraintProto::_internal_level_changes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_changes_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
ReservoirConstraintProto::_internal_mutable_level_changes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.level_changes_;
}

// repeated int32 active_literals = 5;
inline int ReservoirConstraintProto::_internal_active_literals_size() const {
  return _internal_active_literals().size();
}
inline int ReservoirConstraintProto::active_literals_size() const {
  return _internal_active_literals_size();
}
inline void ReservoirConstraintProto::clear_active_literals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_literals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t ReservoirConstraintProto::active_literals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ReservoirConstraintProto.active_literals)
  return _internal_active_literals().Get(index);
}
inline void ReservoirConstraintProto::set_active_literals(int index, ::int32_t value) {
  _internal_mutable_active_literals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ReservoirConstraintProto.active_literals)
}
inline void ReservoirConstraintProto::add_active_literals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_active_literals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ReservoirConstraintProto.active_literals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ReservoirConstraintProto::active_literals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ReservoirConstraintProto.active_literals)
  return _internal_active_literals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL ReservoirConstraintProto::mutable_active_literals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ReservoirConstraintProto.active_literals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_active_literals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ReservoirConstraintProto::_internal_active_literals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_literals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
ReservoirConstraintProto::_internal_mutable_active_literals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.active_literals_;
}

// -------------------------------------------------------------------

// CircuitConstraintProto

// repeated int32 tails = 3;
inline int CircuitConstraintProto::_internal_tails_size() const {
  return _internal_tails().size();
}
inline int CircuitConstraintProto::tails_size() const {
  return _internal_tails_size();
}
inline void CircuitConstraintProto::clear_tails() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tails_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t CircuitConstraintProto::tails(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CircuitConstraintProto.tails)
  return _internal_tails().Get(index);
}
inline void CircuitConstraintProto::set_tails(int index, ::int32_t value) {
  _internal_mutable_tails()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CircuitConstraintProto.tails)
}
inline void CircuitConstraintProto::add_tails(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tails()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CircuitConstraintProto.tails)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CircuitConstraintProto::tails() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CircuitConstraintProto.tails)
  return _internal_tails();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CircuitConstraintProto::mutable_tails()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CircuitConstraintProto.tails)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tails();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CircuitConstraintProto::_internal_tails() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tails_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CircuitConstraintProto::_internal_mutable_tails() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tails_;
}

// repeated int32 heads = 4;
inline int CircuitConstraintProto::_internal_heads_size() const {
  return _internal_heads().size();
}
inline int CircuitConstraintProto::heads_size() const {
  return _internal_heads_size();
}
inline void CircuitConstraintProto::clear_heads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heads_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t CircuitConstraintProto::heads(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CircuitConstraintProto.heads)
  return _internal_heads().Get(index);
}
inline void CircuitConstraintProto::set_heads(int index, ::int32_t value) {
  _internal_mutable_heads()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CircuitConstraintProto.heads)
}
inline void CircuitConstraintProto::add_heads(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_heads()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CircuitConstraintProto.heads)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CircuitConstraintProto::heads() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CircuitConstraintProto.heads)
  return _internal_heads();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CircuitConstraintProto::mutable_heads()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CircuitConstraintProto.heads)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_heads();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CircuitConstraintProto::_internal_heads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heads_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CircuitConstraintProto::_internal_mutable_heads() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.heads_;
}

// repeated int32 literals = 5;
inline int CircuitConstraintProto::_internal_literals_size() const {
  return _internal_literals().size();
}
inline int CircuitConstraintProto::literals_size() const {
  return _internal_literals_size();
}
inline void CircuitConstraintProto::clear_literals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.literals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t CircuitConstraintProto::literals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CircuitConstraintProto.literals)
  return _internal_literals().Get(index);
}
inline void CircuitConstraintProto::set_literals(int index, ::int32_t value) {
  _internal_mutable_literals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CircuitConstraintProto.literals)
}
inline void CircuitConstraintProto::add_literals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_literals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CircuitConstraintProto.literals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CircuitConstraintProto::literals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CircuitConstraintProto.literals)
  return _internal_literals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CircuitConstraintProto::mutable_literals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CircuitConstraintProto.literals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_literals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CircuitConstraintProto::_internal_literals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.literals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CircuitConstraintProto::_internal_mutable_literals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.literals_;
}

// -------------------------------------------------------------------

// RoutesConstraintProto_NodeExpressions

// repeated .operations_research.sat.LinearExpressionProto exprs = 1;
inline int RoutesConstraintProto_NodeExpressions::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int RoutesConstraintProto_NodeExpressions::exprs_size() const {
  return _internal_exprs_size();
}
inline void RoutesConstraintProto_NodeExpressions::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.RoutesConstraintProto.NodeExpressions.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.NodeExpressions.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& RoutesConstraintProto_NodeExpressions::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.NodeExpressions.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.NodeExpressions.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& RoutesConstraintProto_NodeExpressions::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.NodeExpressions.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
RoutesConstraintProto_NodeExpressions::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
RoutesConstraintProto_NodeExpressions::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// -------------------------------------------------------------------

// RoutesConstraintProto

// repeated int32 tails = 1;
inline int RoutesConstraintProto::_internal_tails_size() const {
  return _internal_tails().size();
}
inline int RoutesConstraintProto::tails_size() const {
  return _internal_tails_size();
}
inline void RoutesConstraintProto::clear_tails() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tails_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t RoutesConstraintProto::tails(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.tails)
  return _internal_tails().Get(index);
}
inline void RoutesConstraintProto::set_tails(int index, ::int32_t value) {
  _internal_mutable_tails()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.RoutesConstraintProto.tails)
}
inline void RoutesConstraintProto::add_tails(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tails()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.tails)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RoutesConstraintProto::tails() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.tails)
  return _internal_tails();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL RoutesConstraintProto::mutable_tails()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.tails)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tails();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RoutesConstraintProto::_internal_tails() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tails_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
RoutesConstraintProto::_internal_mutable_tails() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tails_;
}

// repeated int32 heads = 2;
inline int RoutesConstraintProto::_internal_heads_size() const {
  return _internal_heads().size();
}
inline int RoutesConstraintProto::heads_size() const {
  return _internal_heads_size();
}
inline void RoutesConstraintProto::clear_heads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heads_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t RoutesConstraintProto::heads(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.heads)
  return _internal_heads().Get(index);
}
inline void RoutesConstraintProto::set_heads(int index, ::int32_t value) {
  _internal_mutable_heads()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.RoutesConstraintProto.heads)
}
inline void RoutesConstraintProto::add_heads(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_heads()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.heads)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RoutesConstraintProto::heads() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.heads)
  return _internal_heads();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL RoutesConstraintProto::mutable_heads()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.heads)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_heads();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RoutesConstraintProto::_internal_heads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heads_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
RoutesConstraintProto::_internal_mutable_heads() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.heads_;
}

// repeated int32 literals = 3;
inline int RoutesConstraintProto::_internal_literals_size() const {
  return _internal_literals().size();
}
inline int RoutesConstraintProto::literals_size() const {
  return _internal_literals_size();
}
inline void RoutesConstraintProto::clear_literals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.literals_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t RoutesConstraintProto::literals(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.literals)
  return _internal_literals().Get(index);
}
inline void RoutesConstraintProto::set_literals(int index, ::int32_t value) {
  _internal_mutable_literals()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.RoutesConstraintProto.literals)
}
inline void RoutesConstraintProto::add_literals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_literals()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.literals)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RoutesConstraintProto::literals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.literals)
  return _internal_literals();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL RoutesConstraintProto::mutable_literals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.literals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_literals();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RoutesConstraintProto::_internal_literals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.literals_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
RoutesConstraintProto::_internal_mutable_literals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.literals_;
}

// repeated int32 demands = 4;
inline int RoutesConstraintProto::_internal_demands_size() const {
  return _internal_demands().size();
}
inline int RoutesConstraintProto::demands_size() const {
  return _internal_demands_size();
}
inline void RoutesConstraintProto::clear_demands() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.demands_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t RoutesConstraintProto::demands(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.demands)
  return _internal_demands().Get(index);
}
inline void RoutesConstraintProto::set_demands(int index, ::int32_t value) {
  _internal_mutable_demands()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.RoutesConstraintProto.demands)
}
inline void RoutesConstraintProto::add_demands(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_demands()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.demands)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RoutesConstraintProto::demands() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.demands)
  return _internal_demands();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL RoutesConstraintProto::mutable_demands()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.demands)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_demands();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RoutesConstraintProto::_internal_demands() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.demands_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
RoutesConstraintProto::_internal_mutable_demands() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.demands_;
}

// int64 capacity = 5;
inline void RoutesConstraintProto::clear_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int64_t RoutesConstraintProto::capacity() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.capacity)
  return _internal_capacity();
}
inline void RoutesConstraintProto::set_capacity(::int64_t value) {
  _internal_set_capacity(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:operations_research.sat.RoutesConstraintProto.capacity)
}
inline ::int64_t RoutesConstraintProto::_internal_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capacity_;
}
inline void RoutesConstraintProto::_internal_set_capacity(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = value;
}

// repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
inline int RoutesConstraintProto::_internal_dimensions_size() const {
  return _internal_dimensions().size();
}
inline int RoutesConstraintProto::dimensions_size() const {
  return _internal_dimensions_size();
}
inline void RoutesConstraintProto::clear_dimensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dimensions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::operations_research::sat::RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL RoutesConstraintProto::mutable_dimensions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.RoutesConstraintProto.dimensions)
  return _internal_mutable_dimensions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>* PROTOBUF_NONNULL RoutesConstraintProto::mutable_dimensions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.RoutesConstraintProto.dimensions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dimensions();
}
inline const ::operations_research::sat::RoutesConstraintProto_NodeExpressions& RoutesConstraintProto::dimensions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.RoutesConstraintProto.dimensions)
  return _internal_dimensions().Get(index);
}
inline ::operations_research::sat::RoutesConstraintProto_NodeExpressions* PROTOBUF_NONNULL RoutesConstraintProto::add_dimensions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::RoutesConstraintProto_NodeExpressions* _add =
      _internal_mutable_dimensions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_add:operations_research.sat.RoutesConstraintProto.dimensions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>& RoutesConstraintProto::dimensions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.RoutesConstraintProto.dimensions)
  return _internal_dimensions();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>&
RoutesConstraintProto::_internal_dimensions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dimensions_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::RoutesConstraintProto_NodeExpressions>* PROTOBUF_NONNULL
RoutesConstraintProto::_internal_mutable_dimensions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dimensions_;
}

// -------------------------------------------------------------------

// TableConstraintProto

// repeated int32 vars = 1;
inline int TableConstraintProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int TableConstraintProto::vars_size() const {
  return _internal_vars_size();
}
inline void TableConstraintProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t TableConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.vars)
  return _internal_vars().Get(index);
}
inline void TableConstraintProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.vars)
}
inline void TableConstraintProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.TableConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TableConstraintProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.TableConstraintProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL TableConstraintProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.TableConstraintProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
TableConstraintProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
TableConstraintProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated int64 values = 2;
inline int TableConstraintProto::_internal_values_size() const {
  return _internal_values().size();
}
inline int TableConstraintProto::values_size() const {
  return _internal_values_size();
}
inline void TableConstraintProto::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t TableConstraintProto::values(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.values)
  return _internal_values().Get(index);
}
inline void TableConstraintProto::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.values)
}
inline void TableConstraintProto::add_values(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.TableConstraintProto.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TableConstraintProto::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.TableConstraintProto.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL TableConstraintProto::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.TableConstraintProto.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
TableConstraintProto::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
TableConstraintProto::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// repeated .operations_research.sat.LinearExpressionProto exprs = 4;
inline int TableConstraintProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int TableConstraintProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void TableConstraintProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL TableConstraintProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.TableConstraintProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL TableConstraintProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.TableConstraintProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& TableConstraintProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL TableConstraintProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.TableConstraintProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& TableConstraintProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.TableConstraintProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
TableConstraintProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
TableConstraintProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// bool negated = 3;
inline void TableConstraintProto::clear_negated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negated_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool TableConstraintProto::negated() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.TableConstraintProto.negated)
  return _internal_negated();
}
inline void TableConstraintProto::set_negated(bool value) {
  _internal_set_negated(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:operations_research.sat.TableConstraintProto.negated)
}
inline bool TableConstraintProto::_internal_negated() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.negated_;
}
inline void TableConstraintProto::_internal_set_negated(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.negated_ = value;
}

// -------------------------------------------------------------------

// InverseConstraintProto

// repeated int32 f_direct = 1;
inline int InverseConstraintProto::_internal_f_direct_size() const {
  return _internal_f_direct().size();
}
inline int InverseConstraintProto::f_direct_size() const {
  return _internal_f_direct_size();
}
inline void InverseConstraintProto::clear_f_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.f_direct_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t InverseConstraintProto::f_direct(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.InverseConstraintProto.f_direct)
  return _internal_f_direct().Get(index);
}
inline void InverseConstraintProto::set_f_direct(int index, ::int32_t value) {
  _internal_mutable_f_direct()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.InverseConstraintProto.f_direct)
}
inline void InverseConstraintProto::add_f_direct(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_f_direct()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.InverseConstraintProto.f_direct)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& InverseConstraintProto::f_direct() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.InverseConstraintProto.f_direct)
  return _internal_f_direct();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL InverseConstraintProto::mutable_f_direct()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.InverseConstraintProto.f_direct)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_f_direct();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
InverseConstraintProto::_internal_f_direct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.f_direct_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
InverseConstraintProto::_internal_mutable_f_direct() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.f_direct_;
}

// repeated int32 f_inverse = 2;
inline int InverseConstraintProto::_internal_f_inverse_size() const {
  return _internal_f_inverse().size();
}
inline int InverseConstraintProto::f_inverse_size() const {
  return _internal_f_inverse_size();
}
inline void InverseConstraintProto::clear_f_inverse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.f_inverse_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t InverseConstraintProto::f_inverse(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.InverseConstraintProto.f_inverse)
  return _internal_f_inverse().Get(index);
}
inline void InverseConstraintProto::set_f_inverse(int index, ::int32_t value) {
  _internal_mutable_f_inverse()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.InverseConstraintProto.f_inverse)
}
inline void InverseConstraintProto::add_f_inverse(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_f_inverse()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.InverseConstraintProto.f_inverse)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& InverseConstraintProto::f_inverse() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.InverseConstraintProto.f_inverse)
  return _internal_f_inverse();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL InverseConstraintProto::mutable_f_inverse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.InverseConstraintProto.f_inverse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_f_inverse();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
InverseConstraintProto::_internal_f_inverse() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.f_inverse_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
InverseConstraintProto::_internal_mutable_f_inverse() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.f_inverse_;
}

// -------------------------------------------------------------------

// AutomatonConstraintProto

// int64 starting_state = 2;
inline void AutomatonConstraintProto::clear_starting_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_state_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::int64_t AutomatonConstraintProto::starting_state() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.starting_state)
  return _internal_starting_state();
}
inline void AutomatonConstraintProto::set_starting_state(::int64_t value) {
  _internal_set_starting_state(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.starting_state)
}
inline ::int64_t AutomatonConstraintProto::_internal_starting_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.starting_state_;
}
inline void AutomatonConstraintProto::_internal_set_starting_state(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.starting_state_ = value;
}

// repeated int64 final_states = 3;
inline int AutomatonConstraintProto::_internal_final_states_size() const {
  return _internal_final_states().size();
}
inline int AutomatonConstraintProto::final_states_size() const {
  return _internal_final_states_size();
}
inline void AutomatonConstraintProto::clear_final_states() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_states_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t AutomatonConstraintProto::final_states(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.final_states)
  return _internal_final_states().Get(index);
}
inline void AutomatonConstraintProto::set_final_states(int index, ::int64_t value) {
  _internal_mutable_final_states()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.final_states)
}
inline void AutomatonConstraintProto::add_final_states(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_final_states()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.final_states)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AutomatonConstraintProto::final_states() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.final_states)
  return _internal_final_states();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_final_states()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.final_states)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_final_states();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
AutomatonConstraintProto::_internal_final_states() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_states_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_final_states() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.final_states_;
}

// repeated int64 transition_tail = 4;
inline int AutomatonConstraintProto::_internal_transition_tail_size() const {
  return _internal_transition_tail().size();
}
inline int AutomatonConstraintProto::transition_tail_size() const {
  return _internal_transition_tail_size();
}
inline void AutomatonConstraintProto::clear_transition_tail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transition_tail_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t AutomatonConstraintProto::transition_tail(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.transition_tail)
  return _internal_transition_tail().Get(index);
}
inline void AutomatonConstraintProto::set_transition_tail(int index, ::int64_t value) {
  _internal_mutable_transition_tail()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.transition_tail)
}
inline void AutomatonConstraintProto::add_transition_tail(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transition_tail()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.transition_tail)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AutomatonConstraintProto::transition_tail() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.transition_tail)
  return _internal_transition_tail();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_transition_tail()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.transition_tail)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transition_tail();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
AutomatonConstraintProto::_internal_transition_tail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transition_tail_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_transition_tail() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transition_tail_;
}

// repeated int64 transition_head = 5;
inline int AutomatonConstraintProto::_internal_transition_head_size() const {
  return _internal_transition_head().size();
}
inline int AutomatonConstraintProto::transition_head_size() const {
  return _internal_transition_head_size();
}
inline void AutomatonConstraintProto::clear_transition_head() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transition_head_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int64_t AutomatonConstraintProto::transition_head(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.transition_head)
  return _internal_transition_head().Get(index);
}
inline void AutomatonConstraintProto::set_transition_head(int index, ::int64_t value) {
  _internal_mutable_transition_head()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.transition_head)
}
inline void AutomatonConstraintProto::add_transition_head(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transition_head()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.transition_head)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AutomatonConstraintProto::transition_head() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.transition_head)
  return _internal_transition_head();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_transition_head()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.transition_head)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transition_head();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
AutomatonConstraintProto::_internal_transition_head() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transition_head_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_transition_head() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transition_head_;
}

// repeated int64 transition_label = 6;
inline int AutomatonConstraintProto::_internal_transition_label_size() const {
  return _internal_transition_label().size();
}
inline int AutomatonConstraintProto::transition_label_size() const {
  return _internal_transition_label_size();
}
inline void AutomatonConstraintProto::clear_transition_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transition_label_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int64_t AutomatonConstraintProto::transition_label(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.transition_label)
  return _internal_transition_label().Get(index);
}
inline void AutomatonConstraintProto::set_transition_label(int index, ::int64_t value) {
  _internal_mutable_transition_label()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.transition_label)
}
inline void AutomatonConstraintProto::add_transition_label(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_transition_label()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.transition_label)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AutomatonConstraintProto::transition_label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.transition_label)
  return _internal_transition_label();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_transition_label()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.transition_label)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_transition_label();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
AutomatonConstraintProto::_internal_transition_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transition_label_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_transition_label() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.transition_label_;
}

// repeated int32 vars = 7;
inline int AutomatonConstraintProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int AutomatonConstraintProto::vars_size() const {
  return _internal_vars_size();
}
inline void AutomatonConstraintProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t AutomatonConstraintProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.vars)
  return _internal_vars().Get(index);
}
inline void AutomatonConstraintProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.AutomatonConstraintProto.vars)
}
inline void AutomatonConstraintProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& AutomatonConstraintProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
AutomatonConstraintProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated .operations_research.sat.LinearExpressionProto exprs = 8;
inline int AutomatonConstraintProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int AutomatonConstraintProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void AutomatonConstraintProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.AutomatonConstraintProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL AutomatonConstraintProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.AutomatonConstraintProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& AutomatonConstraintProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.AutomatonConstraintProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL AutomatonConstraintProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_add:operations_research.sat.AutomatonConstraintProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& AutomatonConstraintProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.AutomatonConstraintProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
AutomatonConstraintProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
AutomatonConstraintProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// -------------------------------------------------------------------

// ListOfVariablesProto

// repeated int32 vars = 1;
inline int ListOfVariablesProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int ListOfVariablesProto::vars_size() const {
  return _internal_vars_size();
}
inline void ListOfVariablesProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t ListOfVariablesProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ListOfVariablesProto.vars)
  return _internal_vars().Get(index);
}
inline void ListOfVariablesProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ListOfVariablesProto.vars)
}
inline void ListOfVariablesProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ListOfVariablesProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ListOfVariablesProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ListOfVariablesProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL ListOfVariablesProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ListOfVariablesProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ListOfVariablesProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
ListOfVariablesProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// -------------------------------------------------------------------

// ConstraintProto

// string name = 1;
inline void ConstraintProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::std::string& ConstraintProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ConstraintProto::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.ConstraintProto.name)
}
inline ::std::string* PROTOBUF_NONNULL ConstraintProto::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.name)
  return _s;
}
inline const ::std::string& ConstraintProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ConstraintProto::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ConstraintProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000002U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ConstraintProto::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.name)
}

// repeated int32 enforcement_literal = 2;
inline int ConstraintProto::_internal_enforcement_literal_size() const {
  return _internal_enforcement_literal().size();
}
inline int ConstraintProto::enforcement_literal_size() const {
  return _internal_enforcement_literal_size();
}
inline void ConstraintProto::clear_enforcement_literal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enforcement_literal_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t ConstraintProto::enforcement_literal(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.enforcement_literal)
  return _internal_enforcement_literal().Get(index);
}
inline void ConstraintProto::set_enforcement_literal(int index, ::int32_t value) {
  _internal_mutable_enforcement_literal()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.ConstraintProto.enforcement_literal)
}
inline void ConstraintProto::add_enforcement_literal(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_enforcement_literal()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.ConstraintProto.enforcement_literal)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ConstraintProto::enforcement_literal() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.ConstraintProto.enforcement_literal)
  return _internal_enforcement_literal();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL ConstraintProto::mutable_enforcement_literal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.ConstraintProto.enforcement_literal)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_enforcement_literal();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ConstraintProto::_internal_enforcement_literal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enforcement_literal_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
ConstraintProto::_internal_mutable_enforcement_literal() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.enforcement_literal_;
}

// .operations_research.sat.BoolArgumentProto bool_or = 3;
inline bool ConstraintProto::has_bool_or() const {
  return constraint_case() == kBoolOr;
}
inline bool ConstraintProto::_internal_has_bool_or() const {
  return constraint_case() == kBoolOr;
}
inline void ConstraintProto::set_has_bool_or() {
  _impl_._oneof_case_[0] = kBoolOr;
}
inline void ConstraintProto::clear_bool_or() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kBoolOr) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.bool_or_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_or_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_bool_or() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_or)
  if (constraint_case() == kBoolOr) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_or_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.bool_or_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::_internal_bool_or() const {
  return constraint_case() == kBoolOr ? static_cast<const ::operations_research::sat::BoolArgumentProto&>(*reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_or_))
                     : reinterpret_cast<const ::operations_research::sat::BoolArgumentProto&>(::operations_research::sat::_BoolArgumentProto_default_instance_);
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_or() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_or)
  return _internal_bool_or();
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_bool_or() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.bool_or)
  if (constraint_case() == kBoolOr) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_or_);
    _impl_.constraint_.bool_or_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_bool_or(
    ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_bool_or();
    _impl_.constraint_.bool_or_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.bool_or)
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_bool_or() {
  if (constraint_case() != kBoolOr) {
    clear_constraint();
    set_has_bool_or();
    _impl_.constraint_.bool_or_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::BoolArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_or_);
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_bool_or()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::BoolArgumentProto* _msg = _internal_mutable_bool_or();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_or)
  return _msg;
}

// .operations_research.sat.BoolArgumentProto bool_and = 4;
inline bool ConstraintProto::has_bool_and() const {
  return constraint_case() == kBoolAnd;
}
inline bool ConstraintProto::_internal_has_bool_and() const {
  return constraint_case() == kBoolAnd;
}
inline void ConstraintProto::set_has_bool_and() {
  _impl_._oneof_case_[0] = kBoolAnd;
}
inline void ConstraintProto::clear_bool_and() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kBoolAnd) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.bool_and_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_and_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_bool_and() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_and)
  if (constraint_case() == kBoolAnd) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_and_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.bool_and_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::_internal_bool_and() const {
  return constraint_case() == kBoolAnd ? static_cast<const ::operations_research::sat::BoolArgumentProto&>(*reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_and_))
                     : reinterpret_cast<const ::operations_research::sat::BoolArgumentProto&>(::operations_research::sat::_BoolArgumentProto_default_instance_);
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_and() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_and)
  return _internal_bool_and();
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_bool_and() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.bool_and)
  if (constraint_case() == kBoolAnd) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_and_);
    _impl_.constraint_.bool_and_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_bool_and(
    ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_bool_and();
    _impl_.constraint_.bool_and_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.bool_and)
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_bool_and() {
  if (constraint_case() != kBoolAnd) {
    clear_constraint();
    set_has_bool_and();
    _impl_.constraint_.bool_and_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::BoolArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_and_);
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_bool_and()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::BoolArgumentProto* _msg = _internal_mutable_bool_and();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_and)
  return _msg;
}

// .operations_research.sat.BoolArgumentProto at_most_one = 26;
inline bool ConstraintProto::has_at_most_one() const {
  return constraint_case() == kAtMostOne;
}
inline bool ConstraintProto::_internal_has_at_most_one() const {
  return constraint_case() == kAtMostOne;
}
inline void ConstraintProto::set_has_at_most_one() {
  _impl_._oneof_case_[0] = kAtMostOne;
}
inline void ConstraintProto::clear_at_most_one() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kAtMostOne) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.at_most_one_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.at_most_one_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_at_most_one() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.at_most_one)
  if (constraint_case() == kAtMostOne) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.at_most_one_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.at_most_one_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::_internal_at_most_one() const {
  return constraint_case() == kAtMostOne ? static_cast<const ::operations_research::sat::BoolArgumentProto&>(*reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.at_most_one_))
                     : reinterpret_cast<const ::operations_research::sat::BoolArgumentProto&>(::operations_research::sat::_BoolArgumentProto_default_instance_);
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::at_most_one() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.at_most_one)
  return _internal_at_most_one();
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_at_most_one() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.at_most_one)
  if (constraint_case() == kAtMostOne) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.at_most_one_);
    _impl_.constraint_.at_most_one_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_at_most_one(
    ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_at_most_one();
    _impl_.constraint_.at_most_one_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.at_most_one)
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_at_most_one() {
  if (constraint_case() != kAtMostOne) {
    clear_constraint();
    set_has_at_most_one();
    _impl_.constraint_.at_most_one_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::BoolArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.at_most_one_);
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_at_most_one()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::BoolArgumentProto* _msg = _internal_mutable_at_most_one();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.at_most_one)
  return _msg;
}

// .operations_research.sat.BoolArgumentProto exactly_one = 29;
inline bool ConstraintProto::has_exactly_one() const {
  return constraint_case() == kExactlyOne;
}
inline bool ConstraintProto::_internal_has_exactly_one() const {
  return constraint_case() == kExactlyOne;
}
inline void ConstraintProto::set_has_exactly_one() {
  _impl_._oneof_case_[0] = kExactlyOne;
}
inline void ConstraintProto::clear_exactly_one() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kExactlyOne) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.exactly_one_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.exactly_one_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_exactly_one() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.exactly_one)
  if (constraint_case() == kExactlyOne) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.exactly_one_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.exactly_one_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::_internal_exactly_one() const {
  return constraint_case() == kExactlyOne ? static_cast<const ::operations_research::sat::BoolArgumentProto&>(*reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.exactly_one_))
                     : reinterpret_cast<const ::operations_research::sat::BoolArgumentProto&>(::operations_research::sat::_BoolArgumentProto_default_instance_);
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::exactly_one() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.exactly_one)
  return _internal_exactly_one();
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_exactly_one() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.exactly_one)
  if (constraint_case() == kExactlyOne) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.exactly_one_);
    _impl_.constraint_.exactly_one_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_exactly_one(
    ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_exactly_one();
    _impl_.constraint_.exactly_one_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.exactly_one)
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_exactly_one() {
  if (constraint_case() != kExactlyOne) {
    clear_constraint();
    set_has_exactly_one();
    _impl_.constraint_.exactly_one_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::BoolArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.exactly_one_);
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_exactly_one()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::BoolArgumentProto* _msg = _internal_mutable_exactly_one();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.exactly_one)
  return _msg;
}

// .operations_research.sat.BoolArgumentProto bool_xor = 5;
inline bool ConstraintProto::has_bool_xor() const {
  return constraint_case() == kBoolXor;
}
inline bool ConstraintProto::_internal_has_bool_xor() const {
  return constraint_case() == kBoolXor;
}
inline void ConstraintProto::set_has_bool_xor() {
  _impl_._oneof_case_[0] = kBoolXor;
}
inline void ConstraintProto::clear_bool_xor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kBoolXor) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.bool_xor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_xor_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_bool_xor() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.bool_xor)
  if (constraint_case() == kBoolXor) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_xor_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.bool_xor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::_internal_bool_xor() const {
  return constraint_case() == kBoolXor ? static_cast<const ::operations_research::sat::BoolArgumentProto&>(*reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_xor_))
                     : reinterpret_cast<const ::operations_research::sat::BoolArgumentProto&>(::operations_research::sat::_BoolArgumentProto_default_instance_);
}
inline const ::operations_research::sat::BoolArgumentProto& ConstraintProto::bool_xor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.bool_xor)
  return _internal_bool_xor();
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_bool_xor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.bool_xor)
  if (constraint_case() == kBoolXor) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_xor_);
    _impl_.constraint_.bool_xor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_bool_xor(
    ::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_bool_xor();
    _impl_.constraint_.bool_xor_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.bool_xor)
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_bool_xor() {
  if (constraint_case() != kBoolXor) {
    clear_constraint();
    set_has_bool_xor();
    _impl_.constraint_.bool_xor_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::BoolArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::BoolArgumentProto*>(_impl_.constraint_.bool_xor_);
}
inline ::operations_research::sat::BoolArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_bool_xor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::BoolArgumentProto* _msg = _internal_mutable_bool_xor();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.bool_xor)
  return _msg;
}

// .operations_research.sat.LinearArgumentProto int_div = 7;
inline bool ConstraintProto::has_int_div() const {
  return constraint_case() == kIntDiv;
}
inline bool ConstraintProto::_internal_has_int_div() const {
  return constraint_case() == kIntDiv;
}
inline void ConstraintProto::set_has_int_div() {
  _impl_._oneof_case_[0] = kIntDiv;
}
inline void ConstraintProto::clear_int_div() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kIntDiv) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.int_div_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_div_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_int_div() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_div)
  if (constraint_case() == kIntDiv) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_div_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.int_div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::_internal_int_div() const {
  return constraint_case() == kIntDiv ? static_cast<const ::operations_research::sat::LinearArgumentProto&>(*reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_div_))
                     : reinterpret_cast<const ::operations_research::sat::LinearArgumentProto&>(::operations_research::sat::_LinearArgumentProto_default_instance_);
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::int_div() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_div)
  return _internal_int_div();
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_int_div() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.int_div)
  if (constraint_case() == kIntDiv) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_div_);
    _impl_.constraint_.int_div_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_int_div(
    ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_int_div();
    _impl_.constraint_.int_div_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.int_div)
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_int_div() {
  if (constraint_case() != kIntDiv) {
    clear_constraint();
    set_has_int_div();
    _impl_.constraint_.int_div_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_div_);
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_int_div()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::LinearArgumentProto* _msg = _internal_mutable_int_div();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_div)
  return _msg;
}

// .operations_research.sat.LinearArgumentProto int_mod = 8;
inline bool ConstraintProto::has_int_mod() const {
  return constraint_case() == kIntMod;
}
inline bool ConstraintProto::_internal_has_int_mod() const {
  return constraint_case() == kIntMod;
}
inline void ConstraintProto::set_has_int_mod() {
  _impl_._oneof_case_[0] = kIntMod;
}
inline void ConstraintProto::clear_int_mod() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kIntMod) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.int_mod_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_mod_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_int_mod() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_mod)
  if (constraint_case() == kIntMod) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_mod_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.int_mod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::_internal_int_mod() const {
  return constraint_case() == kIntMod ? static_cast<const ::operations_research::sat::LinearArgumentProto&>(*reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_mod_))
                     : reinterpret_cast<const ::operations_research::sat::LinearArgumentProto&>(::operations_research::sat::_LinearArgumentProto_default_instance_);
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::int_mod() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_mod)
  return _internal_int_mod();
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_int_mod() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.int_mod)
  if (constraint_case() == kIntMod) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_mod_);
    _impl_.constraint_.int_mod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_int_mod(
    ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_int_mod();
    _impl_.constraint_.int_mod_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.int_mod)
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_int_mod() {
  if (constraint_case() != kIntMod) {
    clear_constraint();
    set_has_int_mod();
    _impl_.constraint_.int_mod_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_mod_);
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_int_mod()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::LinearArgumentProto* _msg = _internal_mutable_int_mod();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_mod)
  return _msg;
}

// .operations_research.sat.LinearArgumentProto int_prod = 11;
inline bool ConstraintProto::has_int_prod() const {
  return constraint_case() == kIntProd;
}
inline bool ConstraintProto::_internal_has_int_prod() const {
  return constraint_case() == kIntProd;
}
inline void ConstraintProto::set_has_int_prod() {
  _impl_._oneof_case_[0] = kIntProd;
}
inline void ConstraintProto::clear_int_prod() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kIntProd) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.int_prod_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_prod_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_int_prod() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.int_prod)
  if (constraint_case() == kIntProd) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_prod_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.int_prod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::_internal_int_prod() const {
  return constraint_case() == kIntProd ? static_cast<const ::operations_research::sat::LinearArgumentProto&>(*reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_prod_))
                     : reinterpret_cast<const ::operations_research::sat::LinearArgumentProto&>(::operations_research::sat::_LinearArgumentProto_default_instance_);
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::int_prod() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.int_prod)
  return _internal_int_prod();
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_int_prod() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.int_prod)
  if (constraint_case() == kIntProd) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_prod_);
    _impl_.constraint_.int_prod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_int_prod(
    ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_int_prod();
    _impl_.constraint_.int_prod_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.int_prod)
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_int_prod() {
  if (constraint_case() != kIntProd) {
    clear_constraint();
    set_has_int_prod();
    _impl_.constraint_.int_prod_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.int_prod_);
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_int_prod()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::LinearArgumentProto* _msg = _internal_mutable_int_prod();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.int_prod)
  return _msg;
}

// .operations_research.sat.LinearArgumentProto lin_max = 27;
inline bool ConstraintProto::has_lin_max() const {
  return constraint_case() == kLinMax;
}
inline bool ConstraintProto::_internal_has_lin_max() const {
  return constraint_case() == kLinMax;
}
inline void ConstraintProto::set_has_lin_max() {
  _impl_._oneof_case_[0] = kLinMax;
}
inline void ConstraintProto::clear_lin_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kLinMax) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.lin_max_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.lin_max_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::release_lin_max() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.lin_max)
  if (constraint_case() == kLinMax) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.lin_max_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.lin_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::_internal_lin_max() const {
  return constraint_case() == kLinMax ? static_cast<const ::operations_research::sat::LinearArgumentProto&>(*reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.lin_max_))
                     : reinterpret_cast<const ::operations_research::sat::LinearArgumentProto&>(::operations_research::sat::_LinearArgumentProto_default_instance_);
}
inline const ::operations_research::sat::LinearArgumentProto& ConstraintProto::lin_max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.lin_max)
  return _internal_lin_max();
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_lin_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.lin_max)
  if (constraint_case() == kLinMax) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.lin_max_);
    _impl_.constraint_.lin_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_lin_max(
    ::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_lin_max();
    _impl_.constraint_.lin_max_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.lin_max)
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_lin_max() {
  if (constraint_case() != kLinMax) {
    clear_constraint();
    set_has_lin_max();
    _impl_.constraint_.lin_max_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearArgumentProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::LinearArgumentProto*>(_impl_.constraint_.lin_max_);
}
inline ::operations_research::sat::LinearArgumentProto* PROTOBUF_NONNULL ConstraintProto::mutable_lin_max()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::LinearArgumentProto* _msg = _internal_mutable_lin_max();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.lin_max)
  return _msg;
}

// .operations_research.sat.LinearConstraintProto linear = 12;
inline bool ConstraintProto::has_linear() const {
  return constraint_case() == kLinear;
}
inline bool ConstraintProto::_internal_has_linear() const {
  return constraint_case() == kLinear;
}
inline void ConstraintProto::set_has_linear() {
  _impl_._oneof_case_[0] = kLinear;
}
inline void ConstraintProto::clear_linear() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kLinear) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.linear_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.linear_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_linear() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.linear)
  if (constraint_case() == kLinear) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearConstraintProto*>(_impl_.constraint_.linear_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::LinearConstraintProto& ConstraintProto::_internal_linear() const {
  return constraint_case() == kLinear ? static_cast<const ::operations_research::sat::LinearConstraintProto&>(*reinterpret_cast<::operations_research::sat::LinearConstraintProto*>(_impl_.constraint_.linear_))
                     : reinterpret_cast<const ::operations_research::sat::LinearConstraintProto&>(::operations_research::sat::_LinearConstraintProto_default_instance_);
}
inline const ::operations_research::sat::LinearConstraintProto& ConstraintProto::linear() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.linear)
  return _internal_linear();
}
inline ::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.linear)
  if (constraint_case() == kLinear) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::LinearConstraintProto*>(_impl_.constraint_.linear_);
    _impl_.constraint_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_linear(
    ::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_linear();
    _impl_.constraint_.linear_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.linear)
}
inline ::operations_research::sat::LinearConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_linear() {
  if (constraint_case() != kLinear) {
    clear_constraint();
    set_has_linear();
    _impl_.constraint_.linear_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::LinearConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::LinearConstraintProto*>(_impl_.constraint_.linear_);
}
inline ::operations_research::sat::LinearConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_linear()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::LinearConstraintProto* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.linear)
  return _msg;
}

// .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
inline bool ConstraintProto::has_all_diff() const {
  return constraint_case() == kAllDiff;
}
inline bool ConstraintProto::_internal_has_all_diff() const {
  return constraint_case() == kAllDiff;
}
inline void ConstraintProto::set_has_all_diff() {
  _impl_._oneof_case_[0] = kAllDiff;
}
inline void ConstraintProto::clear_all_diff() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kAllDiff) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.all_diff_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.all_diff_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_all_diff() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.all_diff)
  if (constraint_case() == kAllDiff) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::AllDifferentConstraintProto*>(_impl_.constraint_.all_diff_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.all_diff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::AllDifferentConstraintProto& ConstraintProto::_internal_all_diff() const {
  return constraint_case() == kAllDiff ? static_cast<const ::operations_research::sat::AllDifferentConstraintProto&>(*reinterpret_cast<::operations_research::sat::AllDifferentConstraintProto*>(_impl_.constraint_.all_diff_))
                     : reinterpret_cast<const ::operations_research::sat::AllDifferentConstraintProto&>(::operations_research::sat::_AllDifferentConstraintProto_default_instance_);
}
inline const ::operations_research::sat::AllDifferentConstraintProto& ConstraintProto::all_diff() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.all_diff)
  return _internal_all_diff();
}
inline ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_all_diff() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.all_diff)
  if (constraint_case() == kAllDiff) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::AllDifferentConstraintProto*>(_impl_.constraint_.all_diff_);
    _impl_.constraint_.all_diff_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_all_diff(
    ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_all_diff();
    _impl_.constraint_.all_diff_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.all_diff)
}
inline ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_all_diff() {
  if (constraint_case() != kAllDiff) {
    clear_constraint();
    set_has_all_diff();
    _impl_.constraint_.all_diff_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::AllDifferentConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::AllDifferentConstraintProto*>(_impl_.constraint_.all_diff_);
}
inline ::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_all_diff()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::AllDifferentConstraintProto* _msg = _internal_mutable_all_diff();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.all_diff)
  return _msg;
}

// .operations_research.sat.ElementConstraintProto element = 14;
inline bool ConstraintProto::has_element() const {
  return constraint_case() == kElement;
}
inline bool ConstraintProto::_internal_has_element() const {
  return constraint_case() == kElement;
}
inline void ConstraintProto::set_has_element() {
  _impl_._oneof_case_[0] = kElement;
}
inline void ConstraintProto::clear_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kElement) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.element_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.element_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_element() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.element)
  if (constraint_case() == kElement) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ElementConstraintProto*>(_impl_.constraint_.element_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::ElementConstraintProto& ConstraintProto::_internal_element() const {
  return constraint_case() == kElement ? static_cast<const ::operations_research::sat::ElementConstraintProto&>(*reinterpret_cast<::operations_research::sat::ElementConstraintProto*>(_impl_.constraint_.element_))
                     : reinterpret_cast<const ::operations_research::sat::ElementConstraintProto&>(::operations_research::sat::_ElementConstraintProto_default_instance_);
}
inline const ::operations_research::sat::ElementConstraintProto& ConstraintProto::element() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.element)
  return _internal_element();
}
inline ::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.element)
  if (constraint_case() == kElement) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ElementConstraintProto*>(_impl_.constraint_.element_);
    _impl_.constraint_.element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_element(
    ::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_element();
    _impl_.constraint_.element_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.element)
}
inline ::operations_research::sat::ElementConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_element() {
  if (constraint_case() != kElement) {
    clear_constraint();
    set_has_element();
    _impl_.constraint_.element_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::ElementConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::ElementConstraintProto*>(_impl_.constraint_.element_);
}
inline ::operations_research::sat::ElementConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_element()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::ElementConstraintProto* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.element)
  return _msg;
}

// .operations_research.sat.CircuitConstraintProto circuit = 15;
inline bool ConstraintProto::has_circuit() const {
  return constraint_case() == kCircuit;
}
inline bool ConstraintProto::_internal_has_circuit() const {
  return constraint_case() == kCircuit;
}
inline void ConstraintProto::set_has_circuit() {
  _impl_._oneof_case_[0] = kCircuit;
}
inline void ConstraintProto::clear_circuit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kCircuit) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.circuit_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.circuit_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_circuit() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.circuit)
  if (constraint_case() == kCircuit) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::CircuitConstraintProto*>(_impl_.constraint_.circuit_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.circuit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::CircuitConstraintProto& ConstraintProto::_internal_circuit() const {
  return constraint_case() == kCircuit ? static_cast<const ::operations_research::sat::CircuitConstraintProto&>(*reinterpret_cast<::operations_research::sat::CircuitConstraintProto*>(_impl_.constraint_.circuit_))
                     : reinterpret_cast<const ::operations_research::sat::CircuitConstraintProto&>(::operations_research::sat::_CircuitConstraintProto_default_instance_);
}
inline const ::operations_research::sat::CircuitConstraintProto& ConstraintProto::circuit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.circuit)
  return _internal_circuit();
}
inline ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_circuit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.circuit)
  if (constraint_case() == kCircuit) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::CircuitConstraintProto*>(_impl_.constraint_.circuit_);
    _impl_.constraint_.circuit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_circuit(
    ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_circuit();
    _impl_.constraint_.circuit_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.circuit)
}
inline ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_circuit() {
  if (constraint_case() != kCircuit) {
    clear_constraint();
    set_has_circuit();
    _impl_.constraint_.circuit_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::CircuitConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::CircuitConstraintProto*>(_impl_.constraint_.circuit_);
}
inline ::operations_research::sat::CircuitConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_circuit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::CircuitConstraintProto* _msg = _internal_mutable_circuit();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.circuit)
  return _msg;
}

// .operations_research.sat.RoutesConstraintProto routes = 23;
inline bool ConstraintProto::has_routes() const {
  return constraint_case() == kRoutes;
}
inline bool ConstraintProto::_internal_has_routes() const {
  return constraint_case() == kRoutes;
}
inline void ConstraintProto::set_has_routes() {
  _impl_._oneof_case_[0] = kRoutes;
}
inline void ConstraintProto::clear_routes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kRoutes) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.routes_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.routes_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_routes() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.routes)
  if (constraint_case() == kRoutes) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::RoutesConstraintProto*>(_impl_.constraint_.routes_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.routes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::RoutesConstraintProto& ConstraintProto::_internal_routes() const {
  return constraint_case() == kRoutes ? static_cast<const ::operations_research::sat::RoutesConstraintProto&>(*reinterpret_cast<::operations_research::sat::RoutesConstraintProto*>(_impl_.constraint_.routes_))
                     : reinterpret_cast<const ::operations_research::sat::RoutesConstraintProto&>(::operations_research::sat::_RoutesConstraintProto_default_instance_);
}
inline const ::operations_research::sat::RoutesConstraintProto& ConstraintProto::routes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.routes)
  return _internal_routes();
}
inline ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_routes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.routes)
  if (constraint_case() == kRoutes) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::RoutesConstraintProto*>(_impl_.constraint_.routes_);
    _impl_.constraint_.routes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_routes(
    ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_routes();
    _impl_.constraint_.routes_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.routes)
}
inline ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_routes() {
  if (constraint_case() != kRoutes) {
    clear_constraint();
    set_has_routes();
    _impl_.constraint_.routes_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::RoutesConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::RoutesConstraintProto*>(_impl_.constraint_.routes_);
}
inline ::operations_research::sat::RoutesConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_routes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::RoutesConstraintProto* _msg = _internal_mutable_routes();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.routes)
  return _msg;
}

// .operations_research.sat.TableConstraintProto table = 16;
inline bool ConstraintProto::has_table() const {
  return constraint_case() == kTable;
}
inline bool ConstraintProto::_internal_has_table() const {
  return constraint_case() == kTable;
}
inline void ConstraintProto::set_has_table() {
  _impl_._oneof_case_[0] = kTable;
}
inline void ConstraintProto::clear_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kTable) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.table_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_table() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.table)
  if (constraint_case() == kTable) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::TableConstraintProto*>(_impl_.constraint_.table_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::TableConstraintProto& ConstraintProto::_internal_table() const {
  return constraint_case() == kTable ? static_cast<const ::operations_research::sat::TableConstraintProto&>(*reinterpret_cast<::operations_research::sat::TableConstraintProto*>(_impl_.constraint_.table_))
                     : reinterpret_cast<const ::operations_research::sat::TableConstraintProto&>(::operations_research::sat::_TableConstraintProto_default_instance_);
}
inline const ::operations_research::sat::TableConstraintProto& ConstraintProto::table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.table)
  return _internal_table();
}
inline ::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.table)
  if (constraint_case() == kTable) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::TableConstraintProto*>(_impl_.constraint_.table_);
    _impl_.constraint_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_table(
    ::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_table();
    _impl_.constraint_.table_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.table)
}
inline ::operations_research::sat::TableConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_table() {
  if (constraint_case() != kTable) {
    clear_constraint();
    set_has_table();
    _impl_.constraint_.table_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::TableConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::TableConstraintProto*>(_impl_.constraint_.table_);
}
inline ::operations_research::sat::TableConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_table()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::TableConstraintProto* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.table)
  return _msg;
}

// .operations_research.sat.AutomatonConstraintProto automaton = 17;
inline bool ConstraintProto::has_automaton() const {
  return constraint_case() == kAutomaton;
}
inline bool ConstraintProto::_internal_has_automaton() const {
  return constraint_case() == kAutomaton;
}
inline void ConstraintProto::set_has_automaton() {
  _impl_._oneof_case_[0] = kAutomaton;
}
inline void ConstraintProto::clear_automaton() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kAutomaton) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.automaton_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.automaton_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_automaton() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.automaton)
  if (constraint_case() == kAutomaton) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::AutomatonConstraintProto*>(_impl_.constraint_.automaton_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.automaton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::AutomatonConstraintProto& ConstraintProto::_internal_automaton() const {
  return constraint_case() == kAutomaton ? static_cast<const ::operations_research::sat::AutomatonConstraintProto&>(*reinterpret_cast<::operations_research::sat::AutomatonConstraintProto*>(_impl_.constraint_.automaton_))
                     : reinterpret_cast<const ::operations_research::sat::AutomatonConstraintProto&>(::operations_research::sat::_AutomatonConstraintProto_default_instance_);
}
inline const ::operations_research::sat::AutomatonConstraintProto& ConstraintProto::automaton() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.automaton)
  return _internal_automaton();
}
inline ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_automaton() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.automaton)
  if (constraint_case() == kAutomaton) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::AutomatonConstraintProto*>(_impl_.constraint_.automaton_);
    _impl_.constraint_.automaton_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_automaton(
    ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_automaton();
    _impl_.constraint_.automaton_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.automaton)
}
inline ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_automaton() {
  if (constraint_case() != kAutomaton) {
    clear_constraint();
    set_has_automaton();
    _impl_.constraint_.automaton_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::AutomatonConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::AutomatonConstraintProto*>(_impl_.constraint_.automaton_);
}
inline ::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_automaton()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::AutomatonConstraintProto* _msg = _internal_mutable_automaton();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.automaton)
  return _msg;
}

// .operations_research.sat.InverseConstraintProto inverse = 18;
inline bool ConstraintProto::has_inverse() const {
  return constraint_case() == kInverse;
}
inline bool ConstraintProto::_internal_has_inverse() const {
  return constraint_case() == kInverse;
}
inline void ConstraintProto::set_has_inverse() {
  _impl_._oneof_case_[0] = kInverse;
}
inline void ConstraintProto::clear_inverse() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kInverse) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.inverse_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.inverse_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_inverse() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.inverse)
  if (constraint_case() == kInverse) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::InverseConstraintProto*>(_impl_.constraint_.inverse_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.inverse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::InverseConstraintProto& ConstraintProto::_internal_inverse() const {
  return constraint_case() == kInverse ? static_cast<const ::operations_research::sat::InverseConstraintProto&>(*reinterpret_cast<::operations_research::sat::InverseConstraintProto*>(_impl_.constraint_.inverse_))
                     : reinterpret_cast<const ::operations_research::sat::InverseConstraintProto&>(::operations_research::sat::_InverseConstraintProto_default_instance_);
}
inline const ::operations_research::sat::InverseConstraintProto& ConstraintProto::inverse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.inverse)
  return _internal_inverse();
}
inline ::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_inverse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.inverse)
  if (constraint_case() == kInverse) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::InverseConstraintProto*>(_impl_.constraint_.inverse_);
    _impl_.constraint_.inverse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_inverse(
    ::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_inverse();
    _impl_.constraint_.inverse_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.inverse)
}
inline ::operations_research::sat::InverseConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_inverse() {
  if (constraint_case() != kInverse) {
    clear_constraint();
    set_has_inverse();
    _impl_.constraint_.inverse_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::InverseConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::InverseConstraintProto*>(_impl_.constraint_.inverse_);
}
inline ::operations_research::sat::InverseConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_inverse()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::InverseConstraintProto* _msg = _internal_mutable_inverse();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.inverse)
  return _msg;
}

// .operations_research.sat.ReservoirConstraintProto reservoir = 24;
inline bool ConstraintProto::has_reservoir() const {
  return constraint_case() == kReservoir;
}
inline bool ConstraintProto::_internal_has_reservoir() const {
  return constraint_case() == kReservoir;
}
inline void ConstraintProto::set_has_reservoir() {
  _impl_._oneof_case_[0] = kReservoir;
}
inline void ConstraintProto::clear_reservoir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kReservoir) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.reservoir_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.reservoir_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_reservoir() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.reservoir)
  if (constraint_case() == kReservoir) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ReservoirConstraintProto*>(_impl_.constraint_.reservoir_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.reservoir_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::ReservoirConstraintProto& ConstraintProto::_internal_reservoir() const {
  return constraint_case() == kReservoir ? static_cast<const ::operations_research::sat::ReservoirConstraintProto&>(*reinterpret_cast<::operations_research::sat::ReservoirConstraintProto*>(_impl_.constraint_.reservoir_))
                     : reinterpret_cast<const ::operations_research::sat::ReservoirConstraintProto&>(::operations_research::sat::_ReservoirConstraintProto_default_instance_);
}
inline const ::operations_research::sat::ReservoirConstraintProto& ConstraintProto::reservoir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.reservoir)
  return _internal_reservoir();
}
inline ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_reservoir() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.reservoir)
  if (constraint_case() == kReservoir) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ReservoirConstraintProto*>(_impl_.constraint_.reservoir_);
    _impl_.constraint_.reservoir_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_reservoir(
    ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_reservoir();
    _impl_.constraint_.reservoir_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.reservoir)
}
inline ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_reservoir() {
  if (constraint_case() != kReservoir) {
    clear_constraint();
    set_has_reservoir();
    _impl_.constraint_.reservoir_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::ReservoirConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::ReservoirConstraintProto*>(_impl_.constraint_.reservoir_);
}
inline ::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_reservoir()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::ReservoirConstraintProto* _msg = _internal_mutable_reservoir();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.reservoir)
  return _msg;
}

// .operations_research.sat.IntervalConstraintProto interval = 19;
inline bool ConstraintProto::has_interval() const {
  return constraint_case() == kInterval;
}
inline bool ConstraintProto::_internal_has_interval() const {
  return constraint_case() == kInterval;
}
inline void ConstraintProto::set_has_interval() {
  _impl_._oneof_case_[0] = kInterval;
}
inline void ConstraintProto::clear_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kInterval) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.interval_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.interval_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_interval() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.interval)
  if (constraint_case() == kInterval) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::IntervalConstraintProto*>(_impl_.constraint_.interval_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::IntervalConstraintProto& ConstraintProto::_internal_interval() const {
  return constraint_case() == kInterval ? static_cast<const ::operations_research::sat::IntervalConstraintProto&>(*reinterpret_cast<::operations_research::sat::IntervalConstraintProto*>(_impl_.constraint_.interval_))
                     : reinterpret_cast<const ::operations_research::sat::IntervalConstraintProto&>(::operations_research::sat::_IntervalConstraintProto_default_instance_);
}
inline const ::operations_research::sat::IntervalConstraintProto& ConstraintProto::interval() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.interval)
  return _internal_interval();
}
inline ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.interval)
  if (constraint_case() == kInterval) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::IntervalConstraintProto*>(_impl_.constraint_.interval_);
    _impl_.constraint_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_interval(
    ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_interval();
    _impl_.constraint_.interval_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.interval)
}
inline ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_interval() {
  if (constraint_case() != kInterval) {
    clear_constraint();
    set_has_interval();
    _impl_.constraint_.interval_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::IntervalConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::IntervalConstraintProto*>(_impl_.constraint_.interval_);
}
inline ::operations_research::sat::IntervalConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_interval()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::IntervalConstraintProto* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.interval)
  return _msg;
}

// .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
inline bool ConstraintProto::has_no_overlap() const {
  return constraint_case() == kNoOverlap;
}
inline bool ConstraintProto::_internal_has_no_overlap() const {
  return constraint_case() == kNoOverlap;
}
inline void ConstraintProto::set_has_no_overlap() {
  _impl_._oneof_case_[0] = kNoOverlap;
}
inline void ConstraintProto::clear_no_overlap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kNoOverlap) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.no_overlap_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.no_overlap_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_no_overlap() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.no_overlap)
  if (constraint_case() == kNoOverlap) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::NoOverlapConstraintProto*>(_impl_.constraint_.no_overlap_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.no_overlap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::NoOverlapConstraintProto& ConstraintProto::_internal_no_overlap() const {
  return constraint_case() == kNoOverlap ? static_cast<const ::operations_research::sat::NoOverlapConstraintProto&>(*reinterpret_cast<::operations_research::sat::NoOverlapConstraintProto*>(_impl_.constraint_.no_overlap_))
                     : reinterpret_cast<const ::operations_research::sat::NoOverlapConstraintProto&>(::operations_research::sat::_NoOverlapConstraintProto_default_instance_);
}
inline const ::operations_research::sat::NoOverlapConstraintProto& ConstraintProto::no_overlap() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.no_overlap)
  return _internal_no_overlap();
}
inline ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_no_overlap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.no_overlap)
  if (constraint_case() == kNoOverlap) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::NoOverlapConstraintProto*>(_impl_.constraint_.no_overlap_);
    _impl_.constraint_.no_overlap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_no_overlap(
    ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_no_overlap();
    _impl_.constraint_.no_overlap_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.no_overlap)
}
inline ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_no_overlap() {
  if (constraint_case() != kNoOverlap) {
    clear_constraint();
    set_has_no_overlap();
    _impl_.constraint_.no_overlap_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::NoOverlapConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::NoOverlapConstraintProto*>(_impl_.constraint_.no_overlap_);
}
inline ::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_no_overlap()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::NoOverlapConstraintProto* _msg = _internal_mutable_no_overlap();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.no_overlap)
  return _msg;
}

// .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
inline bool ConstraintProto::has_no_overlap_2d() const {
  return constraint_case() == kNoOverlap2D;
}
inline bool ConstraintProto::_internal_has_no_overlap_2d() const {
  return constraint_case() == kNoOverlap2D;
}
inline void ConstraintProto::set_has_no_overlap_2d() {
  _impl_._oneof_case_[0] = kNoOverlap2D;
}
inline void ConstraintProto::clear_no_overlap_2d() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kNoOverlap2D) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.no_overlap_2d_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.no_overlap_2d_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_no_overlap_2d() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.no_overlap_2d)
  if (constraint_case() == kNoOverlap2D) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::NoOverlap2DConstraintProto*>(_impl_.constraint_.no_overlap_2d_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.no_overlap_2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::NoOverlap2DConstraintProto& ConstraintProto::_internal_no_overlap_2d() const {
  return constraint_case() == kNoOverlap2D ? static_cast<const ::operations_research::sat::NoOverlap2DConstraintProto&>(*reinterpret_cast<::operations_research::sat::NoOverlap2DConstraintProto*>(_impl_.constraint_.no_overlap_2d_))
                     : reinterpret_cast<const ::operations_research::sat::NoOverlap2DConstraintProto&>(::operations_research::sat::_NoOverlap2DConstraintProto_default_instance_);
}
inline const ::operations_research::sat::NoOverlap2DConstraintProto& ConstraintProto::no_overlap_2d() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.no_overlap_2d)
  return _internal_no_overlap_2d();
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_no_overlap_2d() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.no_overlap_2d)
  if (constraint_case() == kNoOverlap2D) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::NoOverlap2DConstraintProto*>(_impl_.constraint_.no_overlap_2d_);
    _impl_.constraint_.no_overlap_2d_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_no_overlap_2d(
    ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_no_overlap_2d();
    _impl_.constraint_.no_overlap_2d_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.no_overlap_2d)
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_no_overlap_2d() {
  if (constraint_case() != kNoOverlap2D) {
    clear_constraint();
    set_has_no_overlap_2d();
    _impl_.constraint_.no_overlap_2d_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::NoOverlap2DConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::NoOverlap2DConstraintProto*>(_impl_.constraint_.no_overlap_2d_);
}
inline ::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_no_overlap_2d()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::NoOverlap2DConstraintProto* _msg = _internal_mutable_no_overlap_2d();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.no_overlap_2d)
  return _msg;
}

// .operations_research.sat.CumulativeConstraintProto cumulative = 22;
inline bool ConstraintProto::has_cumulative() const {
  return constraint_case() == kCumulative;
}
inline bool ConstraintProto::_internal_has_cumulative() const {
  return constraint_case() == kCumulative;
}
inline void ConstraintProto::set_has_cumulative() {
  _impl_._oneof_case_[0] = kCumulative;
}
inline void ConstraintProto::clear_cumulative() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kCumulative) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.cumulative_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.cumulative_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE ConstraintProto::release_cumulative() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.cumulative)
  if (constraint_case() == kCumulative) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::CumulativeConstraintProto*>(_impl_.constraint_.cumulative_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.cumulative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::CumulativeConstraintProto& ConstraintProto::_internal_cumulative() const {
  return constraint_case() == kCumulative ? static_cast<const ::operations_research::sat::CumulativeConstraintProto&>(*reinterpret_cast<::operations_research::sat::CumulativeConstraintProto*>(_impl_.constraint_.cumulative_))
                     : reinterpret_cast<const ::operations_research::sat::CumulativeConstraintProto&>(::operations_research::sat::_CumulativeConstraintProto_default_instance_);
}
inline const ::operations_research::sat::CumulativeConstraintProto& ConstraintProto::cumulative() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.cumulative)
  return _internal_cumulative();
}
inline ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_cumulative() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.cumulative)
  if (constraint_case() == kCumulative) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::CumulativeConstraintProto*>(_impl_.constraint_.cumulative_);
    _impl_.constraint_.cumulative_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_cumulative(
    ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_cumulative();
    _impl_.constraint_.cumulative_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.cumulative)
}
inline ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_cumulative() {
  if (constraint_case() != kCumulative) {
    clear_constraint();
    set_has_cumulative();
    _impl_.constraint_.cumulative_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::CumulativeConstraintProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::CumulativeConstraintProto*>(_impl_.constraint_.cumulative_);
}
inline ::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NONNULL ConstraintProto::mutable_cumulative()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::CumulativeConstraintProto* _msg = _internal_mutable_cumulative();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.cumulative)
  return _msg;
}

// .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
inline bool ConstraintProto::has_dummy_constraint() const {
  return constraint_case() == kDummyConstraint;
}
inline bool ConstraintProto::_internal_has_dummy_constraint() const {
  return constraint_case() == kDummyConstraint;
}
inline void ConstraintProto::set_has_dummy_constraint() {
  _impl_._oneof_case_[0] = kDummyConstraint;
}
inline void ConstraintProto::clear_dummy_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (constraint_case() == kDummyConstraint) {
    if (GetArena() == nullptr) {
      delete _impl_.constraint_.dummy_constraint_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.dummy_constraint_);
    }
    clear_has_constraint();
  }
}
inline ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE ConstraintProto::release_dummy_constraint() {
  // @@protoc_insertion_point(field_release:operations_research.sat.ConstraintProto.dummy_constraint)
  if (constraint_case() == kDummyConstraint) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ListOfVariablesProto*>(_impl_.constraint_.dummy_constraint_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.constraint_.dummy_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::operations_research::sat::ListOfVariablesProto& ConstraintProto::_internal_dummy_constraint() const {
  return constraint_case() == kDummyConstraint ? static_cast<const ::operations_research::sat::ListOfVariablesProto&>(*reinterpret_cast<::operations_research::sat::ListOfVariablesProto*>(_impl_.constraint_.dummy_constraint_))
                     : reinterpret_cast<const ::operations_research::sat::ListOfVariablesProto&>(::operations_research::sat::_ListOfVariablesProto_default_instance_);
}
inline const ::operations_research::sat::ListOfVariablesProto& ConstraintProto::dummy_constraint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.ConstraintProto.dummy_constraint)
  return _internal_dummy_constraint();
}
inline ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE ConstraintProto::unsafe_arena_release_dummy_constraint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:operations_research.sat.ConstraintProto.dummy_constraint)
  if (constraint_case() == kDummyConstraint) {
    clear_has_constraint();
    auto* temp = reinterpret_cast<::operations_research::sat::ListOfVariablesProto*>(_impl_.constraint_.dummy_constraint_);
    _impl_.constraint_.dummy_constraint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConstraintProto::unsafe_arena_set_allocated_dummy_constraint(
    ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_constraint();
  if (value) {
    set_has_dummy_constraint();
    _impl_.constraint_.dummy_constraint_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.ConstraintProto.dummy_constraint)
}
inline ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NONNULL ConstraintProto::_internal_mutable_dummy_constraint() {
  if (constraint_case() != kDummyConstraint) {
    clear_constraint();
    set_has_dummy_constraint();
    _impl_.constraint_.dummy_constraint_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::ListOfVariablesProto>(GetArena()));
  }
  return reinterpret_cast<::operations_research::sat::ListOfVariablesProto*>(_impl_.constraint_.dummy_constraint_);
}
inline ::operations_research::sat::ListOfVariablesProto* PROTOBUF_NONNULL ConstraintProto::mutable_dummy_constraint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::operations_research::sat::ListOfVariablesProto* _msg = _internal_mutable_dummy_constraint();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.ConstraintProto.dummy_constraint)
  return _msg;
}

inline bool ConstraintProto::has_constraint() const {
  return constraint_case() != CONSTRAINT_NOT_SET;
}
inline void ConstraintProto::clear_has_constraint() {
  _impl_._oneof_case_[0] = CONSTRAINT_NOT_SET;
}
inline ConstraintProto::ConstraintCase ConstraintProto::constraint_case() const {
  return ConstraintProto::ConstraintCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CpObjectiveProto

// repeated int32 vars = 1;
inline int CpObjectiveProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int CpObjectiveProto::vars_size() const {
  return _internal_vars_size();
}
inline void CpObjectiveProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t CpObjectiveProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.vars)
  return _internal_vars().Get(index);
}
inline void CpObjectiveProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.vars)
}
inline void CpObjectiveProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpObjectiveProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CpObjectiveProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpObjectiveProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CpObjectiveProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpObjectiveProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CpObjectiveProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CpObjectiveProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated int64 coeffs = 4;
inline int CpObjectiveProto::_internal_coeffs_size() const {
  return _internal_coeffs().size();
}
inline int CpObjectiveProto::coeffs_size() const {
  return _internal_coeffs_size();
}
inline void CpObjectiveProto::clear_coeffs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coeffs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t CpObjectiveProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.coeffs)
  return _internal_coeffs().Get(index);
}
inline void CpObjectiveProto::set_coeffs(int index, ::int64_t value) {
  _internal_mutable_coeffs()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.coeffs)
}
inline void CpObjectiveProto::add_coeffs(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_coeffs()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpObjectiveProto.coeffs)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CpObjectiveProto::coeffs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpObjectiveProto.coeffs)
  return _internal_coeffs();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL CpObjectiveProto::mutable_coeffs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpObjectiveProto.coeffs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_coeffs();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
CpObjectiveProto::_internal_coeffs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coeffs_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
CpObjectiveProto::_internal_mutable_coeffs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.coeffs_;
}

// double offset = 2;
inline void CpObjectiveProto::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline double CpObjectiveProto::offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.offset)
  return _internal_offset();
}
inline void CpObjectiveProto::set_offset(double value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.offset)
}
inline double CpObjectiveProto::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void CpObjectiveProto::_internal_set_offset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// double scaling_factor = 3;
inline void CpObjectiveProto::clear_scaling_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scaling_factor_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline double CpObjectiveProto::scaling_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.scaling_factor)
  return _internal_scaling_factor();
}
inline void CpObjectiveProto::set_scaling_factor(double value) {
  _internal_set_scaling_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.scaling_factor)
}
inline double CpObjectiveProto::_internal_scaling_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scaling_factor_;
}
inline void CpObjectiveProto::_internal_set_scaling_factor(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scaling_factor_ = value;
}

// repeated int64 domain = 5;
inline int CpObjectiveProto::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int CpObjectiveProto::domain_size() const {
  return _internal_domain_size();
}
inline void CpObjectiveProto::clear_domain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.domain_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int64_t CpObjectiveProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.domain)
  return _internal_domain().Get(index);
}
inline void CpObjectiveProto::set_domain(int index, ::int64_t value) {
  _internal_mutable_domain()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.domain)
}
inline void CpObjectiveProto::add_domain(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_domain()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpObjectiveProto.domain)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CpObjectiveProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpObjectiveProto.domain)
  return _internal_domain();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL CpObjectiveProto::mutable_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpObjectiveProto.domain)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_domain();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
CpObjectiveProto::_internal_domain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
CpObjectiveProto::_internal_mutable_domain() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.domain_;
}

// bool scaling_was_exact = 6;
inline void CpObjectiveProto::clear_scaling_was_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scaling_was_exact_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline bool CpObjectiveProto::scaling_was_exact() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.scaling_was_exact)
  return _internal_scaling_was_exact();
}
inline void CpObjectiveProto::set_scaling_was_exact(bool value) {
  _internal_set_scaling_was_exact(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.scaling_was_exact)
}
inline bool CpObjectiveProto::_internal_scaling_was_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scaling_was_exact_;
}
inline void CpObjectiveProto::_internal_set_scaling_was_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scaling_was_exact_ = value;
}

// int64 integer_before_offset = 7;
inline void CpObjectiveProto::clear_integer_before_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_before_offset_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline ::int64_t CpObjectiveProto::integer_before_offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.integer_before_offset)
  return _internal_integer_before_offset();
}
inline void CpObjectiveProto::set_integer_before_offset(::int64_t value) {
  _internal_set_integer_before_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.integer_before_offset)
}
inline ::int64_t CpObjectiveProto::_internal_integer_before_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integer_before_offset_;
}
inline void CpObjectiveProto::_internal_set_integer_before_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_before_offset_ = value;
}

// int64 integer_after_offset = 9;
inline void CpObjectiveProto::clear_integer_after_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_after_offset_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline ::int64_t CpObjectiveProto::integer_after_offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.integer_after_offset)
  return _internal_integer_after_offset();
}
inline void CpObjectiveProto::set_integer_after_offset(::int64_t value) {
  _internal_set_integer_after_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.integer_after_offset)
}
inline ::int64_t CpObjectiveProto::_internal_integer_after_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integer_after_offset_;
}
inline void CpObjectiveProto::_internal_set_integer_after_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_after_offset_ = value;
}

// int64 integer_scaling_factor = 8;
inline void CpObjectiveProto::clear_integer_scaling_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_scaling_factor_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline ::int64_t CpObjectiveProto::integer_scaling_factor() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpObjectiveProto.integer_scaling_factor)
  return _internal_integer_scaling_factor();
}
inline void CpObjectiveProto::set_integer_scaling_factor(::int64_t value) {
  _internal_set_integer_scaling_factor(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpObjectiveProto.integer_scaling_factor)
}
inline ::int64_t CpObjectiveProto::_internal_integer_scaling_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.integer_scaling_factor_;
}
inline void CpObjectiveProto::_internal_set_integer_scaling_factor(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.integer_scaling_factor_ = value;
}

// -------------------------------------------------------------------

// FloatObjectiveProto

// repeated int32 vars = 1;
inline int FloatObjectiveProto::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int FloatObjectiveProto::vars_size() const {
  return _internal_vars_size();
}
inline void FloatObjectiveProto::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t FloatObjectiveProto::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.FloatObjectiveProto.vars)
  return _internal_vars().Get(index);
}
inline void FloatObjectiveProto::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.FloatObjectiveProto.vars)
}
inline void FloatObjectiveProto::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.FloatObjectiveProto.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& FloatObjectiveProto::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.FloatObjectiveProto.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL FloatObjectiveProto::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.FloatObjectiveProto.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
FloatObjectiveProto::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
FloatObjectiveProto::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated double coeffs = 2;
inline int FloatObjectiveProto::_internal_coeffs_size() const {
  return _internal_coeffs().size();
}
inline int FloatObjectiveProto::coeffs_size() const {
  return _internal_coeffs_size();
}
inline void FloatObjectiveProto::clear_coeffs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coeffs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline double FloatObjectiveProto::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.FloatObjectiveProto.coeffs)
  return _internal_coeffs().Get(index);
}
inline void FloatObjectiveProto::set_coeffs(int index, double value) {
  _internal_mutable_coeffs()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.FloatObjectiveProto.coeffs)
}
inline void FloatObjectiveProto::add_coeffs(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_coeffs()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.FloatObjectiveProto.coeffs)
}
inline const ::google::protobuf::RepeatedField<double>& FloatObjectiveProto::coeffs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.FloatObjectiveProto.coeffs)
  return _internal_coeffs();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL FloatObjectiveProto::mutable_coeffs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.FloatObjectiveProto.coeffs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_coeffs();
}
inline const ::google::protobuf::RepeatedField<double>&
FloatObjectiveProto::_internal_coeffs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coeffs_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
FloatObjectiveProto::_internal_mutable_coeffs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.coeffs_;
}

// double offset = 3;
inline void FloatObjectiveProto::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double FloatObjectiveProto::offset() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.FloatObjectiveProto.offset)
  return _internal_offset();
}
inline void FloatObjectiveProto::set_offset(double value) {
  _internal_set_offset(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:operations_research.sat.FloatObjectiveProto.offset)
}
inline double FloatObjectiveProto::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void FloatObjectiveProto::_internal_set_offset(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// bool maximize = 4;
inline void FloatObjectiveProto::clear_maximize() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maximize_ = false;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline bool FloatObjectiveProto::maximize() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.FloatObjectiveProto.maximize)
  return _internal_maximize();
}
inline void FloatObjectiveProto::set_maximize(bool value) {
  _internal_set_maximize(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:operations_research.sat.FloatObjectiveProto.maximize)
}
inline bool FloatObjectiveProto::_internal_maximize() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maximize_;
}
inline void FloatObjectiveProto::_internal_set_maximize(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maximize_ = value;
}

// -------------------------------------------------------------------

// DecisionStrategyProto

// repeated int32 variables = 1;
inline int DecisionStrategyProto::_internal_variables_size() const {
  return _internal_variables().size();
}
inline int DecisionStrategyProto::variables_size() const {
  return _internal_variables_size();
}
inline void DecisionStrategyProto::clear_variables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variables_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DecisionStrategyProto::variables(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.variables)
  return _internal_variables().Get(index);
}
inline void DecisionStrategyProto::set_variables(int index, ::int32_t value) {
  _internal_mutable_variables()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.variables)
}
inline void DecisionStrategyProto::add_variables(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_variables()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.DecisionStrategyProto.variables)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DecisionStrategyProto::variables() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.DecisionStrategyProto.variables)
  return _internal_variables();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DecisionStrategyProto::mutable_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.DecisionStrategyProto.variables)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_variables();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DecisionStrategyProto::_internal_variables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.variables_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DecisionStrategyProto::_internal_mutable_variables() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.variables_;
}

// repeated .operations_research.sat.LinearExpressionProto exprs = 5;
inline int DecisionStrategyProto::_internal_exprs_size() const {
  return _internal_exprs().size();
}
inline int DecisionStrategyProto::exprs_size() const {
  return _internal_exprs_size();
}
inline void DecisionStrategyProto::clear_exprs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exprs_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL DecisionStrategyProto::mutable_exprs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.DecisionStrategyProto.exprs)
  return _internal_mutable_exprs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL DecisionStrategyProto::mutable_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.DecisionStrategyProto.exprs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_exprs();
}
inline const ::operations_research::sat::LinearExpressionProto& DecisionStrategyProto::exprs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.exprs)
  return _internal_exprs().Get(index);
}
inline ::operations_research::sat::LinearExpressionProto* PROTOBUF_NONNULL DecisionStrategyProto::add_exprs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::LinearExpressionProto* _add =
      _internal_mutable_exprs()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.DecisionStrategyProto.exprs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>& DecisionStrategyProto::exprs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.DecisionStrategyProto.exprs)
  return _internal_exprs();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>&
DecisionStrategyProto::_internal_exprs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exprs_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::LinearExpressionProto>* PROTOBUF_NONNULL
DecisionStrategyProto::_internal_mutable_exprs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.exprs_;
}

// .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
inline void DecisionStrategyProto::clear_variable_selection_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variable_selection_strategy_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::variable_selection_strategy() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.variable_selection_strategy)
  return _internal_variable_selection_strategy();
}
inline void DecisionStrategyProto::set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value) {
  _internal_set_variable_selection_strategy(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.variable_selection_strategy)
}
inline ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::_internal_variable_selection_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy>(_impl_.variable_selection_strategy_);
}
inline void DecisionStrategyProto::_internal_set_variable_selection_strategy(::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variable_selection_strategy_ = value;
}

// .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
inline void DecisionStrategyProto::clear_domain_reduction_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.domain_reduction_strategy_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::domain_reduction_strategy() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DecisionStrategyProto.domain_reduction_strategy)
  return _internal_domain_reduction_strategy();
}
inline void DecisionStrategyProto::set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value) {
  _internal_set_domain_reduction_strategy(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:operations_research.sat.DecisionStrategyProto.domain_reduction_strategy)
}
inline ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::_internal_domain_reduction_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy>(_impl_.domain_reduction_strategy_);
}
inline void DecisionStrategyProto::_internal_set_domain_reduction_strategy(::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.domain_reduction_strategy_ = value;
}

// -------------------------------------------------------------------

// PartialVariableAssignment

// repeated int32 vars = 1;
inline int PartialVariableAssignment::_internal_vars_size() const {
  return _internal_vars().size();
}
inline int PartialVariableAssignment::vars_size() const {
  return _internal_vars_size();
}
inline void PartialVariableAssignment::clear_vars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vars_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PartialVariableAssignment::vars(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.PartialVariableAssignment.vars)
  return _internal_vars().Get(index);
}
inline void PartialVariableAssignment::set_vars(int index, ::int32_t value) {
  _internal_mutable_vars()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.PartialVariableAssignment.vars)
}
inline void PartialVariableAssignment::add_vars(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_vars()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.PartialVariableAssignment.vars)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& PartialVariableAssignment::vars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.PartialVariableAssignment.vars)
  return _internal_vars();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL PartialVariableAssignment::mutable_vars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.PartialVariableAssignment.vars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_vars();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
PartialVariableAssignment::_internal_vars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vars_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
PartialVariableAssignment::_internal_mutable_vars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.vars_;
}

// repeated int64 values = 2;
inline int PartialVariableAssignment::_internal_values_size() const {
  return _internal_values().size();
}
inline int PartialVariableAssignment::values_size() const {
  return _internal_values_size();
}
inline void PartialVariableAssignment::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int64_t PartialVariableAssignment::values(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.PartialVariableAssignment.values)
  return _internal_values().Get(index);
}
inline void PartialVariableAssignment::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.PartialVariableAssignment.values)
}
inline void PartialVariableAssignment::add_values(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.PartialVariableAssignment.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& PartialVariableAssignment::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.PartialVariableAssignment.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL PartialVariableAssignment::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.PartialVariableAssignment.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
PartialVariableAssignment::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
PartialVariableAssignment::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// SparsePermutationProto

// repeated int32 support = 1;
inline int SparsePermutationProto::_internal_support_size() const {
  return _internal_support().size();
}
inline int SparsePermutationProto::support_size() const {
  return _internal_support_size();
}
inline void SparsePermutationProto::clear_support() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.support_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t SparsePermutationProto::support(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SparsePermutationProto.support)
  return _internal_support().Get(index);
}
inline void SparsePermutationProto::set_support(int index, ::int32_t value) {
  _internal_mutable_support()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SparsePermutationProto.support)
}
inline void SparsePermutationProto::add_support(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_support()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.SparsePermutationProto.support)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SparsePermutationProto::support() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SparsePermutationProto.support)
  return _internal_support();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SparsePermutationProto::mutable_support()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SparsePermutationProto.support)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_support();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SparsePermutationProto::_internal_support() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.support_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SparsePermutationProto::_internal_mutable_support() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.support_;
}

// repeated int32 cycle_sizes = 2;
inline int SparsePermutationProto::_internal_cycle_sizes_size() const {
  return _internal_cycle_sizes().size();
}
inline int SparsePermutationProto::cycle_sizes_size() const {
  return _internal_cycle_sizes_size();
}
inline void SparsePermutationProto::clear_cycle_sizes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cycle_sizes_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t SparsePermutationProto::cycle_sizes(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.SparsePermutationProto.cycle_sizes)
  return _internal_cycle_sizes().Get(index);
}
inline void SparsePermutationProto::set_cycle_sizes(int index, ::int32_t value) {
  _internal_mutable_cycle_sizes()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.SparsePermutationProto.cycle_sizes)
}
inline void SparsePermutationProto::add_cycle_sizes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_cycle_sizes()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.SparsePermutationProto.cycle_sizes)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SparsePermutationProto::cycle_sizes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SparsePermutationProto.cycle_sizes)
  return _internal_cycle_sizes();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL SparsePermutationProto::mutable_cycle_sizes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SparsePermutationProto.cycle_sizes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cycle_sizes();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
SparsePermutationProto::_internal_cycle_sizes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cycle_sizes_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
SparsePermutationProto::_internal_mutable_cycle_sizes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cycle_sizes_;
}

// -------------------------------------------------------------------

// DenseMatrixProto

// int32 num_rows = 1;
inline void DenseMatrixProto::clear_num_rows() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_rows_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DenseMatrixProto::num_rows() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DenseMatrixProto.num_rows)
  return _internal_num_rows();
}
inline void DenseMatrixProto::set_num_rows(::int32_t value) {
  _internal_set_num_rows(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:operations_research.sat.DenseMatrixProto.num_rows)
}
inline ::int32_t DenseMatrixProto::_internal_num_rows() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_rows_;
}
inline void DenseMatrixProto::_internal_set_num_rows(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_rows_ = value;
}

// int32 num_cols = 2;
inline void DenseMatrixProto::clear_num_cols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cols_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t DenseMatrixProto::num_cols() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DenseMatrixProto.num_cols)
  return _internal_num_cols();
}
inline void DenseMatrixProto::set_num_cols(::int32_t value) {
  _internal_set_num_cols(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:operations_research.sat.DenseMatrixProto.num_cols)
}
inline ::int32_t DenseMatrixProto::_internal_num_cols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_cols_;
}
inline void DenseMatrixProto::_internal_set_num_cols(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_cols_ = value;
}

// repeated int32 entries = 3;
inline int DenseMatrixProto::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int DenseMatrixProto::entries_size() const {
  return _internal_entries_size();
}
inline void DenseMatrixProto::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DenseMatrixProto::entries(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.DenseMatrixProto.entries)
  return _internal_entries().Get(index);
}
inline void DenseMatrixProto::set_entries(int index, ::int32_t value) {
  _internal_mutable_entries()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.DenseMatrixProto.entries)
}
inline void DenseMatrixProto::add_entries(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_entries()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.DenseMatrixProto.entries)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& DenseMatrixProto::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.DenseMatrixProto.entries)
  return _internal_entries();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL DenseMatrixProto::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.DenseMatrixProto.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
DenseMatrixProto::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
DenseMatrixProto::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// SymmetryProto

// repeated .operations_research.sat.SparsePermutationProto permutations = 1;
inline int SymmetryProto::_internal_permutations_size() const {
  return _internal_permutations().size();
}
inline int SymmetryProto::permutations_size() const {
  return _internal_permutations_size();
}
inline void SymmetryProto::clear_permutations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.permutations_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::SparsePermutationProto* PROTOBUF_NONNULL SymmetryProto::mutable_permutations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SymmetryProto.permutations)
  return _internal_mutable_permutations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>* PROTOBUF_NONNULL SymmetryProto::mutable_permutations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SymmetryProto.permutations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_permutations();
}
inline const ::operations_research::sat::SparsePermutationProto& SymmetryProto::permutations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SymmetryProto.permutations)
  return _internal_permutations().Get(index);
}
inline ::operations_research::sat::SparsePermutationProto* PROTOBUF_NONNULL SymmetryProto::add_permutations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::SparsePermutationProto* _add =
      _internal_mutable_permutations()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.SymmetryProto.permutations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>& SymmetryProto::permutations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SymmetryProto.permutations)
  return _internal_permutations();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>&
SymmetryProto::_internal_permutations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.permutations_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::SparsePermutationProto>* PROTOBUF_NONNULL
SymmetryProto::_internal_mutable_permutations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.permutations_;
}

// repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
inline int SymmetryProto::_internal_orbitopes_size() const {
  return _internal_orbitopes().size();
}
inline int SymmetryProto::orbitopes_size() const {
  return _internal_orbitopes_size();
}
inline void SymmetryProto::clear_orbitopes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orbitopes_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::DenseMatrixProto* PROTOBUF_NONNULL SymmetryProto::mutable_orbitopes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.SymmetryProto.orbitopes)
  return _internal_mutable_orbitopes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>* PROTOBUF_NONNULL SymmetryProto::mutable_orbitopes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.SymmetryProto.orbitopes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_orbitopes();
}
inline const ::operations_research::sat::DenseMatrixProto& SymmetryProto::orbitopes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.SymmetryProto.orbitopes)
  return _internal_orbitopes().Get(index);
}
inline ::operations_research::sat::DenseMatrixProto* PROTOBUF_NONNULL SymmetryProto::add_orbitopes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::DenseMatrixProto* _add =
      _internal_mutable_orbitopes()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.SymmetryProto.orbitopes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>& SymmetryProto::orbitopes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.SymmetryProto.orbitopes)
  return _internal_orbitopes();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>&
SymmetryProto::_internal_orbitopes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orbitopes_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::DenseMatrixProto>* PROTOBUF_NONNULL
SymmetryProto::_internal_mutable_orbitopes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.orbitopes_;
}

// -------------------------------------------------------------------

// CpModelProto

// string name = 1;
inline void CpModelProto::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& CpModelProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CpModelProto::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.CpModelProto.name)
}
inline ::std::string* PROTOBUF_NONNULL CpModelProto::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.name)
  return _s;
}
inline const ::std::string& CpModelProto::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void CpModelProto::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CpModelProto::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CpModelProto::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void CpModelProto::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.name)
}

// repeated .operations_research.sat.IntegerVariableProto variables = 2;
inline int CpModelProto::_internal_variables_size() const {
  return _internal_variables().size();
}
inline int CpModelProto::variables_size() const {
  return _internal_variables_size();
}
inline void CpModelProto::clear_variables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variables_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL CpModelProto::mutable_variables(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.variables)
  return _internal_mutable_variables()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL CpModelProto::mutable_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.variables)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_variables();
}
inline const ::operations_research::sat::IntegerVariableProto& CpModelProto::variables(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.variables)
  return _internal_variables().Get(index);
}
inline ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL CpModelProto::add_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::IntegerVariableProto* _add =
      _internal_mutable_variables()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.variables)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& CpModelProto::variables() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.variables)
  return _internal_variables();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>&
CpModelProto::_internal_variables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.variables_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL
CpModelProto::_internal_mutable_variables() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.variables_;
}

// repeated .operations_research.sat.ConstraintProto constraints = 3;
inline int CpModelProto::_internal_constraints_size() const {
  return _internal_constraints().size();
}
inline int CpModelProto::constraints_size() const {
  return _internal_constraints_size();
}
inline void CpModelProto::clear_constraints() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constraints_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::ConstraintProto* PROTOBUF_NONNULL CpModelProto::mutable_constraints(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.constraints)
  return _internal_mutable_constraints()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>* PROTOBUF_NONNULL CpModelProto::mutable_constraints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.constraints)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_constraints();
}
inline const ::operations_research::sat::ConstraintProto& CpModelProto::constraints(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.constraints)
  return _internal_constraints().Get(index);
}
inline ::operations_research::sat::ConstraintProto* PROTOBUF_NONNULL CpModelProto::add_constraints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::ConstraintProto* _add =
      _internal_mutable_constraints()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.constraints)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>& CpModelProto::constraints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.constraints)
  return _internal_constraints();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>&
CpModelProto::_internal_constraints() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constraints_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::ConstraintProto>* PROTOBUF_NONNULL
CpModelProto::_internal_mutable_constraints() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.constraints_;
}

// .operations_research.sat.CpObjectiveProto objective = 4;
inline bool CpModelProto::has_objective() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000020U);
  PROTOBUF_ASSUME(!value || _impl_.objective_ != nullptr);
  return value;
}
inline void CpModelProto::clear_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ != nullptr) _impl_.objective_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::operations_research::sat::CpObjectiveProto& CpModelProto::_internal_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::CpObjectiveProto* p = _impl_.objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::CpObjectiveProto&>(::operations_research::sat::_CpObjectiveProto_default_instance_);
}
inline const ::operations_research::sat::CpObjectiveProto& CpModelProto::objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.objective)
  return _internal_objective();
}
inline void CpModelProto::unsafe_arena_set_allocated_objective(
    ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }
  _impl_.objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CpModelProto.objective)
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE CpModelProto::release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::operations_research::sat::CpObjectiveProto* released = _impl_.objective_;
  _impl_.objective_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE CpModelProto::unsafe_arena_release_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.objective)

  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::operations_research::sat::CpObjectiveProto* temp = _impl_.objective_;
  _impl_.objective_ = nullptr;
  return temp;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL CpModelProto::_internal_mutable_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::CpObjectiveProto>(GetArena());
    _impl_.objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(p);
  }
  return _impl_.objective_;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL CpModelProto::mutable_objective()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::operations_research::sat::CpObjectiveProto* _msg = _internal_mutable_objective();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.objective)
  return _msg;
}
inline void CpModelProto::set_allocated_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }

  _impl_.objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.objective)
}

// .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
inline bool CpModelProto::has_floating_point_objective() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000100U);
  PROTOBUF_ASSUME(!value || _impl_.floating_point_objective_ != nullptr);
  return value;
}
inline void CpModelProto::clear_floating_point_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.floating_point_objective_ != nullptr) _impl_.floating_point_objective_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline const ::operations_research::sat::FloatObjectiveProto& CpModelProto::_internal_floating_point_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::FloatObjectiveProto* p = _impl_.floating_point_objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::FloatObjectiveProto&>(::operations_research::sat::_FloatObjectiveProto_default_instance_);
}
inline const ::operations_research::sat::FloatObjectiveProto& CpModelProto::floating_point_objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.floating_point_objective)
  return _internal_floating_point_objective();
}
inline void CpModelProto::unsafe_arena_set_allocated_floating_point_objective(
    ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.floating_point_objective_);
  }
  _impl_.floating_point_objective_ = reinterpret_cast<::operations_research::sat::FloatObjectiveProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CpModelProto.floating_point_objective)
}
inline ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE CpModelProto::release_floating_point_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::operations_research::sat::FloatObjectiveProto* released = _impl_.floating_point_objective_;
  _impl_.floating_point_objective_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE CpModelProto::unsafe_arena_release_floating_point_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.floating_point_objective)

  ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::operations_research::sat::FloatObjectiveProto* temp = _impl_.floating_point_objective_;
  _impl_.floating_point_objective_ = nullptr;
  return temp;
}
inline ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NONNULL CpModelProto::_internal_mutable_floating_point_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.floating_point_objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::FloatObjectiveProto>(GetArena());
    _impl_.floating_point_objective_ = reinterpret_cast<::operations_research::sat::FloatObjectiveProto*>(p);
  }
  return _impl_.floating_point_objective_;
}
inline ::operations_research::sat::FloatObjectiveProto* PROTOBUF_NONNULL CpModelProto::mutable_floating_point_objective()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  ::operations_research::sat::FloatObjectiveProto* _msg = _internal_mutable_floating_point_objective();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.floating_point_objective)
  return _msg;
}
inline void CpModelProto::set_allocated_floating_point_objective(::operations_research::sat::FloatObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.floating_point_objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000100U);
  }

  _impl_.floating_point_objective_ = reinterpret_cast<::operations_research::sat::FloatObjectiveProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.floating_point_objective)
}

// repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
inline int CpModelProto::_internal_search_strategy_size() const {
  return _internal_search_strategy().size();
}
inline int CpModelProto::search_strategy_size() const {
  return _internal_search_strategy_size();
}
inline void CpModelProto::clear_search_strategy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.search_strategy_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::operations_research::sat::DecisionStrategyProto* PROTOBUF_NONNULL CpModelProto::mutable_search_strategy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.search_strategy)
  return _internal_mutable_search_strategy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>* PROTOBUF_NONNULL CpModelProto::mutable_search_strategy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.search_strategy)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_search_strategy();
}
inline const ::operations_research::sat::DecisionStrategyProto& CpModelProto::search_strategy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.search_strategy)
  return _internal_search_strategy().Get(index);
}
inline ::operations_research::sat::DecisionStrategyProto* PROTOBUF_NONNULL CpModelProto::add_search_strategy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::DecisionStrategyProto* _add =
      _internal_mutable_search_strategy()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.search_strategy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>& CpModelProto::search_strategy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.search_strategy)
  return _internal_search_strategy();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>&
CpModelProto::_internal_search_strategy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.search_strategy_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::DecisionStrategyProto>* PROTOBUF_NONNULL
CpModelProto::_internal_mutable_search_strategy() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.search_strategy_;
}

// .operations_research.sat.PartialVariableAssignment solution_hint = 6;
inline bool CpModelProto::has_solution_hint() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.solution_hint_ != nullptr);
  return value;
}
inline void CpModelProto::clear_solution_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.solution_hint_ != nullptr) _impl_.solution_hint_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::operations_research::sat::PartialVariableAssignment& CpModelProto::_internal_solution_hint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::PartialVariableAssignment* p = _impl_.solution_hint_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::PartialVariableAssignment&>(::operations_research::sat::_PartialVariableAssignment_default_instance_);
}
inline const ::operations_research::sat::PartialVariableAssignment& CpModelProto::solution_hint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.solution_hint)
  return _internal_solution_hint();
}
inline void CpModelProto::unsafe_arena_set_allocated_solution_hint(
    ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.solution_hint_);
  }
  _impl_.solution_hint_ = reinterpret_cast<::operations_research::sat::PartialVariableAssignment*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CpModelProto.solution_hint)
}
inline ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE CpModelProto::release_solution_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::PartialVariableAssignment* released = _impl_.solution_hint_;
  _impl_.solution_hint_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE CpModelProto::unsafe_arena_release_solution_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.solution_hint)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::PartialVariableAssignment* temp = _impl_.solution_hint_;
  _impl_.solution_hint_ = nullptr;
  return temp;
}
inline ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NONNULL CpModelProto::_internal_mutable_solution_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.solution_hint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::PartialVariableAssignment>(GetArena());
    _impl_.solution_hint_ = reinterpret_cast<::operations_research::sat::PartialVariableAssignment*>(p);
  }
  return _impl_.solution_hint_;
}
inline ::operations_research::sat::PartialVariableAssignment* PROTOBUF_NONNULL CpModelProto::mutable_solution_hint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::PartialVariableAssignment* _msg = _internal_mutable_solution_hint();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.solution_hint)
  return _msg;
}
inline void CpModelProto::set_allocated_solution_hint(::operations_research::sat::PartialVariableAssignment* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.solution_hint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.solution_hint_ = reinterpret_cast<::operations_research::sat::PartialVariableAssignment*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.solution_hint)
}

// repeated int32 assumptions = 7;
inline int CpModelProto::_internal_assumptions_size() const {
  return _internal_assumptions().size();
}
inline int CpModelProto::assumptions_size() const {
  return _internal_assumptions_size();
}
inline void CpModelProto::clear_assumptions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assumptions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t CpModelProto::assumptions(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.assumptions)
  return _internal_assumptions().Get(index);
}
inline void CpModelProto::set_assumptions(int index, ::int32_t value) {
  _internal_mutable_assumptions()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpModelProto.assumptions)
}
inline void CpModelProto::add_assumptions(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_assumptions()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpModelProto.assumptions)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CpModelProto::assumptions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpModelProto.assumptions)
  return _internal_assumptions();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CpModelProto::mutable_assumptions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpModelProto.assumptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_assumptions();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CpModelProto::_internal_assumptions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assumptions_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CpModelProto::_internal_mutable_assumptions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.assumptions_;
}

// .operations_research.sat.SymmetryProto symmetry = 8;
inline bool CpModelProto::has_symmetry() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000080U);
  PROTOBUF_ASSUME(!value || _impl_.symmetry_ != nullptr);
  return value;
}
inline void CpModelProto::clear_symmetry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symmetry_ != nullptr) _impl_.symmetry_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline const ::operations_research::sat::SymmetryProto& CpModelProto::_internal_symmetry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::SymmetryProto* p = _impl_.symmetry_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::SymmetryProto&>(::operations_research::sat::_SymmetryProto_default_instance_);
}
inline const ::operations_research::sat::SymmetryProto& CpModelProto::symmetry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpModelProto.symmetry)
  return _internal_symmetry();
}
inline void CpModelProto::unsafe_arena_set_allocated_symmetry(
    ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.symmetry_);
  }
  _impl_.symmetry_ = reinterpret_cast<::operations_research::sat::SymmetryProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CpModelProto.symmetry)
}
inline ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE CpModelProto::release_symmetry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::operations_research::sat::SymmetryProto* released = _impl_.symmetry_;
  _impl_.symmetry_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE CpModelProto::unsafe_arena_release_symmetry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpModelProto.symmetry)

  ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::operations_research::sat::SymmetryProto* temp = _impl_.symmetry_;
  _impl_.symmetry_ = nullptr;
  return temp;
}
inline ::operations_research::sat::SymmetryProto* PROTOBUF_NONNULL CpModelProto::_internal_mutable_symmetry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.symmetry_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::SymmetryProto>(GetArena());
    _impl_.symmetry_ = reinterpret_cast<::operations_research::sat::SymmetryProto*>(p);
  }
  return _impl_.symmetry_;
}
inline ::operations_research::sat::SymmetryProto* PROTOBUF_NONNULL CpModelProto::mutable_symmetry()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  ::operations_research::sat::SymmetryProto* _msg = _internal_mutable_symmetry();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpModelProto.symmetry)
  return _msg;
}
inline void CpModelProto::set_allocated_symmetry(::operations_research::sat::SymmetryProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.symmetry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000080U);
  }

  _impl_.symmetry_ = reinterpret_cast<::operations_research::sat::SymmetryProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpModelProto.symmetry)
}

// -------------------------------------------------------------------

// CpSolverSolution

// repeated int64 values = 1;
inline int CpSolverSolution::_internal_values_size() const {
  return _internal_values().size();
}
inline int CpSolverSolution::values_size() const {
  return _internal_values_size();
}
inline void CpSolverSolution::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t CpSolverSolution::values(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverSolution.values)
  return _internal_values().Get(index);
}
inline void CpSolverSolution::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverSolution.values)
}
inline void CpSolverSolution::add_values(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverSolution.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CpSolverSolution::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverSolution.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL CpSolverSolution::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverSolution.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
CpSolverSolution::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
CpSolverSolution::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// CpSolverResponse

// .operations_research.sat.CpSolverStatus status = 1;
inline void CpSolverResponse::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00800000U);
}
inline ::operations_research::sat::CpSolverStatus CpSolverResponse::status() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.status)
  return _internal_status();
}
inline void CpSolverResponse::set_status(::operations_research::sat::CpSolverStatus value) {
  _internal_set_status(value);
  SetHasBit(_impl_._has_bits_[0], 0x00800000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.status)
}
inline ::operations_research::sat::CpSolverStatus CpSolverResponse::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::operations_research::sat::CpSolverStatus>(_impl_.status_);
}
inline void CpSolverResponse::_internal_set_status(::operations_research::sat::CpSolverStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// repeated int64 solution = 2;
inline int CpSolverResponse::_internal_solution_size() const {
  return _internal_solution().size();
}
inline int CpSolverResponse::solution_size() const {
  return _internal_solution_size();
}
inline void CpSolverResponse::clear_solution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.solution_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int64_t CpSolverResponse::solution(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solution)
  return _internal_solution().Get(index);
}
inline void CpSolverResponse::set_solution(int index, ::int64_t value) {
  _internal_mutable_solution()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solution)
}
inline void CpSolverResponse::add_solution(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_solution()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.solution)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CpSolverResponse::solution() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.solution)
  return _internal_solution();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL CpSolverResponse::mutable_solution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.solution)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_solution();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
CpSolverResponse::_internal_solution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.solution_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
CpSolverResponse::_internal_mutable_solution() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.solution_;
}

// double objective_value = 3;
inline void CpSolverResponse::clear_objective_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objective_value_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000080U);
}
inline double CpSolverResponse::objective_value() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.objective_value)
  return _internal_objective_value();
}
inline void CpSolverResponse::set_objective_value(double value) {
  _internal_set_objective_value(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000080U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.objective_value)
}
inline double CpSolverResponse::_internal_objective_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.objective_value_;
}
inline void CpSolverResponse::_internal_set_objective_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.objective_value_ = value;
}

// double best_objective_bound = 4;
inline void CpSolverResponse::clear_best_objective_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.best_objective_bound_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000100U);
}
inline double CpSolverResponse::best_objective_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.best_objective_bound)
  return _internal_best_objective_bound();
}
inline void CpSolverResponse::set_best_objective_bound(double value) {
  _internal_set_best_objective_bound(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000100U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.best_objective_bound)
}
inline double CpSolverResponse::_internal_best_objective_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.best_objective_bound_;
}
inline void CpSolverResponse::_internal_set_best_objective_bound(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.best_objective_bound_ = value;
}

// repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
inline int CpSolverResponse::_internal_additional_solutions_size() const {
  return _internal_additional_solutions().size();
}
inline int CpSolverResponse::additional_solutions_size() const {
  return _internal_additional_solutions_size();
}
inline void CpSolverResponse::clear_additional_solutions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.additional_solutions_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::operations_research::sat::CpSolverSolution* PROTOBUF_NONNULL CpSolverResponse::mutable_additional_solutions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpSolverResponse.additional_solutions)
  return _internal_mutable_additional_solutions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>* PROTOBUF_NONNULL CpSolverResponse::mutable_additional_solutions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.additional_solutions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_additional_solutions();
}
inline const ::operations_research::sat::CpSolverSolution& CpSolverResponse::additional_solutions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.additional_solutions)
  return _internal_additional_solutions().Get(index);
}
inline ::operations_research::sat::CpSolverSolution* PROTOBUF_NONNULL CpSolverResponse::add_additional_solutions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::CpSolverSolution* _add =
      _internal_mutable_additional_solutions()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.additional_solutions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>& CpSolverResponse::additional_solutions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.additional_solutions)
  return _internal_additional_solutions();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>&
CpSolverResponse::_internal_additional_solutions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.additional_solutions_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::CpSolverSolution>* PROTOBUF_NONNULL
CpSolverResponse::_internal_mutable_additional_solutions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.additional_solutions_;
}

// repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
inline int CpSolverResponse::_internal_tightened_variables_size() const {
  return _internal_tightened_variables().size();
}
inline int CpSolverResponse::tightened_variables_size() const {
  return _internal_tightened_variables_size();
}
inline void CpSolverResponse::clear_tightened_variables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tightened_variables_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL CpSolverResponse::mutable_tightened_variables(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpSolverResponse.tightened_variables)
  return _internal_mutable_tightened_variables()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL CpSolverResponse::mutable_tightened_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.tightened_variables)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tightened_variables();
}
inline const ::operations_research::sat::IntegerVariableProto& CpSolverResponse::tightened_variables(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.tightened_variables)
  return _internal_tightened_variables().Get(index);
}
inline ::operations_research::sat::IntegerVariableProto* PROTOBUF_NONNULL CpSolverResponse::add_tightened_variables()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::operations_research::sat::IntegerVariableProto* _add =
      _internal_mutable_tightened_variables()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.tightened_variables)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>& CpSolverResponse::tightened_variables() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.tightened_variables)
  return _internal_tightened_variables();
}
inline const ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>&
CpSolverResponse::_internal_tightened_variables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tightened_variables_;
}
inline ::google::protobuf::RepeatedPtrField<::operations_research::sat::IntegerVariableProto>* PROTOBUF_NONNULL
CpSolverResponse::_internal_mutable_tightened_variables() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tightened_variables_;
}

// repeated int32 sufficient_assumptions_for_infeasibility = 23;
inline int CpSolverResponse::_internal_sufficient_assumptions_for_infeasibility_size() const {
  return _internal_sufficient_assumptions_for_infeasibility().size();
}
inline int CpSolverResponse::sufficient_assumptions_for_infeasibility_size() const {
  return _internal_sufficient_assumptions_for_infeasibility_size();
}
inline void CpSolverResponse::clear_sufficient_assumptions_for_infeasibility() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sufficient_assumptions_for_infeasibility_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t CpSolverResponse::sufficient_assumptions_for_infeasibility(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.sufficient_assumptions_for_infeasibility)
  return _internal_sufficient_assumptions_for_infeasibility().Get(index);
}
inline void CpSolverResponse::set_sufficient_assumptions_for_infeasibility(int index, ::int32_t value) {
  _internal_mutable_sufficient_assumptions_for_infeasibility()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.sufficient_assumptions_for_infeasibility)
}
inline void CpSolverResponse::add_sufficient_assumptions_for_infeasibility(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_sufficient_assumptions_for_infeasibility()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.sat.CpSolverResponse.sufficient_assumptions_for_infeasibility)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CpSolverResponse::sufficient_assumptions_for_infeasibility() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.sat.CpSolverResponse.sufficient_assumptions_for_infeasibility)
  return _internal_sufficient_assumptions_for_infeasibility();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL CpSolverResponse::mutable_sufficient_assumptions_for_infeasibility()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.sat.CpSolverResponse.sufficient_assumptions_for_infeasibility)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sufficient_assumptions_for_infeasibility();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CpSolverResponse::_internal_sufficient_assumptions_for_infeasibility() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sufficient_assumptions_for_infeasibility_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
CpSolverResponse::_internal_mutable_sufficient_assumptions_for_infeasibility() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sufficient_assumptions_for_infeasibility_;
}

// .operations_research.sat.CpObjectiveProto integer_objective = 28;
inline bool CpSolverResponse::has_integer_objective() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000040U);
  PROTOBUF_ASSUME(!value || _impl_.integer_objective_ != nullptr);
  return value;
}
inline void CpSolverResponse::clear_integer_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.integer_objective_ != nullptr) _impl_.integer_objective_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000040U);
}
inline const ::operations_research::sat::CpObjectiveProto& CpSolverResponse::_internal_integer_objective() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::sat::CpObjectiveProto* p = _impl_.integer_objective_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::sat::CpObjectiveProto&>(::operations_research::sat::_CpObjectiveProto_default_instance_);
}
inline const ::operations_research::sat::CpObjectiveProto& CpSolverResponse::integer_objective() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.integer_objective)
  return _internal_integer_objective();
}
inline void CpSolverResponse::unsafe_arena_set_allocated_integer_objective(
    ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.integer_objective_);
  }
  _impl_.integer_objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.sat.CpSolverResponse.integer_objective)
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE CpSolverResponse::release_integer_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::CpObjectiveProto* released = _impl_.integer_objective_;
  _impl_.integer_objective_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE CpSolverResponse::unsafe_arena_release_integer_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpSolverResponse.integer_objective)

  ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::CpObjectiveProto* temp = _impl_.integer_objective_;
  _impl_.integer_objective_ = nullptr;
  return temp;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL CpSolverResponse::_internal_mutable_integer_objective() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.integer_objective_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::sat::CpObjectiveProto>(GetArena());
    _impl_.integer_objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(p);
  }
  return _impl_.integer_objective_;
}
inline ::operations_research::sat::CpObjectiveProto* PROTOBUF_NONNULL CpSolverResponse::mutable_integer_objective()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  ::operations_research::sat::CpObjectiveProto* _msg = _internal_mutable_integer_objective();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpSolverResponse.integer_objective)
  return _msg;
}
inline void CpSolverResponse::set_allocated_integer_objective(::operations_research::sat::CpObjectiveProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.integer_objective_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000040U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000040U);
  }

  _impl_.integer_objective_ = reinterpret_cast<::operations_research::sat::CpObjectiveProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpSolverResponse.integer_objective)
}

// int64 inner_objective_lower_bound = 29;
inline void CpSolverResponse::clear_inner_objective_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inner_objective_lower_bound_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00100000U);
}
inline ::int64_t CpSolverResponse::inner_objective_lower_bound() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.inner_objective_lower_bound)
  return _internal_inner_objective_lower_bound();
}
inline void CpSolverResponse::set_inner_objective_lower_bound(::int64_t value) {
  _internal_set_inner_objective_lower_bound(value);
  SetHasBit(_impl_._has_bits_[0], 0x00100000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.inner_objective_lower_bound)
}
inline ::int64_t CpSolverResponse::_internal_inner_objective_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inner_objective_lower_bound_;
}
inline void CpSolverResponse::_internal_set_inner_objective_lower_bound(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inner_objective_lower_bound_ = value;
}

// int64 num_integers = 30;
inline void CpSolverResponse::clear_num_integers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_integers_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00200000U);
}
inline ::int64_t CpSolverResponse::num_integers() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_integers)
  return _internal_num_integers();
}
inline void CpSolverResponse::set_num_integers(::int64_t value) {
  _internal_set_num_integers(value);
  SetHasBit(_impl_._has_bits_[0], 0x00200000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_integers)
}
inline ::int64_t CpSolverResponse::_internal_num_integers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_integers_;
}
inline void CpSolverResponse::_internal_set_num_integers(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_integers_ = value;
}

// int64 num_booleans = 10;
inline void CpSolverResponse::clear_num_booleans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_booleans_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000200U);
}
inline ::int64_t CpSolverResponse::num_booleans() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_booleans)
  return _internal_num_booleans();
}
inline void CpSolverResponse::set_num_booleans(::int64_t value) {
  _internal_set_num_booleans(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000200U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_booleans)
}
inline ::int64_t CpSolverResponse::_internal_num_booleans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_booleans_;
}
inline void CpSolverResponse::_internal_set_num_booleans(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_booleans_ = value;
}

// int64 num_fixed_booleans = 31;
inline void CpSolverResponse::clear_num_fixed_booleans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_fixed_booleans_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00400000U);
}
inline ::int64_t CpSolverResponse::num_fixed_booleans() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_fixed_booleans)
  return _internal_num_fixed_booleans();
}
inline void CpSolverResponse::set_num_fixed_booleans(::int64_t value) {
  _internal_set_num_fixed_booleans(value);
  SetHasBit(_impl_._has_bits_[0], 0x00400000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_fixed_booleans)
}
inline ::int64_t CpSolverResponse::_internal_num_fixed_booleans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_fixed_booleans_;
}
inline void CpSolverResponse::_internal_set_num_fixed_booleans(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_fixed_booleans_ = value;
}

// int64 num_conflicts = 11;
inline void CpSolverResponse::clear_num_conflicts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_conflicts_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000400U);
}
inline ::int64_t CpSolverResponse::num_conflicts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_conflicts)
  return _internal_num_conflicts();
}
inline void CpSolverResponse::set_num_conflicts(::int64_t value) {
  _internal_set_num_conflicts(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000400U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_conflicts)
}
inline ::int64_t CpSolverResponse::_internal_num_conflicts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_conflicts_;
}
inline void CpSolverResponse::_internal_set_num_conflicts(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_conflicts_ = value;
}

// int64 num_branches = 12;
inline void CpSolverResponse::clear_num_branches() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_branches_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000800U);
}
inline ::int64_t CpSolverResponse::num_branches() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_branches)
  return _internal_num_branches();
}
inline void CpSolverResponse::set_num_branches(::int64_t value) {
  _internal_set_num_branches(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000800U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_branches)
}
inline ::int64_t CpSolverResponse::_internal_num_branches() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_branches_;
}
inline void CpSolverResponse::_internal_set_num_branches(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_branches_ = value;
}

// int64 num_binary_propagations = 13;
inline void CpSolverResponse::clear_num_binary_propagations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_binary_propagations_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00001000U);
}
inline ::int64_t CpSolverResponse::num_binary_propagations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_binary_propagations)
  return _internal_num_binary_propagations();
}
inline void CpSolverResponse::set_num_binary_propagations(::int64_t value) {
  _internal_set_num_binary_propagations(value);
  SetHasBit(_impl_._has_bits_[0], 0x00001000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_binary_propagations)
}
inline ::int64_t CpSolverResponse::_internal_num_binary_propagations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_binary_propagations_;
}
inline void CpSolverResponse::_internal_set_num_binary_propagations(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_binary_propagations_ = value;
}

// int64 num_integer_propagations = 14;
inline void CpSolverResponse::clear_num_integer_propagations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_integer_propagations_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00002000U);
}
inline ::int64_t CpSolverResponse::num_integer_propagations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_integer_propagations)
  return _internal_num_integer_propagations();
}
inline void CpSolverResponse::set_num_integer_propagations(::int64_t value) {
  _internal_set_num_integer_propagations(value);
  SetHasBit(_impl_._has_bits_[0], 0x00002000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_integer_propagations)
}
inline ::int64_t CpSolverResponse::_internal_num_integer_propagations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_integer_propagations_;
}
inline void CpSolverResponse::_internal_set_num_integer_propagations(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_integer_propagations_ = value;
}

// int64 num_restarts = 24;
inline void CpSolverResponse::clear_num_restarts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_restarts_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00040000U);
}
inline ::int64_t CpSolverResponse::num_restarts() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_restarts)
  return _internal_num_restarts();
}
inline void CpSolverResponse::set_num_restarts(::int64_t value) {
  _internal_set_num_restarts(value);
  SetHasBit(_impl_._has_bits_[0], 0x00040000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_restarts)
}
inline ::int64_t CpSolverResponse::_internal_num_restarts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_restarts_;
}
inline void CpSolverResponse::_internal_set_num_restarts(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_restarts_ = value;
}

// int64 num_lp_iterations = 25;
inline void CpSolverResponse::clear_num_lp_iterations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_lp_iterations_ = ::int64_t{0};
  ClearHasBit(_impl_._has_bits_[0],
                  0x00080000U);
}
inline ::int64_t CpSolverResponse::num_lp_iterations() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.num_lp_iterations)
  return _internal_num_lp_iterations();
}
inline void CpSolverResponse::set_num_lp_iterations(::int64_t value) {
  _internal_set_num_lp_iterations(value);
  SetHasBit(_impl_._has_bits_[0], 0x00080000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.num_lp_iterations)
}
inline ::int64_t CpSolverResponse::_internal_num_lp_iterations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_lp_iterations_;
}
inline void CpSolverResponse::_internal_set_num_lp_iterations(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_lp_iterations_ = value;
}

// double wall_time = 15;
inline void CpSolverResponse::clear_wall_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00004000U);
}
inline double CpSolverResponse::wall_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.wall_time)
  return _internal_wall_time();
}
inline void CpSolverResponse::set_wall_time(double value) {
  _internal_set_wall_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00004000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.wall_time)
}
inline double CpSolverResponse::_internal_wall_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wall_time_;
}
inline void CpSolverResponse::_internal_set_wall_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wall_time_ = value;
}

// double user_time = 16;
inline void CpSolverResponse::clear_user_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00008000U);
}
inline double CpSolverResponse::user_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.user_time)
  return _internal_user_time();
}
inline void CpSolverResponse::set_user_time(double value) {
  _internal_set_user_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00008000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.user_time)
}
inline double CpSolverResponse::_internal_user_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_time_;
}
inline void CpSolverResponse::_internal_set_user_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_time_ = value;
}

// double deterministic_time = 17;
inline void CpSolverResponse::clear_deterministic_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deterministic_time_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00010000U);
}
inline double CpSolverResponse::deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.deterministic_time)
  return _internal_deterministic_time();
}
inline void CpSolverResponse::set_deterministic_time(double value) {
  _internal_set_deterministic_time(value);
  SetHasBit(_impl_._has_bits_[0], 0x00010000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.deterministic_time)
}
inline double CpSolverResponse::_internal_deterministic_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.deterministic_time_;
}
inline void CpSolverResponse::_internal_set_deterministic_time(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.deterministic_time_ = value;
}

// double gap_integral = 22;
inline void CpSolverResponse::clear_gap_integral() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gap_integral_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00020000U);
}
inline double CpSolverResponse::gap_integral() const {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.gap_integral)
  return _internal_gap_integral();
}
inline void CpSolverResponse::set_gap_integral(double value) {
  _internal_set_gap_integral(value);
  SetHasBit(_impl_._has_bits_[0], 0x00020000U);
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.gap_integral)
}
inline double CpSolverResponse::_internal_gap_integral() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gap_integral_;
}
inline void CpSolverResponse::_internal_set_gap_integral(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gap_integral_ = value;
}

// string solution_info = 20;
inline void CpSolverResponse::clear_solution_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.solution_info_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline const ::std::string& CpSolverResponse::solution_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solution_info)
  return _internal_solution_info();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CpSolverResponse::set_solution_info(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  _impl_.solution_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solution_info)
}
inline ::std::string* PROTOBUF_NONNULL CpSolverResponse::mutable_solution_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  ::std::string* _s = _internal_mutable_solution_info();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpSolverResponse.solution_info)
  return _s;
}
inline const ::std::string& CpSolverResponse::_internal_solution_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.solution_info_.Get();
}
inline void CpSolverResponse::_internal_set_solution_info(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.solution_info_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CpSolverResponse::_internal_mutable_solution_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.solution_info_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CpSolverResponse::release_solution_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpSolverResponse.solution_info)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000010U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  auto* released = _impl_.solution_info_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.solution_info_.Set("", GetArena());
  }
  return released;
}
inline void CpSolverResponse::set_allocated_solution_info(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000010U);
  }
  _impl_.solution_info_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.solution_info_.IsDefault()) {
    _impl_.solution_info_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpSolverResponse.solution_info)
}

// string solve_log = 26;
inline void CpSolverResponse::clear_solve_log() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.solve_log_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000020U);
}
inline const ::std::string& CpSolverResponse::solve_log() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.sat.CpSolverResponse.solve_log)
  return _internal_solve_log();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CpSolverResponse::set_solve_log(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  _impl_.solve_log_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:operations_research.sat.CpSolverResponse.solve_log)
}
inline ::std::string* PROTOBUF_NONNULL CpSolverResponse::mutable_solve_log()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  ::std::string* _s = _internal_mutable_solve_log();
  // @@protoc_insertion_point(field_mutable:operations_research.sat.CpSolverResponse.solve_log)
  return _s;
}
inline const ::std::string& CpSolverResponse::_internal_solve_log() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.solve_log_.Get();
}
inline void CpSolverResponse::_internal_set_solve_log(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.solve_log_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CpSolverResponse::_internal_mutable_solve_log() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.solve_log_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CpSolverResponse::release_solve_log() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.sat.CpSolverResponse.solve_log)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000020U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  auto* released = _impl_.solve_log_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.solve_log_.Set("", GetArena());
  }
  return released;
}
inline void CpSolverResponse::set_allocated_solve_log(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000020U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000020U);
  }
  _impl_.solve_log_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.solve_log_.IsDefault()) {
    _impl_.solve_log_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.CpSolverResponse.solve_log)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sat
}  // namespace operations_research


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy>() {
  return ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy>() {
  return ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy_descriptor();
}
template <>
struct is_proto_enum<::operations_research::sat::CpSolverStatus> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::operations_research::sat::CpSolverStatus>() {
  return ::operations_research::sat::CpSolverStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // ortools_2fsat_2fcp_5fmodel_2eproto_2epb_2eh
