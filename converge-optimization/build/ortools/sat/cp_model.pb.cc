// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ortools/sat/cp_model.proto
// Protobuf C++ Version: 6.33.1

#include "ortools/sat/cp_model.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace operations_research {
namespace sat {

inline constexpr SparsePermutationProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        support_{},
        _support_cached_byte_size_{0},
        cycle_sizes_{},
        _cycle_sizes_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SparsePermutationProto::SparsePermutationProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SparsePermutationProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SparsePermutationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparsePermutationProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparsePermutationProtoDefaultTypeInternal() {}
  union {
    SparsePermutationProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparsePermutationProtoDefaultTypeInternal _SparsePermutationProto_default_instance_;

inline constexpr PartialVariableAssignment::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        values_{},
        _values_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PartialVariableAssignment::PartialVariableAssignment(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PartialVariableAssignment_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PartialVariableAssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartialVariableAssignmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartialVariableAssignmentDefaultTypeInternal() {}
  union {
    PartialVariableAssignment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartialVariableAssignmentDefaultTypeInternal _PartialVariableAssignment_default_instance_;

inline constexpr NoOverlapConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        intervals_{},
        _intervals_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR NoOverlapConstraintProto::NoOverlapConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NoOverlapConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NoOverlapConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoOverlapConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoOverlapConstraintProtoDefaultTypeInternal() {}
  union {
    NoOverlapConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoOverlapConstraintProtoDefaultTypeInternal _NoOverlapConstraintProto_default_instance_;

inline constexpr NoOverlap2DConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_intervals_{},
        _x_intervals_cached_byte_size_{0},
        y_intervals_{},
        _y_intervals_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NoOverlap2DConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NoOverlap2DConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoOverlap2DConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoOverlap2DConstraintProtoDefaultTypeInternal() {}
  union {
    NoOverlap2DConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoOverlap2DConstraintProtoDefaultTypeInternal _NoOverlap2DConstraintProto_default_instance_;

inline constexpr ListOfVariablesProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ListOfVariablesProto::ListOfVariablesProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ListOfVariablesProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ListOfVariablesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListOfVariablesProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListOfVariablesProtoDefaultTypeInternal() {}
  union {
    ListOfVariablesProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListOfVariablesProtoDefaultTypeInternal _ListOfVariablesProto_default_instance_;

inline constexpr LinearExpressionProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        coeffs_{},
        _coeffs_cached_byte_size_{0},
        offset_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR LinearExpressionProto::LinearExpressionProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LinearExpressionProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LinearExpressionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearExpressionProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearExpressionProtoDefaultTypeInternal() {}
  union {
    LinearExpressionProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearExpressionProtoDefaultTypeInternal _LinearExpressionProto_default_instance_;

inline constexpr LinearConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        coeffs_{},
        _coeffs_cached_byte_size_{0},
        domain_{},
        _domain_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LinearConstraintProto::LinearConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LinearConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LinearConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearConstraintProtoDefaultTypeInternal() {}
  union {
    LinearConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearConstraintProtoDefaultTypeInternal _LinearConstraintProto_default_instance_;

inline constexpr InverseConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        f_direct_{},
        _f_direct_cached_byte_size_{0},
        f_inverse_{},
        _f_inverse_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR InverseConstraintProto::InverseConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(InverseConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InverseConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InverseConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InverseConstraintProtoDefaultTypeInternal() {}
  union {
    InverseConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InverseConstraintProtoDefaultTypeInternal _InverseConstraintProto_default_instance_;

inline constexpr IntegerVariableProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        domain_{},
        _domain_cached_byte_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR IntegerVariableProto::IntegerVariableProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(IntegerVariableProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct IntegerVariableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegerVariableProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegerVariableProtoDefaultTypeInternal() {}
  union {
    IntegerVariableProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegerVariableProtoDefaultTypeInternal _IntegerVariableProto_default_instance_;

inline constexpr FloatObjectiveProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        coeffs_{},
        offset_{0},
        maximize_{false} {}

template <typename>
PROTOBUF_CONSTEXPR FloatObjectiveProto::FloatObjectiveProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FloatObjectiveProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FloatObjectiveProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatObjectiveProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatObjectiveProtoDefaultTypeInternal() {}
  union {
    FloatObjectiveProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatObjectiveProtoDefaultTypeInternal _FloatObjectiveProto_default_instance_;

inline constexpr DenseMatrixProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        entries_{},
        _entries_cached_byte_size_{0},
        num_rows_{0},
        num_cols_{0} {}

template <typename>
PROTOBUF_CONSTEXPR DenseMatrixProto::DenseMatrixProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DenseMatrixProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DenseMatrixProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenseMatrixProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenseMatrixProtoDefaultTypeInternal() {}
  union {
    DenseMatrixProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenseMatrixProtoDefaultTypeInternal _DenseMatrixProto_default_instance_;

inline constexpr CpSolverSolution::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        values_{},
        _values_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CpSolverSolution::CpSolverSolution(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CpSolverSolution_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CpSolverSolutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpSolverSolutionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpSolverSolutionDefaultTypeInternal() {}
  union {
    CpSolverSolution _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpSolverSolutionDefaultTypeInternal _CpSolverSolution_default_instance_;

inline constexpr CpObjectiveProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        coeffs_{},
        _coeffs_cached_byte_size_{0},
        domain_{},
        _domain_cached_byte_size_{0},
        offset_{0},
        scaling_factor_{0},
        integer_before_offset_{::int64_t{0}},
        integer_scaling_factor_{::int64_t{0}},
        integer_after_offset_{::int64_t{0}},
        scaling_was_exact_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CpObjectiveProto::CpObjectiveProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CpObjectiveProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CpObjectiveProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpObjectiveProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpObjectiveProtoDefaultTypeInternal() {}
  union {
    CpObjectiveProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpObjectiveProtoDefaultTypeInternal _CpObjectiveProto_default_instance_;

inline constexpr CircuitConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        tails_{},
        _tails_cached_byte_size_{0},
        heads_{},
        _heads_cached_byte_size_{0},
        literals_{},
        _literals_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CircuitConstraintProto::CircuitConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CircuitConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CircuitConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircuitConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircuitConstraintProtoDefaultTypeInternal() {}
  union {
    CircuitConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircuitConstraintProtoDefaultTypeInternal _CircuitConstraintProto_default_instance_;

inline constexpr BoolArgumentProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        literals_{},
        _literals_cached_byte_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BoolArgumentProto::BoolArgumentProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BoolArgumentProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BoolArgumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolArgumentProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolArgumentProtoDefaultTypeInternal() {}
  union {
    BoolArgumentProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolArgumentProtoDefaultTypeInternal _BoolArgumentProto_default_instance_;

inline constexpr TableConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        values_{},
        _values_cached_byte_size_{0},
        exprs_{},
        negated_{false} {}

template <typename>
PROTOBUF_CONSTEXPR TableConstraintProto::TableConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TableConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TableConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableConstraintProtoDefaultTypeInternal() {}
  union {
    TableConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableConstraintProtoDefaultTypeInternal _TableConstraintProto_default_instance_;

inline constexpr SymmetryProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        permutations_{},
        orbitopes_{} {}

template <typename>
PROTOBUF_CONSTEXPR SymmetryProto::SymmetryProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SymmetryProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SymmetryProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymmetryProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymmetryProtoDefaultTypeInternal() {}
  union {
    SymmetryProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymmetryProtoDefaultTypeInternal _SymmetryProto_default_instance_;

inline constexpr RoutesConstraintProto_NodeExpressions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        exprs_{} {}

template <typename>
PROTOBUF_CONSTEXPR RoutesConstraintProto_NodeExpressions::RoutesConstraintProto_NodeExpressions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RoutesConstraintProto_NodeExpressions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoutesConstraintProto_NodeExpressionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutesConstraintProto_NodeExpressionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutesConstraintProto_NodeExpressionsDefaultTypeInternal() {}
  union {
    RoutesConstraintProto_NodeExpressions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutesConstraintProto_NodeExpressionsDefaultTypeInternal _RoutesConstraintProto_NodeExpressions_default_instance_;

inline constexpr ReservoirConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        time_exprs_{},
        active_literals_{},
        _active_literals_cached_byte_size_{0},
        level_changes_{},
        min_level_{::int64_t{0}},
        max_level_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR ReservoirConstraintProto::ReservoirConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ReservoirConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ReservoirConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReservoirConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReservoirConstraintProtoDefaultTypeInternal() {}
  union {
    ReservoirConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReservoirConstraintProtoDefaultTypeInternal _ReservoirConstraintProto_default_instance_;

inline constexpr LinearArgumentProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        exprs_{},
        target_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR LinearArgumentProto::LinearArgumentProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LinearArgumentProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LinearArgumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearArgumentProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearArgumentProtoDefaultTypeInternal() {}
  union {
    LinearArgumentProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearArgumentProtoDefaultTypeInternal _LinearArgumentProto_default_instance_;

inline constexpr IntervalConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        start_{nullptr},
        end_{nullptr},
        size_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR IntervalConstraintProto::IntervalConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(IntervalConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct IntervalConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntervalConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntervalConstraintProtoDefaultTypeInternal() {}
  union {
    IntervalConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntervalConstraintProtoDefaultTypeInternal _IntervalConstraintProto_default_instance_;

inline constexpr ElementConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        exprs_{},
        linear_index_{nullptr},
        linear_target_{nullptr},
        index_{0},
        target_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ElementConstraintProto::ElementConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ElementConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ElementConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementConstraintProtoDefaultTypeInternal() {}
  union {
    ElementConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementConstraintProtoDefaultTypeInternal _ElementConstraintProto_default_instance_;

inline constexpr DecisionStrategyProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        variables_{},
        _variables_cached_byte_size_{0},
        exprs_{},
        variable_selection_strategy_{static_cast< ::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy >(0)},
        domain_reduction_strategy_{static_cast< ::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DecisionStrategyProto::DecisionStrategyProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DecisionStrategyProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DecisionStrategyProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecisionStrategyProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecisionStrategyProtoDefaultTypeInternal() {}
  union {
    DecisionStrategyProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecisionStrategyProtoDefaultTypeInternal _DecisionStrategyProto_default_instance_;

inline constexpr CumulativeConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        intervals_{},
        _intervals_cached_byte_size_{0},
        demands_{},
        capacity_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CumulativeConstraintProto::CumulativeConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CumulativeConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CumulativeConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CumulativeConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CumulativeConstraintProtoDefaultTypeInternal() {}
  union {
    CumulativeConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CumulativeConstraintProtoDefaultTypeInternal _CumulativeConstraintProto_default_instance_;

inline constexpr CpSolverResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        solution_{},
        _solution_cached_byte_size_{0},
        tightened_variables_{},
        sufficient_assumptions_for_infeasibility_{},
        _sufficient_assumptions_for_infeasibility_cached_byte_size_{0},
        additional_solutions_{},
        solution_info_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        solve_log_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        integer_objective_{nullptr},
        objective_value_{0},
        best_objective_bound_{0},
        num_booleans_{::int64_t{0}},
        num_conflicts_{::int64_t{0}},
        num_branches_{::int64_t{0}},
        num_binary_propagations_{::int64_t{0}},
        num_integer_propagations_{::int64_t{0}},
        wall_time_{0},
        user_time_{0},
        deterministic_time_{0},
        gap_integral_{0},
        num_restarts_{::int64_t{0}},
        num_lp_iterations_{::int64_t{0}},
        inner_objective_lower_bound_{::int64_t{0}},
        num_integers_{::int64_t{0}},
        num_fixed_booleans_{::int64_t{0}},
        status_{static_cast< ::operations_research::sat::CpSolverStatus >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CpSolverResponse::CpSolverResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CpSolverResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CpSolverResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpSolverResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpSolverResponseDefaultTypeInternal() {}
  union {
    CpSolverResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpSolverResponseDefaultTypeInternal _CpSolverResponse_default_instance_;

inline constexpr AutomatonConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        final_states_{},
        _final_states_cached_byte_size_{0},
        transition_tail_{},
        _transition_tail_cached_byte_size_{0},
        transition_head_{},
        _transition_head_cached_byte_size_{0},
        transition_label_{},
        _transition_label_cached_byte_size_{0},
        vars_{},
        _vars_cached_byte_size_{0},
        exprs_{},
        starting_state_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR AutomatonConstraintProto::AutomatonConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AutomatonConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AutomatonConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutomatonConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutomatonConstraintProtoDefaultTypeInternal() {}
  union {
    AutomatonConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutomatonConstraintProtoDefaultTypeInternal _AutomatonConstraintProto_default_instance_;

inline constexpr AllDifferentConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        exprs_{} {}

template <typename>
PROTOBUF_CONSTEXPR AllDifferentConstraintProto::AllDifferentConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AllDifferentConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AllDifferentConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllDifferentConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllDifferentConstraintProtoDefaultTypeInternal() {}
  union {
    AllDifferentConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllDifferentConstraintProtoDefaultTypeInternal _AllDifferentConstraintProto_default_instance_;

inline constexpr RoutesConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        tails_{},
        _tails_cached_byte_size_{0},
        heads_{},
        _heads_cached_byte_size_{0},
        literals_{},
        _literals_cached_byte_size_{0},
        demands_{},
        _demands_cached_byte_size_{0},
        dimensions_{},
        capacity_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR RoutesConstraintProto::RoutesConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RoutesConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoutesConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutesConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutesConstraintProtoDefaultTypeInternal() {}
  union {
    RoutesConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutesConstraintProtoDefaultTypeInternal _RoutesConstraintProto_default_instance_;

inline constexpr ConstraintProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        enforcement_literal_{},
        _enforcement_literal_cached_byte_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        constraint_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ConstraintProto::ConstraintProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ConstraintProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstraintProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstraintProtoDefaultTypeInternal() {}
  union {
    ConstraintProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstraintProtoDefaultTypeInternal _ConstraintProto_default_instance_;

inline constexpr CpModelProto::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        variables_{},
        constraints_{},
        search_strategy_{},
        assumptions_{},
        _assumptions_cached_byte_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        objective_{nullptr},
        solution_hint_{nullptr},
        symmetry_{nullptr},
        floating_point_objective_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CpModelProto::CpModelProto(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CpModelProto_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CpModelProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpModelProtoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpModelProtoDefaultTypeInternal() {}
  union {
    CpModelProto _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpModelProtoDefaultTypeInternal _CpModelProto_default_instance_;
}  // namespace sat
}  // namespace operations_research
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor* PROTOBUF_NONNULL* PROTOBUF_NULLABLE
    file_level_service_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto = nullptr;
const ::uint32_t
    TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _impl_.domain_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::BoolArgumentProto, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::BoolArgumentProto, _impl_.literals_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.coeffs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.offset_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _impl_.target_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _impl_.exprs_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AllDifferentConstraintProto, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AllDifferentConstraintProto, _impl_.exprs_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.coeffs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.domain_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.index_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.target_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.linear_index_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.linear_target_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.exprs_),
        4,
        5,
        0,
        2,
        3,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.start_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.end_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.size_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlapConstraintProto, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlapConstraintProto, _impl_.intervals_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_.x_intervals_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_.y_intervals_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.capacity_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.intervals_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.demands_),
        2,
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.min_level_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.max_level_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.time_exprs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.level_changes_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.active_literals_),
        3,
        4,
        0,
        2,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.tails_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.heads_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.literals_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto_NodeExpressions, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto_NodeExpressions, _impl_.exprs_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.tails_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.heads_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.literals_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.demands_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.capacity_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.dimensions_),
        0,
        1,
        2,
        3,
        5,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.values_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.exprs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.negated_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _impl_.f_direct_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _impl_.f_inverse_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.starting_state_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.final_states_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_tail_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_head_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_label_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.exprs_),
        6,
        0,
        1,
        2,
        3,
        4,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ListOfVariablesProto, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ListOfVariablesProto, _impl_.vars_),
        0,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_._oneof_case_[0]),
        30, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.enforcement_literal_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
        1,
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.coeffs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.offset_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.scaling_factor_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.domain_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.scaling_was_exact_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_before_offset_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_after_offset_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_scaling_factor_),
        0,
        1,
        3,
        4,
        2,
        8,
        5,
        7,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.coeffs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.offset_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.maximize_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.variables_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.exprs_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.variable_selection_strategy_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.domain_reduction_strategy_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _impl_.vars_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _impl_.values_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _impl_.support_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _impl_.cycle_sizes_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.num_rows_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.num_cols_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.entries_),
        1,
        2,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _impl_.permutations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _impl_.orbitopes_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.variables_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.constraints_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.objective_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.floating_point_objective_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.search_strategy_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.solution_hint_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.assumptions_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.symmetry_),
        4,
        0,
        1,
        5,
        8,
        2,
        6,
        3,
        7,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverSolution, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverSolution, _impl_.values_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_._has_bits_),
        27, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.status_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solution_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.objective_value_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.best_objective_bound_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.additional_solutions_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.tightened_variables_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.sufficient_assumptions_for_infeasibility_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.integer_objective_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.inner_objective_lower_bound_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_integers_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_booleans_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_fixed_booleans_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_conflicts_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_branches_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_binary_propagations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_integer_propagations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_restarts_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_lp_iterations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.wall_time_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.user_time_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.deterministic_time_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.gap_integral_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solution_info_),
        PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solve_log_),
        23,
        0,
        7,
        8,
        3,
        1,
        2,
        6,
        20,
        21,
        9,
        22,
        10,
        11,
        12,
        13,
        18,
        19,
        14,
        15,
        16,
        17,
        4,
        5,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::operations_research::sat::IntegerVariableProto)},
        {7, sizeof(::operations_research::sat::BoolArgumentProto)},
        {12, sizeof(::operations_research::sat::LinearExpressionProto)},
        {21, sizeof(::operations_research::sat::LinearArgumentProto)},
        {28, sizeof(::operations_research::sat::AllDifferentConstraintProto)},
        {33, sizeof(::operations_research::sat::LinearConstraintProto)},
        {42, sizeof(::operations_research::sat::ElementConstraintProto)},
        {57, sizeof(::operations_research::sat::IntervalConstraintProto)},
        {66, sizeof(::operations_research::sat::NoOverlapConstraintProto)},
        {71, sizeof(::operations_research::sat::NoOverlap2DConstraintProto)},
        {78, sizeof(::operations_research::sat::CumulativeConstraintProto)},
        {87, sizeof(::operations_research::sat::ReservoirConstraintProto)},
        {100, sizeof(::operations_research::sat::CircuitConstraintProto)},
        {109, sizeof(::operations_research::sat::RoutesConstraintProto_NodeExpressions)},
        {114, sizeof(::operations_research::sat::RoutesConstraintProto)},
        {129, sizeof(::operations_research::sat::TableConstraintProto)},
        {140, sizeof(::operations_research::sat::InverseConstraintProto)},
        {147, sizeof(::operations_research::sat::AutomatonConstraintProto)},
        {164, sizeof(::operations_research::sat::ListOfVariablesProto)},
        {169, sizeof(::operations_research::sat::ConstraintProto)},
        {224, sizeof(::operations_research::sat::CpObjectiveProto)},
        {245, sizeof(::operations_research::sat::FloatObjectiveProto)},
        {256, sizeof(::operations_research::sat::DecisionStrategyProto)},
        {267, sizeof(::operations_research::sat::PartialVariableAssignment)},
        {274, sizeof(::operations_research::sat::SparsePermutationProto)},
        {281, sizeof(::operations_research::sat::DenseMatrixProto)},
        {290, sizeof(::operations_research::sat::SymmetryProto)},
        {297, sizeof(::operations_research::sat::CpModelProto)},
        {318, sizeof(::operations_research::sat::CpSolverSolution)},
        {323, sizeof(::operations_research::sat::CpSolverResponse)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::operations_research::sat::_IntegerVariableProto_default_instance_._instance,
    &::operations_research::sat::_BoolArgumentProto_default_instance_._instance,
    &::operations_research::sat::_LinearExpressionProto_default_instance_._instance,
    &::operations_research::sat::_LinearArgumentProto_default_instance_._instance,
    &::operations_research::sat::_AllDifferentConstraintProto_default_instance_._instance,
    &::operations_research::sat::_LinearConstraintProto_default_instance_._instance,
    &::operations_research::sat::_ElementConstraintProto_default_instance_._instance,
    &::operations_research::sat::_IntervalConstraintProto_default_instance_._instance,
    &::operations_research::sat::_NoOverlapConstraintProto_default_instance_._instance,
    &::operations_research::sat::_NoOverlap2DConstraintProto_default_instance_._instance,
    &::operations_research::sat::_CumulativeConstraintProto_default_instance_._instance,
    &::operations_research::sat::_ReservoirConstraintProto_default_instance_._instance,
    &::operations_research::sat::_CircuitConstraintProto_default_instance_._instance,
    &::operations_research::sat::_RoutesConstraintProto_NodeExpressions_default_instance_._instance,
    &::operations_research::sat::_RoutesConstraintProto_default_instance_._instance,
    &::operations_research::sat::_TableConstraintProto_default_instance_._instance,
    &::operations_research::sat::_InverseConstraintProto_default_instance_._instance,
    &::operations_research::sat::_AutomatonConstraintProto_default_instance_._instance,
    &::operations_research::sat::_ListOfVariablesProto_default_instance_._instance,
    &::operations_research::sat::_ConstraintProto_default_instance_._instance,
    &::operations_research::sat::_CpObjectiveProto_default_instance_._instance,
    &::operations_research::sat::_FloatObjectiveProto_default_instance_._instance,
    &::operations_research::sat::_DecisionStrategyProto_default_instance_._instance,
    &::operations_research::sat::_PartialVariableAssignment_default_instance_._instance,
    &::operations_research::sat::_SparsePermutationProto_default_instance_._instance,
    &::operations_research::sat::_DenseMatrixProto_default_instance_._instance,
    &::operations_research::sat::_SymmetryProto_default_instance_._instance,
    &::operations_research::sat::_CpModelProto_default_instance_._instance,
    &::operations_research::sat::_CpSolverSolution_default_instance_._instance,
    &::operations_research::sat::_CpSolverResponse_default_instance_._instance,
};
const char descriptor_table_protodef_ortools_2fsat_2fcp_5fmodel_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\032ortools/sat/cp_model.proto\022\027operations"
    "_research.sat\"4\n\024IntegerVariableProto\022\014\n"
    "\004name\030\001 \001(\t\022\016\n\006domain\030\002 \003(\003\"%\n\021BoolArgum"
    "entProto\022\020\n\010literals\030\001 \003(\005\"E\n\025LinearExpr"
    "essionProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs\030\002 \003("
    "\003\022\016\n\006offset\030\003 \001(\003\"\224\001\n\023LinearArgumentProt"
    "o\022>\n\006target\030\001 \001(\0132..operations_research."
    "sat.LinearExpressionProto\022=\n\005exprs\030\002 \003(\013"
    "2..operations_research.sat.LinearExpress"
    "ionProto\"\\\n\033AllDifferentConstraintProto\022"
    "=\n\005exprs\030\001 \003(\0132..operations_research.sat"
    ".LinearExpressionProto\"E\n\025LinearConstrai"
    "ntProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs\030\002 \003(\003\022\016\n"
    "\006domain\030\003 \003(\003\"\221\002\n\026ElementConstraintProto"
    "\022\r\n\005index\030\001 \001(\005\022\016\n\006target\030\002 \001(\005\022\014\n\004vars\030"
    "\003 \003(\005\022D\n\014linear_index\030\004 \001(\0132..operations"
    "_research.sat.LinearExpressionProto\022E\n\rl"
    "inear_target\030\005 \001(\0132..operations_research"
    ".sat.LinearExpressionProto\022=\n\005exprs\030\006 \003("
    "\0132..operations_research.sat.LinearExpres"
    "sionProto\"\323\001\n\027IntervalConstraintProto\022=\n"
    "\005start\030\004 \001(\0132..operations_research.sat.L"
    "inearExpressionProto\022;\n\003end\030\005 \001(\0132..oper"
    "ations_research.sat.LinearExpressionProt"
    "o\022<\n\004size\030\006 \001(\0132..operations_research.sa"
    "t.LinearExpressionProto\"-\n\030NoOverlapCons"
    "traintProto\022\021\n\tintervals\030\001 \003(\005\"F\n\032NoOver"
    "lap2DConstraintProto\022\023\n\013x_intervals\030\001 \003("
    "\005\022\023\n\013y_intervals\030\002 \003(\005\"\261\001\n\031CumulativeCon"
    "straintProto\022@\n\010capacity\030\001 \001(\0132..operati"
    "ons_research.sat.LinearExpressionProto\022\021"
    "\n\tintervals\030\002 \003(\005\022\?\n\007demands\030\003 \003(\0132..ope"
    "rations_research.sat.LinearExpressionPro"
    "to\"\352\001\n\030ReservoirConstraintProto\022\021\n\tmin_l"
    "evel\030\001 \001(\003\022\021\n\tmax_level\030\002 \001(\003\022B\n\ntime_ex"
    "prs\030\003 \003(\0132..operations_research.sat.Line"
    "arExpressionProto\022E\n\rlevel_changes\030\006 \003(\013"
    "2..operations_research.sat.LinearExpress"
    "ionProto\022\027\n\017active_literals\030\005 \003(\005J\004\010\004\020\005\""
    "H\n\026CircuitConstraintProto\022\r\n\005tails\030\003 \003(\005"
    "\022\r\n\005heads\030\004 \003(\005\022\020\n\010literals\030\005 \003(\005\"\220\002\n\025Ro"
    "utesConstraintProto\022\r\n\005tails\030\001 \003(\005\022\r\n\005he"
    "ads\030\002 \003(\005\022\020\n\010literals\030\003 \003(\005\022\017\n\007demands\030\004"
    " \003(\005\022\020\n\010capacity\030\005 \001(\003\022R\n\ndimensions\030\006 \003"
    "(\0132>.operations_research.sat.RoutesConst"
    "raintProto.NodeExpressions\032P\n\017NodeExpres"
    "sions\022=\n\005exprs\030\001 \003(\0132..operations_resear"
    "ch.sat.LinearExpressionProto\"\204\001\n\024TableCo"
    "nstraintProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006values\030\002 "
    "\003(\003\022=\n\005exprs\030\004 \003(\0132..operations_research"
    ".sat.LinearExpressionProto\022\017\n\007negated\030\003 "
    "\001(\010\"=\n\026InverseConstraintProto\022\020\n\010f_direc"
    "t\030\001 \003(\005\022\021\n\tf_inverse\030\002 \003(\005\"\341\001\n\030Automaton"
    "ConstraintProto\022\026\n\016starting_state\030\002 \001(\003\022"
    "\024\n\014final_states\030\003 \003(\003\022\027\n\017transition_tail"
    "\030\004 \003(\003\022\027\n\017transition_head\030\005 \003(\003\022\030\n\020trans"
    "ition_label\030\006 \003(\003\022\014\n\004vars\030\007 \003(\005\022=\n\005exprs"
    "\030\010 \003(\0132..operations_research.sat.LinearE"
    "xpressionProto\"$\n\024ListOfVariablesProto\022\014"
    "\n\004vars\030\001 \003(\005\"\360\014\n\017ConstraintProto\022\014\n\004name"
    "\030\001 \001(\t\022\033\n\023enforcement_literal\030\002 \003(\005\022=\n\007b"
    "ool_or\030\003 \001(\0132*.operations_research.sat.B"
    "oolArgumentProtoH\000\022>\n\010bool_and\030\004 \001(\0132*.o"
    "perations_research.sat.BoolArgumentProto"
    "H\000\022A\n\013at_most_one\030\032 \001(\0132*.operations_res"
    "earch.sat.BoolArgumentProtoH\000\022A\n\013exactly"
    "_one\030\035 \001(\0132*.operations_research.sat.Boo"
    "lArgumentProtoH\000\022>\n\010bool_xor\030\005 \001(\0132*.ope"
    "rations_research.sat.BoolArgumentProtoH\000"
    "\022\?\n\007int_div\030\007 \001(\0132,.operations_research."
    "sat.LinearArgumentProtoH\000\022\?\n\007int_mod\030\010 \001"
    "(\0132,.operations_research.sat.LinearArgum"
    "entProtoH\000\022@\n\010int_prod\030\013 \001(\0132,.operation"
    "s_research.sat.LinearArgumentProtoH\000\022\?\n\007"
    "lin_max\030\033 \001(\0132,.operations_research.sat."
    "LinearArgumentProtoH\000\022@\n\006linear\030\014 \001(\0132.."
    "operations_research.sat.LinearConstraint"
    "ProtoH\000\022H\n\010all_diff\030\r \001(\01324.operations_r"
    "esearch.sat.AllDifferentConstraintProtoH"
    "\000\022B\n\007element\030\016 \001(\0132/.operations_research"
    ".sat.ElementConstraintProtoH\000\022B\n\007circuit"
    "\030\017 \001(\0132/.operations_research.sat.Circuit"
    "ConstraintProtoH\000\022@\n\006routes\030\027 \001(\0132..oper"
    "ations_research.sat.RoutesConstraintProt"
    "oH\000\022>\n\005table\030\020 \001(\0132-.operations_research"
    ".sat.TableConstraintProtoH\000\022F\n\tautomaton"
    "\030\021 \001(\01321.operations_research.sat.Automat"
    "onConstraintProtoH\000\022B\n\007inverse\030\022 \001(\0132/.o"
    "perations_research.sat.InverseConstraint"
    "ProtoH\000\022F\n\treservoir\030\030 \001(\01321.operations_"
    "research.sat.ReservoirConstraintProtoH\000\022"
    "D\n\010interval\030\023 \001(\01320.operations_research."
    "sat.IntervalConstraintProtoH\000\022G\n\nno_over"
    "lap\030\024 \001(\01321.operations_research.sat.NoOv"
    "erlapConstraintProtoH\000\022L\n\rno_overlap_2d\030"
    "\025 \001(\01323.operations_research.sat.NoOverla"
    "p2DConstraintProtoH\000\022H\n\ncumulative\030\026 \001(\013"
    "22.operations_research.sat.CumulativeCon"
    "straintProtoH\000\022I\n\020dummy_constraint\030\036 \001(\013"
    "2-.operations_research.sat.ListOfVariabl"
    "esProtoH\000B\014\n\nconstraint\"\340\001\n\020CpObjectiveP"
    "roto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs\030\004 \003(\003\022\016\n\006of"
    "fset\030\002 \001(\001\022\026\n\016scaling_factor\030\003 \001(\001\022\016\n\006do"
    "main\030\005 \003(\003\022\031\n\021scaling_was_exact\030\006 \001(\010\022\035\n"
    "\025integer_before_offset\030\007 \001(\003\022\034\n\024integer_"
    "after_offset\030\t \001(\003\022\036\n\026integer_scaling_fa"
    "ctor\030\010 \001(\003\"U\n\023FloatObjectiveProto\022\014\n\004var"
    "s\030\001 \003(\005\022\016\n\006coeffs\030\002 \003(\001\022\016\n\006offset\030\003 \001(\001\022"
    "\020\n\010maximize\030\004 \001(\010\"\201\005\n\025DecisionStrategyPr"
    "oto\022\021\n\tvariables\030\001 \003(\005\022=\n\005exprs\030\005 \003(\0132.."
    "operations_research.sat.LinearExpression"
    "Proto\022m\n\033variable_selection_strategy\030\002 \001"
    "(\0162H.operations_research.sat.DecisionStr"
    "ategyProto.VariableSelectionStrategy\022i\n\031"
    "domain_reduction_strategy\030\003 \001(\0162F.operat"
    "ions_research.sat.DecisionStrategyProto."
    "DomainReductionStrategy\"\224\001\n\031VariableSele"
    "ctionStrategy\022\020\n\014CHOOSE_FIRST\020\000\022\025\n\021CHOOS"
    "E_LOWEST_MIN\020\001\022\026\n\022CHOOSE_HIGHEST_MAX\020\002\022\032"
    "\n\026CHOOSE_MIN_DOMAIN_SIZE\020\003\022\032\n\026CHOOSE_MAX"
    "_DOMAIN_SIZE\020\004\"\244\001\n\027DomainReductionStrate"
    "gy\022\024\n\020SELECT_MIN_VALUE\020\000\022\024\n\020SELECT_MAX_V"
    "ALUE\020\001\022\025\n\021SELECT_LOWER_HALF\020\002\022\025\n\021SELECT_"
    "UPPER_HALF\020\003\022\027\n\023SELECT_MEDIAN_VALUE\020\004\022\026\n"
    "\022SELECT_RANDOM_HALF\020\005\"9\n\031PartialVariable"
    "Assignment\022\014\n\004vars\030\001 \003(\005\022\016\n\006values\030\002 \003(\003"
    "\">\n\026SparsePermutationProto\022\017\n\007support\030\001 "
    "\003(\005\022\023\n\013cycle_sizes\030\002 \003(\005\"G\n\020DenseMatrixP"
    "roto\022\020\n\010num_rows\030\001 \001(\005\022\020\n\010num_cols\030\002 \001(\005"
    "\022\017\n\007entries\030\003 \003(\005\"\224\001\n\rSymmetryProto\022E\n\014p"
    "ermutations\030\001 \003(\0132/.operations_research."
    "sat.SparsePermutationProto\022<\n\torbitopes\030"
    "\002 \003(\0132).operations_research.sat.DenseMat"
    "rixProto\"\216\004\n\014CpModelProto\022\014\n\004name\030\001 \001(\t\022"
    "@\n\tvariables\030\002 \003(\0132-.operations_research"
    ".sat.IntegerVariableProto\022=\n\013constraints"
    "\030\003 \003(\0132(.operations_research.sat.Constra"
    "intProto\022<\n\tobjective\030\004 \001(\0132).operations"
    "_research.sat.CpObjectiveProto\022N\n\030floati"
    "ng_point_objective\030\t \001(\0132,.operations_re"
    "search.sat.FloatObjectiveProto\022G\n\017search"
    "_strategy\030\005 \003(\0132..operations_research.sa"
    "t.DecisionStrategyProto\022I\n\rsolution_hint"
    "\030\006 \001(\01322.operations_research.sat.Partial"
    "VariableAssignment\022\023\n\013assumptions\030\007 \003(\005\022"
    "8\n\010symmetry\030\010 \001(\0132&.operations_research."
    "sat.SymmetryProto\"\"\n\020CpSolverSolution\022\016\n"
    "\006values\030\001 \003(\003\"\261\006\n\020CpSolverResponse\0227\n\006st"
    "atus\030\001 \001(\0162\'.operations_research.sat.CpS"
    "olverStatus\022\020\n\010solution\030\002 \003(\003\022\027\n\017objecti"
    "ve_value\030\003 \001(\001\022\034\n\024best_objective_bound\030\004"
    " \001(\001\022G\n\024additional_solutions\030\033 \003(\0132).ope"
    "rations_research.sat.CpSolverSolution\022J\n"
    "\023tightened_variables\030\025 \003(\0132-.operations_"
    "research.sat.IntegerVariableProto\0220\n(suf"
    "ficient_assumptions_for_infeasibility\030\027 "
    "\003(\005\022D\n\021integer_objective\030\034 \001(\0132).operati"
    "ons_research.sat.CpObjectiveProto\022#\n\033inn"
    "er_objective_lower_bound\030\035 \001(\003\022\024\n\014num_in"
    "tegers\030\036 \001(\003\022\024\n\014num_booleans\030\n \001(\003\022\032\n\022nu"
    "m_fixed_booleans\030\037 \001(\003\022\025\n\rnum_conflicts\030"
    "\013 \001(\003\022\024\n\014num_branches\030\014 \001(\003\022\037\n\027num_binar"
    "y_propagations\030\r \001(\003\022 \n\030num_integer_prop"
    "agations\030\016 \001(\003\022\024\n\014num_restarts\030\030 \001(\003\022\031\n\021"
    "num_lp_iterations\030\031 \001(\003\022\021\n\twall_time\030\017 \001"
    "(\001\022\021\n\tuser_time\030\020 \001(\001\022\032\n\022deterministic_t"
    "ime\030\021 \001(\001\022\024\n\014gap_integral\030\026 \001(\001\022\025\n\rsolut"
    "ion_info\030\024 \001(\t\022\021\n\tsolve_log\030\032 \001(\t*[\n\016CpS"
    "olverStatus\022\013\n\007UNKNOWN\020\000\022\021\n\rMODEL_INVALI"
    "D\020\001\022\014\n\010FEASIBLE\020\002\022\016\n\nINFEASIBLE\020\003\022\013\n\007OPT"
    "IMAL\020\004Bv\n\026com.google.ortools.satB\017CpMode"
    "lProtobufP\001Z4github.com/google/or-tools/"
    "ortools/sat/proto/cpmodel\252\002\022Google.OrToo"
    "ls.Satb\006proto3"
};
static ::absl::once_flag descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto = {
    false,
    false,
    6934,
    descriptor_table_protodef_ortools_2fsat_2fcp_5fmodel_2eproto,
    "ortools/sat/cp_model.proto",
    &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
    nullptr,
    0,
    30,
    schemas,
    file_default_instances,
    TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto::offsets,
    file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto,
    file_level_service_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto,
};
namespace operations_research {
namespace sat {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DecisionStrategyProto_VariableSelectionStrategy_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t DecisionStrategyProto_VariableSelectionStrategy_internal_data_[] = {
    327680u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DecisionStrategyProto_DomainReductionStrategy_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t DecisionStrategyProto_DomainReductionStrategy_internal_data_[] = {
    393216u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CpSolverStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t CpSolverStatus_internal_data_[] = {
    327680u, 0u, };
// ===================================================================

class IntegerVariableProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<IntegerVariableProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_._has_bits_);
};

IntegerVariableProto::IntegerVariableProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, IntegerVariableProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.IntegerVariableProto)
}
PROTOBUF_NDEBUG_INLINE IntegerVariableProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::IntegerVariableProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        domain_{visibility, arena, from.domain_},
        _domain_cached_byte_size_{0},
        name_(arena, from.name_) {}

IntegerVariableProto::IntegerVariableProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const IntegerVariableProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, IntegerVariableProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  IntegerVariableProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.IntegerVariableProto)
}
PROTOBUF_NDEBUG_INLINE IntegerVariableProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        domain_{visibility, arena},
        _domain_cached_byte_size_{0},
        name_(arena) {}

inline void IntegerVariableProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
IntegerVariableProto::~IntegerVariableProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.IntegerVariableProto)
  SharedDtor(*this);
}
inline void IntegerVariableProto::SharedDtor(MessageLite& self) {
  IntegerVariableProto& this_ = static_cast<IntegerVariableProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL IntegerVariableProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) IntegerVariableProto(arena);
}
constexpr auto IntegerVariableProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_.domain_) +
          decltype(IntegerVariableProto::_impl_.domain_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(IntegerVariableProto), alignof(IntegerVariableProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&IntegerVariableProto::PlacementNew_,
                                 sizeof(IntegerVariableProto),
                                 alignof(IntegerVariableProto));
  }
}
constexpr auto IntegerVariableProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_IntegerVariableProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &IntegerVariableProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<IntegerVariableProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &IntegerVariableProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<IntegerVariableProto>(), &IntegerVariableProto::ByteSizeLong,
              &IntegerVariableProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_._cached_size_),
          false,
      },
      &IntegerVariableProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull IntegerVariableProto_class_data_ =
        IntegerVariableProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
IntegerVariableProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&IntegerVariableProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(IntegerVariableProto_class_data_.tc_table);
  return IntegerVariableProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 57, 2>
IntegerVariableProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    IntegerVariableProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::IntegerVariableProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int64 domain = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_.domain_)}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_.name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_.name_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated int64 domain = 2;
    {PROTOBUF_FIELD_OFFSET(IntegerVariableProto, _impl_.domain_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  // no aux_entries
  {{
    "\54\4\0\0\0\0\0\0"
    "operations_research.sat.IntegerVariableProto"
    "name"
  }},
};
PROTOBUF_NOINLINE void IntegerVariableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.IntegerVariableProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.domain_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL IntegerVariableProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const IntegerVariableProto& this_ = static_cast<const IntegerVariableProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL IntegerVariableProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const IntegerVariableProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.IntegerVariableProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_name().empty()) {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "operations_research.sat.IntegerVariableProto.name");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated int64 domain = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._domain_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_domain(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.IntegerVariableProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t IntegerVariableProto::ByteSizeLong(const MessageLite& base) {
  const IntegerVariableProto& this_ = static_cast<const IntegerVariableProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t IntegerVariableProto::ByteSizeLong() const {
  const IntegerVariableProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.IntegerVariableProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int64 domain = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_domain(), 1,
              this_._impl_._domain_cached_byte_size_);
    }
    // string name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_name());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void IntegerVariableProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<IntegerVariableProto*>(&to_msg);
  auto& from = static_cast<const IntegerVariableProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.IntegerVariableProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_domain()->MergeFrom(from._internal_domain());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
      } else {
        if (_this->_impl_.name_.IsDefault()) {
          _this->_internal_set_name("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void IntegerVariableProto::CopyFrom(const IntegerVariableProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.IntegerVariableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void IntegerVariableProto::InternalSwap(IntegerVariableProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
}

::google::protobuf::Metadata IntegerVariableProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BoolArgumentProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BoolArgumentProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_._has_bits_);
};

BoolArgumentProto::BoolArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BoolArgumentProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.BoolArgumentProto)
}
PROTOBUF_NDEBUG_INLINE BoolArgumentProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::BoolArgumentProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        literals_{visibility, arena, from.literals_},
        _literals_cached_byte_size_{0} {}

BoolArgumentProto::BoolArgumentProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BoolArgumentProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BoolArgumentProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BoolArgumentProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.BoolArgumentProto)
}
PROTOBUF_NDEBUG_INLINE BoolArgumentProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        literals_{visibility, arena},
        _literals_cached_byte_size_{0} {}

inline void BoolArgumentProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BoolArgumentProto::~BoolArgumentProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.BoolArgumentProto)
  SharedDtor(*this);
}
inline void BoolArgumentProto::SharedDtor(MessageLite& self) {
  BoolArgumentProto& this_ = static_cast<BoolArgumentProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BoolArgumentProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BoolArgumentProto(arena);
}
constexpr auto BoolArgumentProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_.literals_) +
          decltype(BoolArgumentProto::_impl_.literals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BoolArgumentProto), alignof(BoolArgumentProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BoolArgumentProto::PlacementNew_,
                                 sizeof(BoolArgumentProto),
                                 alignof(BoolArgumentProto));
  }
}
constexpr auto BoolArgumentProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BoolArgumentProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &BoolArgumentProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BoolArgumentProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BoolArgumentProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BoolArgumentProto>(), &BoolArgumentProto::ByteSizeLong,
              &BoolArgumentProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_._cached_size_),
          false,
      },
      &BoolArgumentProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BoolArgumentProto_class_data_ =
        BoolArgumentProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BoolArgumentProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BoolArgumentProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BoolArgumentProto_class_data_.tc_table);
  return BoolArgumentProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
BoolArgumentProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BoolArgumentProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 literals = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_.literals_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 literals = 1;
    {PROTOBUF_FIELD_OFFSET(BoolArgumentProto, _impl_.literals_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BoolArgumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.BoolArgumentProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.literals_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BoolArgumentProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BoolArgumentProto& this_ = static_cast<const BoolArgumentProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BoolArgumentProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BoolArgumentProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.BoolArgumentProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 literals = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._literals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_literals(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.BoolArgumentProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BoolArgumentProto::ByteSizeLong(const MessageLite& base) {
  const BoolArgumentProto& this_ = static_cast<const BoolArgumentProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BoolArgumentProto::ByteSizeLong() const {
  const BoolArgumentProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.BoolArgumentProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 literals = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_literals(), 1,
              this_._impl_._literals_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BoolArgumentProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BoolArgumentProto*>(&to_msg);
  auto& from = static_cast<const BoolArgumentProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.BoolArgumentProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_literals()->MergeFrom(from._internal_literals());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void BoolArgumentProto::CopyFrom(const BoolArgumentProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.BoolArgumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BoolArgumentProto::InternalSwap(BoolArgumentProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
}

::google::protobuf::Metadata BoolArgumentProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LinearExpressionProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LinearExpressionProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_._has_bits_);
};

LinearExpressionProto::LinearExpressionProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearExpressionProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearExpressionProto)
}
PROTOBUF_NDEBUG_INLINE LinearExpressionProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::LinearExpressionProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena, from.coeffs_},
        _coeffs_cached_byte_size_{0} {}

LinearExpressionProto::LinearExpressionProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LinearExpressionProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearExpressionProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LinearExpressionProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.offset_ = from._impl_.offset_;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearExpressionProto)
}
PROTOBUF_NDEBUG_INLINE LinearExpressionProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena},
        _coeffs_cached_byte_size_{0} {}

inline void LinearExpressionProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.offset_ = {};
}
LinearExpressionProto::~LinearExpressionProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearExpressionProto)
  SharedDtor(*this);
}
inline void LinearExpressionProto::SharedDtor(MessageLite& self) {
  LinearExpressionProto& this_ = static_cast<LinearExpressionProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LinearExpressionProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LinearExpressionProto(arena);
}
constexpr auto LinearExpressionProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.vars_) +
          decltype(LinearExpressionProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.coeffs_) +
          decltype(LinearExpressionProto::_impl_.coeffs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LinearExpressionProto), alignof(LinearExpressionProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LinearExpressionProto::PlacementNew_,
                                 sizeof(LinearExpressionProto),
                                 alignof(LinearExpressionProto));
  }
}
constexpr auto LinearExpressionProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LinearExpressionProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LinearExpressionProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LinearExpressionProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LinearExpressionProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LinearExpressionProto>(), &LinearExpressionProto::ByteSizeLong,
              &LinearExpressionProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_._cached_size_),
          false,
      },
      &LinearExpressionProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LinearExpressionProto_class_data_ =
        LinearExpressionProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LinearExpressionProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LinearExpressionProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LinearExpressionProto_class_data_.tc_table);
  return LinearExpressionProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
LinearExpressionProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LinearExpressionProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.vars_)}},
    // repeated int64 coeffs = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.coeffs_)}},
    // int64 offset = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(LinearExpressionProto, _impl_.offset_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.offset_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int64 coeffs = 2;
    {PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.coeffs_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // int64 offset = 3;
    {PROTOBUF_FIELD_OFFSET(LinearExpressionProto, _impl_.offset_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LinearExpressionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearExpressionProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.coeffs_.Clear();
    }
  }
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LinearExpressionProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LinearExpressionProto& this_ = static_cast<const LinearExpressionProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LinearExpressionProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LinearExpressionProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearExpressionProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated int64 coeffs = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._coeffs_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_coeffs(), byte_size, target);
      }
    }
  }

  // int64 offset = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_offset() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<3>(
              stream, this_._internal_offset(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearExpressionProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LinearExpressionProto::ByteSizeLong(const MessageLite& base) {
  const LinearExpressionProto& this_ = static_cast<const LinearExpressionProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LinearExpressionProto::ByteSizeLong() const {
  const LinearExpressionProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearExpressionProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated int64 coeffs = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_coeffs(), 1,
              this_._impl_._coeffs_cached_byte_size_);
    }
    // int64 offset = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_offset());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LinearExpressionProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LinearExpressionProto*>(&to_msg);
  auto& from = static_cast<const LinearExpressionProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearExpressionProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_coeffs()->MergeFrom(from._internal_coeffs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_offset() != 0) {
        _this->_impl_.offset_ = from._impl_.offset_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void LinearExpressionProto::CopyFrom(const LinearExpressionProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearExpressionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LinearExpressionProto::InternalSwap(LinearExpressionProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  swap(_impl_.offset_, other->_impl_.offset_);
}

::google::protobuf::Metadata LinearExpressionProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LinearArgumentProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LinearArgumentProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_._has_bits_);
};

LinearArgumentProto::LinearArgumentProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearArgumentProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearArgumentProto)
}
PROTOBUF_NDEBUG_INLINE LinearArgumentProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::LinearArgumentProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

LinearArgumentProto::LinearArgumentProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LinearArgumentProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearArgumentProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LinearArgumentProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.target_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.target_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearArgumentProto)
}
PROTOBUF_NDEBUG_INLINE LinearArgumentProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        exprs_{visibility, arena} {}

inline void LinearArgumentProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.target_ = {};
}
LinearArgumentProto::~LinearArgumentProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearArgumentProto)
  SharedDtor(*this);
}
inline void LinearArgumentProto::SharedDtor(MessageLite& self) {
  LinearArgumentProto& this_ = static_cast<LinearArgumentProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.target_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LinearArgumentProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LinearArgumentProto(arena);
}
constexpr auto LinearArgumentProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_.exprs_) +
          decltype(LinearArgumentProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LinearArgumentProto), alignof(LinearArgumentProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LinearArgumentProto::PlacementNew_,
                                 sizeof(LinearArgumentProto),
                                 alignof(LinearArgumentProto));
  }
}
constexpr auto LinearArgumentProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LinearArgumentProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LinearArgumentProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LinearArgumentProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LinearArgumentProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LinearArgumentProto>(), &LinearArgumentProto::ByteSizeLong,
              &LinearArgumentProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_._cached_size_),
          false,
      },
      &LinearArgumentProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LinearArgumentProto_class_data_ =
        LinearArgumentProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LinearArgumentProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LinearArgumentProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LinearArgumentProto_class_data_.tc_table);
  return LinearArgumentProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
LinearArgumentProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    LinearArgumentProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::LinearArgumentProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 1,
      PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_.exprs_)}},
    // .operations_research.sat.LinearExpressionProto target = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_.target_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .operations_research.sat.LinearExpressionProto target = 1;
    {PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_.target_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
    {PROTOBUF_FIELD_OFFSET(LinearArgumentProto, _impl_.exprs_), _Internal::kHasBitsOffset + 0, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void LinearArgumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearArgumentProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.exprs_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.target_ != nullptr);
      _impl_.target_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LinearArgumentProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LinearArgumentProto& this_ = static_cast<const LinearArgumentProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LinearArgumentProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LinearArgumentProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearArgumentProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .operations_research.sat.LinearExpressionProto target = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.target_, this_._impl_.target_->GetCachedSize(), target,
        stream);
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearArgumentProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LinearArgumentProto::ByteSizeLong(const MessageLite& base) {
  const LinearArgumentProto& this_ = static_cast<const LinearArgumentProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LinearArgumentProto::ByteSizeLong() const {
  const LinearArgumentProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearArgumentProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .operations_research.sat.LinearExpressionProto target = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.target_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LinearArgumentProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LinearArgumentProto*>(&to_msg);
  auto& from = static_cast<const LinearArgumentProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearArgumentProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_exprs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.target_ != nullptr);
      if (_this->_impl_.target_ == nullptr) {
        _this->_impl_.target_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.target_);
      } else {
        _this->_impl_.target_->MergeFrom(*from._impl_.target_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void LinearArgumentProto::CopyFrom(const LinearArgumentProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearArgumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LinearArgumentProto::InternalSwap(LinearArgumentProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  swap(_impl_.target_, other->_impl_.target_);
}

::google::protobuf::Metadata LinearArgumentProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AllDifferentConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AllDifferentConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_._has_bits_);
};

AllDifferentConstraintProto::AllDifferentConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AllDifferentConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.AllDifferentConstraintProto)
}
PROTOBUF_NDEBUG_INLINE AllDifferentConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::AllDifferentConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

AllDifferentConstraintProto::AllDifferentConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AllDifferentConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AllDifferentConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AllDifferentConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.AllDifferentConstraintProto)
}
PROTOBUF_NDEBUG_INLINE AllDifferentConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        exprs_{visibility, arena} {}

inline void AllDifferentConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AllDifferentConstraintProto::~AllDifferentConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.AllDifferentConstraintProto)
  SharedDtor(*this);
}
inline void AllDifferentConstraintProto::SharedDtor(MessageLite& self) {
  AllDifferentConstraintProto& this_ = static_cast<AllDifferentConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AllDifferentConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AllDifferentConstraintProto(arena);
}
constexpr auto AllDifferentConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_.exprs_) +
          decltype(AllDifferentConstraintProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(AllDifferentConstraintProto), alignof(AllDifferentConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AllDifferentConstraintProto::PlacementNew_,
                                 sizeof(AllDifferentConstraintProto),
                                 alignof(AllDifferentConstraintProto));
  }
}
constexpr auto AllDifferentConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AllDifferentConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AllDifferentConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AllDifferentConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AllDifferentConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AllDifferentConstraintProto>(), &AllDifferentConstraintProto::ByteSizeLong,
              &AllDifferentConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_._cached_size_),
          false,
      },
      &AllDifferentConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AllDifferentConstraintProto_class_data_ =
        AllDifferentConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AllDifferentConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AllDifferentConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AllDifferentConstraintProto_class_data_.tc_table);
  return AllDifferentConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
AllDifferentConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AllDifferentConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::AllDifferentConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_.exprs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    {PROTOBUF_FIELD_OFFSET(AllDifferentConstraintProto, _impl_.exprs_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void AllDifferentConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.AllDifferentConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.exprs_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AllDifferentConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AllDifferentConstraintProto& this_ = static_cast<const AllDifferentConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AllDifferentConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AllDifferentConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.AllDifferentConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.AllDifferentConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AllDifferentConstraintProto::ByteSizeLong(const MessageLite& base) {
  const AllDifferentConstraintProto& this_ = static_cast<const AllDifferentConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AllDifferentConstraintProto::ByteSizeLong() const {
  const AllDifferentConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.AllDifferentConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AllDifferentConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AllDifferentConstraintProto*>(&to_msg);
  auto& from = static_cast<const AllDifferentConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.AllDifferentConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
        ::google::protobuf::MessageLite::internal_visibility(), arena,
        from._internal_exprs());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AllDifferentConstraintProto::CopyFrom(const AllDifferentConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.AllDifferentConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AllDifferentConstraintProto::InternalSwap(AllDifferentConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
}

::google::protobuf::Metadata AllDifferentConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LinearConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LinearConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_._has_bits_);
};

LinearConstraintProto::LinearConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearConstraintProto)
}
PROTOBUF_NDEBUG_INLINE LinearConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::LinearConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena, from.coeffs_},
        _coeffs_cached_byte_size_{0},
        domain_{visibility, arena, from.domain_},
        _domain_cached_byte_size_{0} {}

LinearConstraintProto::LinearConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LinearConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LinearConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LinearConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearConstraintProto)
}
PROTOBUF_NDEBUG_INLINE LinearConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena},
        _coeffs_cached_byte_size_{0},
        domain_{visibility, arena},
        _domain_cached_byte_size_{0} {}

inline void LinearConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
LinearConstraintProto::~LinearConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearConstraintProto)
  SharedDtor(*this);
}
inline void LinearConstraintProto::SharedDtor(MessageLite& self) {
  LinearConstraintProto& this_ = static_cast<LinearConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LinearConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LinearConstraintProto(arena);
}
constexpr auto LinearConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.vars_) +
          decltype(LinearConstraintProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.coeffs_) +
          decltype(LinearConstraintProto::_impl_.coeffs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.domain_) +
          decltype(LinearConstraintProto::_impl_.domain_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(LinearConstraintProto), alignof(LinearConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&LinearConstraintProto::PlacementNew_,
                                 sizeof(LinearConstraintProto),
                                 alignof(LinearConstraintProto));
  }
}
constexpr auto LinearConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LinearConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LinearConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LinearConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LinearConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LinearConstraintProto>(), &LinearConstraintProto::ByteSizeLong,
              &LinearConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_._cached_size_),
          false,
      },
      &LinearConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LinearConstraintProto_class_data_ =
        LinearConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LinearConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LinearConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LinearConstraintProto_class_data_.tc_table);
  return LinearConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
LinearConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LinearConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::LinearConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.vars_)}},
    // repeated int64 coeffs = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.coeffs_)}},
    // repeated int64 domain = 3;
    {::_pbi::TcParser::FastV64P1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.domain_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int64 coeffs = 2;
    {PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.coeffs_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 domain = 3;
    {PROTOBUF_FIELD_OFFSET(LinearConstraintProto, _impl_.domain_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void LinearConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.coeffs_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.domain_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LinearConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LinearConstraintProto& this_ = static_cast<const LinearConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LinearConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LinearConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated int64 coeffs = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._coeffs_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_coeffs(), byte_size, target);
      }
    }
  }

  // repeated int64 domain = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._domain_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            3, this_._internal_domain(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LinearConstraintProto::ByteSizeLong(const MessageLite& base) {
  const LinearConstraintProto& this_ = static_cast<const LinearConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LinearConstraintProto::ByteSizeLong() const {
  const LinearConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated int64 coeffs = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_coeffs(), 1,
              this_._impl_._coeffs_cached_byte_size_);
    }
    // repeated int64 domain = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_domain(), 1,
              this_._impl_._domain_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LinearConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<LinearConstraintProto*>(&to_msg);
  auto& from = static_cast<const LinearConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_coeffs()->MergeFrom(from._internal_coeffs());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_domain()->MergeFrom(from._internal_domain());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void LinearConstraintProto::CopyFrom(const LinearConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LinearConstraintProto::InternalSwap(LinearConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
}

::google::protobuf::Metadata LinearConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ElementConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ElementConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_._has_bits_);
};

ElementConstraintProto::ElementConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ElementConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ElementConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ElementConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::ElementConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

ElementConstraintProto::ElementConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ElementConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ElementConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ElementConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.linear_index_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.linear_index_)
                : nullptr;
  _impl_.linear_target_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.linear_target_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, index_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, index_),
           offsetof(Impl_, target_) -
               offsetof(Impl_, index_) +
               sizeof(Impl_::target_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ElementConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ElementConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        exprs_{visibility, arena} {}

inline void ElementConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, linear_index_),
           0,
           offsetof(Impl_, target_) -
               offsetof(Impl_, linear_index_) +
               sizeof(Impl_::target_));
}
ElementConstraintProto::~ElementConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ElementConstraintProto)
  SharedDtor(*this);
}
inline void ElementConstraintProto::SharedDtor(MessageLite& self) {
  ElementConstraintProto& this_ = static_cast<ElementConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.linear_index_;
  delete this_._impl_.linear_target_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ElementConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ElementConstraintProto(arena);
}
constexpr auto ElementConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.vars_) +
          decltype(ElementConstraintProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.exprs_) +
          decltype(ElementConstraintProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ElementConstraintProto), alignof(ElementConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ElementConstraintProto::PlacementNew_,
                                 sizeof(ElementConstraintProto),
                                 alignof(ElementConstraintProto));
  }
}
constexpr auto ElementConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ElementConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ElementConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ElementConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ElementConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ElementConstraintProto>(), &ElementConstraintProto::ByteSizeLong,
              &ElementConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_._cached_size_),
          false,
      },
      &ElementConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ElementConstraintProto_class_data_ =
        ElementConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ElementConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ElementConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ElementConstraintProto_class_data_.tc_table);
  return ElementConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 0, 2>
ElementConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ElementConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::ElementConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 index = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ElementConstraintProto, _impl_.index_), 4>(),
     {8, 4, 0,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.index_)}},
    // int32 target = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ElementConstraintProto, _impl_.target_), 5>(),
     {16, 5, 0,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.target_)}},
    // repeated int32 vars = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.vars_)}},
    // .operations_research.sat.LinearExpressionProto linear_index = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.linear_index_)}},
    // .operations_research.sat.LinearExpressionProto linear_target = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 1,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.linear_target_)}},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 1, 2,
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.exprs_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 index = 1;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.index_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 target = 2;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.target_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated int32 vars = 3;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // .operations_research.sat.LinearExpressionProto linear_index = 4;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.linear_index_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearExpressionProto linear_target = 5;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.linear_target_), _Internal::kHasBitsOffset + 3, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 6;
    {PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.exprs_), _Internal::kHasBitsOffset + 1, 2, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ElementConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ElementConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.exprs_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.linear_index_ != nullptr);
      _impl_.linear_index_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.linear_target_ != nullptr);
      _impl_.linear_target_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000030U)) {
    ::memset(&_impl_.index_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.target_) -
        reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.target_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ElementConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ElementConstraintProto& this_ = static_cast<const ElementConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ElementConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ElementConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ElementConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int32 index = 1;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_index() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_index(), target);
    }
  }

  // int32 target = 2;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_target() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_target(), target);
    }
  }

  // repeated int32 vars = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            3, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // .operations_research.sat.LinearExpressionProto linear_index = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.linear_index_, this_._impl_.linear_index_->GetCachedSize(), target,
        stream);
  }

  // .operations_research.sat.LinearExpressionProto linear_target = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.linear_target_, this_._impl_.linear_target_->GetCachedSize(), target,
        stream);
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ElementConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ElementConstraintProto::ByteSizeLong(const MessageLite& base) {
  const ElementConstraintProto& this_ = static_cast<const ElementConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ElementConstraintProto::ByteSizeLong() const {
  const ElementConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ElementConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // repeated int32 vars = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto exprs = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .operations_research.sat.LinearExpressionProto linear_index = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.linear_index_);
    }
    // .operations_research.sat.LinearExpressionProto linear_target = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.linear_target_);
    }
    // int32 index = 1;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_index() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_index());
      }
    }
    // int32 target = 2;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_target() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_target());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ElementConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ElementConstraintProto*>(&to_msg);
  auto& from = static_cast<const ElementConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ElementConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_exprs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.linear_index_ != nullptr);
      if (_this->_impl_.linear_index_ == nullptr) {
        _this->_impl_.linear_index_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.linear_index_);
      } else {
        _this->_impl_.linear_index_->MergeFrom(*from._impl_.linear_index_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.linear_target_ != nullptr);
      if (_this->_impl_.linear_target_ == nullptr) {
        _this->_impl_.linear_target_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.linear_target_);
      } else {
        _this->_impl_.linear_target_->MergeFrom(*from._impl_.linear_target_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_index() != 0) {
        _this->_impl_.index_ = from._impl_.index_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_target() != 0) {
        _this->_impl_.target_ = from._impl_.target_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ElementConstraintProto::CopyFrom(const ElementConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ElementConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ElementConstraintProto::InternalSwap(ElementConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.target_)
      + sizeof(ElementConstraintProto::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.linear_index_)>(
          reinterpret_cast<char*>(&_impl_.linear_index_),
          reinterpret_cast<char*>(&other->_impl_.linear_index_));
}

::google::protobuf::Metadata ElementConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class IntervalConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<IntervalConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_._has_bits_);
};

IntervalConstraintProto::IntervalConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, IntervalConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.IntervalConstraintProto)
}
PROTOBUF_NDEBUG_INLINE IntervalConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::IntervalConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

IntervalConstraintProto::IntervalConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const IntervalConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, IntervalConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  IntervalConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.start_ = (CheckHasBit(cached_has_bits, 0x00000001U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.start_)
                : nullptr;
  _impl_.end_ = (CheckHasBit(cached_has_bits, 0x00000002U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.end_)
                : nullptr;
  _impl_.size_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.size_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.IntervalConstraintProto)
}
PROTOBUF_NDEBUG_INLINE IntervalConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void IntervalConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, start_),
           0,
           offsetof(Impl_, size_) -
               offsetof(Impl_, start_) +
               sizeof(Impl_::size_));
}
IntervalConstraintProto::~IntervalConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.IntervalConstraintProto)
  SharedDtor(*this);
}
inline void IntervalConstraintProto::SharedDtor(MessageLite& self) {
  IntervalConstraintProto& this_ = static_cast<IntervalConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.start_;
  delete this_._impl_.end_;
  delete this_._impl_.size_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL IntervalConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) IntervalConstraintProto(arena);
}
constexpr auto IntervalConstraintProto::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(IntervalConstraintProto),
                                            alignof(IntervalConstraintProto));
}
constexpr auto IntervalConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_IntervalConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &IntervalConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<IntervalConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &IntervalConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<IntervalConstraintProto>(), &IntervalConstraintProto::ByteSizeLong,
              &IntervalConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_._cached_size_),
          false,
      },
      &IntervalConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull IntervalConstraintProto_class_data_ =
        IntervalConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
IntervalConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&IntervalConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(IntervalConstraintProto_class_data_.tc_table);
  return IntervalConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2>
IntervalConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    6, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967239,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    IntervalConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::IntervalConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .operations_research.sat.LinearExpressionProto start = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0,
      PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.start_)}},
    // .operations_research.sat.LinearExpressionProto end = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1,
      PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.end_)}},
    // .operations_research.sat.LinearExpressionProto size = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 2, 2,
      PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.size_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .operations_research.sat.LinearExpressionProto start = 4;
    {PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.start_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearExpressionProto end = 5;
    {PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.end_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearExpressionProto size = 6;
    {PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.size_), _Internal::kHasBitsOffset + 2, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void IntervalConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.IntervalConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.size_ != nullptr);
      _impl_.size_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL IntervalConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const IntervalConstraintProto& this_ = static_cast<const IntervalConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL IntervalConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const IntervalConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.IntervalConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .operations_research.sat.LinearExpressionProto start = 4;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.start_, this_._impl_.start_->GetCachedSize(), target,
        stream);
  }

  // .operations_research.sat.LinearExpressionProto end = 5;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.end_, this_._impl_.end_->GetCachedSize(), target,
        stream);
  }

  // .operations_research.sat.LinearExpressionProto size = 6;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.size_, this_._impl_.size_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.IntervalConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t IntervalConstraintProto::ByteSizeLong(const MessageLite& base) {
  const IntervalConstraintProto& this_ = static_cast<const IntervalConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t IntervalConstraintProto::ByteSizeLong() const {
  const IntervalConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.IntervalConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // .operations_research.sat.LinearExpressionProto start = 4;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.start_);
    }
    // .operations_research.sat.LinearExpressionProto end = 5;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.end_);
    }
    // .operations_research.sat.LinearExpressionProto size = 6;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void IntervalConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<IntervalConstraintProto*>(&to_msg);
  auto& from = static_cast<const IntervalConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.IntervalConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      ABSL_DCHECK(from._impl_.start_ != nullptr);
      if (_this->_impl_.start_ == nullptr) {
        _this->_impl_.start_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.start_);
      } else {
        _this->_impl_.start_->MergeFrom(*from._impl_.start_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      ABSL_DCHECK(from._impl_.end_ != nullptr);
      if (_this->_impl_.end_ == nullptr) {
        _this->_impl_.end_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.end_);
      } else {
        _this->_impl_.end_->MergeFrom(*from._impl_.end_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.size_ != nullptr);
      if (_this->_impl_.size_ == nullptr) {
        _this->_impl_.size_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.size_);
      } else {
        _this->_impl_.size_->MergeFrom(*from._impl_.size_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void IntervalConstraintProto::CopyFrom(const IntervalConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.IntervalConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void IntervalConstraintProto::InternalSwap(IntervalConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.size_)
      + sizeof(IntervalConstraintProto::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::google::protobuf::Metadata IntervalConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NoOverlapConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NoOverlapConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_._has_bits_);
};

NoOverlapConstraintProto::NoOverlapConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NoOverlapConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.NoOverlapConstraintProto)
}
PROTOBUF_NDEBUG_INLINE NoOverlapConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::NoOverlapConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        intervals_{visibility, arena, from.intervals_},
        _intervals_cached_byte_size_{0} {}

NoOverlapConstraintProto::NoOverlapConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NoOverlapConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NoOverlapConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NoOverlapConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.NoOverlapConstraintProto)
}
PROTOBUF_NDEBUG_INLINE NoOverlapConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        intervals_{visibility, arena},
        _intervals_cached_byte_size_{0} {}

inline void NoOverlapConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
NoOverlapConstraintProto::~NoOverlapConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.NoOverlapConstraintProto)
  SharedDtor(*this);
}
inline void NoOverlapConstraintProto::SharedDtor(MessageLite& self) {
  NoOverlapConstraintProto& this_ = static_cast<NoOverlapConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NoOverlapConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NoOverlapConstraintProto(arena);
}
constexpr auto NoOverlapConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_.intervals_) +
          decltype(NoOverlapConstraintProto::_impl_.intervals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(NoOverlapConstraintProto), alignof(NoOverlapConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&NoOverlapConstraintProto::PlacementNew_,
                                 sizeof(NoOverlapConstraintProto),
                                 alignof(NoOverlapConstraintProto));
  }
}
constexpr auto NoOverlapConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NoOverlapConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NoOverlapConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NoOverlapConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NoOverlapConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NoOverlapConstraintProto>(), &NoOverlapConstraintProto::ByteSizeLong,
              &NoOverlapConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_._cached_size_),
          false,
      },
      &NoOverlapConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NoOverlapConstraintProto_class_data_ =
        NoOverlapConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NoOverlapConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NoOverlapConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NoOverlapConstraintProto_class_data_.tc_table);
  return NoOverlapConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
NoOverlapConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    NoOverlapConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::NoOverlapConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 intervals = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_.intervals_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 intervals = 1;
    {PROTOBUF_FIELD_OFFSET(NoOverlapConstraintProto, _impl_.intervals_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void NoOverlapConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.NoOverlapConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.intervals_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NoOverlapConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NoOverlapConstraintProto& this_ = static_cast<const NoOverlapConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NoOverlapConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NoOverlapConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.NoOverlapConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 intervals = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._intervals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_intervals(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.NoOverlapConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NoOverlapConstraintProto::ByteSizeLong(const MessageLite& base) {
  const NoOverlapConstraintProto& this_ = static_cast<const NoOverlapConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NoOverlapConstraintProto::ByteSizeLong() const {
  const NoOverlapConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.NoOverlapConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 intervals = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_intervals(), 1,
              this_._impl_._intervals_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NoOverlapConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<NoOverlapConstraintProto*>(&to_msg);
  auto& from = static_cast<const NoOverlapConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.NoOverlapConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_intervals()->MergeFrom(from._internal_intervals());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void NoOverlapConstraintProto::CopyFrom(const NoOverlapConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.NoOverlapConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NoOverlapConstraintProto::InternalSwap(NoOverlapConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.intervals_.InternalSwap(&other->_impl_.intervals_);
}

::google::protobuf::Metadata NoOverlapConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NoOverlap2DConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NoOverlap2DConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_._has_bits_);
};

NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NoOverlap2DConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.NoOverlap2DConstraintProto)
}
PROTOBUF_NDEBUG_INLINE NoOverlap2DConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::NoOverlap2DConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        x_intervals_{visibility, arena, from.x_intervals_},
        _x_intervals_cached_byte_size_{0},
        y_intervals_{visibility, arena, from.y_intervals_},
        _y_intervals_cached_byte_size_{0} {}

NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NoOverlap2DConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NoOverlap2DConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NoOverlap2DConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.NoOverlap2DConstraintProto)
}
PROTOBUF_NDEBUG_INLINE NoOverlap2DConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        x_intervals_{visibility, arena},
        _x_intervals_cached_byte_size_{0},
        y_intervals_{visibility, arena},
        _y_intervals_cached_byte_size_{0} {}

inline void NoOverlap2DConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
NoOverlap2DConstraintProto::~NoOverlap2DConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.NoOverlap2DConstraintProto)
  SharedDtor(*this);
}
inline void NoOverlap2DConstraintProto::SharedDtor(MessageLite& self) {
  NoOverlap2DConstraintProto& this_ = static_cast<NoOverlap2DConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NoOverlap2DConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NoOverlap2DConstraintProto(arena);
}
constexpr auto NoOverlap2DConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.x_intervals_) +
          decltype(NoOverlap2DConstraintProto::_impl_.x_intervals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.y_intervals_) +
          decltype(NoOverlap2DConstraintProto::_impl_.y_intervals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(NoOverlap2DConstraintProto), alignof(NoOverlap2DConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&NoOverlap2DConstraintProto::PlacementNew_,
                                 sizeof(NoOverlap2DConstraintProto),
                                 alignof(NoOverlap2DConstraintProto));
  }
}
constexpr auto NoOverlap2DConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NoOverlap2DConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NoOverlap2DConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NoOverlap2DConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NoOverlap2DConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NoOverlap2DConstraintProto>(), &NoOverlap2DConstraintProto::ByteSizeLong,
              &NoOverlap2DConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_._cached_size_),
          false,
      },
      &NoOverlap2DConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NoOverlap2DConstraintProto_class_data_ =
        NoOverlap2DConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NoOverlap2DConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NoOverlap2DConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NoOverlap2DConstraintProto_class_data_.tc_table);
  return NoOverlap2DConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
NoOverlap2DConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    NoOverlap2DConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::NoOverlap2DConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 y_intervals = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.y_intervals_)}},
    // repeated int32 x_intervals = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.x_intervals_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 x_intervals = 1;
    {PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.x_intervals_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 y_intervals = 2;
    {PROTOBUF_FIELD_OFFSET(NoOverlap2DConstraintProto, _impl_.y_intervals_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void NoOverlap2DConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.NoOverlap2DConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.x_intervals_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.y_intervals_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NoOverlap2DConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NoOverlap2DConstraintProto& this_ = static_cast<const NoOverlap2DConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NoOverlap2DConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NoOverlap2DConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.NoOverlap2DConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 x_intervals = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._x_intervals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_x_intervals(), byte_size, target);
      }
    }
  }

  // repeated int32 y_intervals = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._y_intervals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_y_intervals(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.NoOverlap2DConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NoOverlap2DConstraintProto::ByteSizeLong(const MessageLite& base) {
  const NoOverlap2DConstraintProto& this_ = static_cast<const NoOverlap2DConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NoOverlap2DConstraintProto::ByteSizeLong() const {
  const NoOverlap2DConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.NoOverlap2DConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int32 x_intervals = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_x_intervals(), 1,
              this_._impl_._x_intervals_cached_byte_size_);
    }
    // repeated int32 y_intervals = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_y_intervals(), 1,
              this_._impl_._y_intervals_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NoOverlap2DConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<NoOverlap2DConstraintProto*>(&to_msg);
  auto& from = static_cast<const NoOverlap2DConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.NoOverlap2DConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_x_intervals()->MergeFrom(from._internal_x_intervals());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_y_intervals()->MergeFrom(from._internal_y_intervals());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void NoOverlap2DConstraintProto::CopyFrom(const NoOverlap2DConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.NoOverlap2DConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NoOverlap2DConstraintProto::InternalSwap(NoOverlap2DConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.x_intervals_.InternalSwap(&other->_impl_.x_intervals_);
  _impl_.y_intervals_.InternalSwap(&other->_impl_.y_intervals_);
}

::google::protobuf::Metadata NoOverlap2DConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CumulativeConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CumulativeConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_._has_bits_);
};

CumulativeConstraintProto::CumulativeConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CumulativeConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CumulativeConstraintProto)
}
PROTOBUF_NDEBUG_INLINE CumulativeConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CumulativeConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        intervals_{visibility, arena, from.intervals_},
        _intervals_cached_byte_size_{0},
        demands_{visibility, arena, from.demands_} {}

CumulativeConstraintProto::CumulativeConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CumulativeConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CumulativeConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CumulativeConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.capacity_ = (CheckHasBit(cached_has_bits, 0x00000004U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.capacity_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CumulativeConstraintProto)
}
PROTOBUF_NDEBUG_INLINE CumulativeConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        intervals_{visibility, arena},
        _intervals_cached_byte_size_{0},
        demands_{visibility, arena} {}

inline void CumulativeConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.capacity_ = {};
}
CumulativeConstraintProto::~CumulativeConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CumulativeConstraintProto)
  SharedDtor(*this);
}
inline void CumulativeConstraintProto::SharedDtor(MessageLite& self) {
  CumulativeConstraintProto& this_ = static_cast<CumulativeConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.capacity_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CumulativeConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CumulativeConstraintProto(arena);
}
constexpr auto CumulativeConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.intervals_) +
          decltype(CumulativeConstraintProto::_impl_.intervals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.demands_) +
          decltype(CumulativeConstraintProto::_impl_.demands_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CumulativeConstraintProto), alignof(CumulativeConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CumulativeConstraintProto::PlacementNew_,
                                 sizeof(CumulativeConstraintProto),
                                 alignof(CumulativeConstraintProto));
  }
}
constexpr auto CumulativeConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CumulativeConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CumulativeConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CumulativeConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CumulativeConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CumulativeConstraintProto>(), &CumulativeConstraintProto::ByteSizeLong,
              &CumulativeConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_._cached_size_),
          false,
      },
      &CumulativeConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CumulativeConstraintProto_class_data_ =
        CumulativeConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CumulativeConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CumulativeConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CumulativeConstraintProto_class_data_.tc_table);
  return CumulativeConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2>
CumulativeConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CumulativeConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CumulativeConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .operations_research.sat.LinearExpressionProto capacity = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 2, 0,
      PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.capacity_)}},
    // repeated int32 intervals = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.intervals_)}},
    // repeated .operations_research.sat.LinearExpressionProto demands = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.demands_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .operations_research.sat.LinearExpressionProto capacity = 1;
    {PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.capacity_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 intervals = 2;
    {PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.intervals_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated .operations_research.sat.LinearExpressionProto demands = 3;
    {PROTOBUF_FIELD_OFFSET(CumulativeConstraintProto, _impl_.demands_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void CumulativeConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CumulativeConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.intervals_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.demands_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(_impl_.capacity_ != nullptr);
      _impl_.capacity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CumulativeConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CumulativeConstraintProto& this_ = static_cast<const CumulativeConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CumulativeConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CumulativeConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CumulativeConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .operations_research.sat.LinearExpressionProto capacity = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, *this_._impl_.capacity_, this_._impl_.capacity_->GetCachedSize(), target,
        stream);
  }

  // repeated int32 intervals = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._intervals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_intervals(), byte_size, target);
      }
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto demands = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_demands_size());
         i < n; i++) {
      const auto& repfield = this_._internal_demands().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CumulativeConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CumulativeConstraintProto::ByteSizeLong(const MessageLite& base) {
  const CumulativeConstraintProto& this_ = static_cast<const CumulativeConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CumulativeConstraintProto::ByteSizeLong() const {
  const CumulativeConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CumulativeConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated int32 intervals = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_intervals(), 1,
              this_._impl_._intervals_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto demands = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_demands_size();
      for (const auto& msg : this_._internal_demands()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .operations_research.sat.LinearExpressionProto capacity = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.capacity_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CumulativeConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CumulativeConstraintProto*>(&to_msg);
  auto& from = static_cast<const CumulativeConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CumulativeConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_intervals()->MergeFrom(from._internal_intervals());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_demands()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_demands());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      ABSL_DCHECK(from._impl_.capacity_ != nullptr);
      if (_this->_impl_.capacity_ == nullptr) {
        _this->_impl_.capacity_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.capacity_);
      } else {
        _this->_impl_.capacity_->MergeFrom(*from._impl_.capacity_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CumulativeConstraintProto::CopyFrom(const CumulativeConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CumulativeConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CumulativeConstraintProto::InternalSwap(CumulativeConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.intervals_.InternalSwap(&other->_impl_.intervals_);
  _impl_.demands_.InternalSwap(&other->_impl_.demands_);
  swap(_impl_.capacity_, other->_impl_.capacity_);
}

::google::protobuf::Metadata CumulativeConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ReservoirConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ReservoirConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_._has_bits_);
};

ReservoirConstraintProto::ReservoirConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ReservoirConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ReservoirConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ReservoirConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::ReservoirConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        time_exprs_{visibility, arena, from.time_exprs_},
        active_literals_{visibility, arena, from.active_literals_},
        _active_literals_cached_byte_size_{0},
        level_changes_{visibility, arena, from.level_changes_} {}

ReservoirConstraintProto::ReservoirConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ReservoirConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ReservoirConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ReservoirConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, min_level_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, min_level_),
           offsetof(Impl_, max_level_) -
               offsetof(Impl_, min_level_) +
               sizeof(Impl_::max_level_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ReservoirConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ReservoirConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        time_exprs_{visibility, arena},
        active_literals_{visibility, arena},
        _active_literals_cached_byte_size_{0},
        level_changes_{visibility, arena} {}

inline void ReservoirConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, min_level_),
           0,
           offsetof(Impl_, max_level_) -
               offsetof(Impl_, min_level_) +
               sizeof(Impl_::max_level_));
}
ReservoirConstraintProto::~ReservoirConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ReservoirConstraintProto)
  SharedDtor(*this);
}
inline void ReservoirConstraintProto::SharedDtor(MessageLite& self) {
  ReservoirConstraintProto& this_ = static_cast<ReservoirConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ReservoirConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ReservoirConstraintProto(arena);
}
constexpr auto ReservoirConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.time_exprs_) +
          decltype(ReservoirConstraintProto::_impl_.time_exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.level_changes_) +
          decltype(ReservoirConstraintProto::_impl_.level_changes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.active_literals_) +
          decltype(ReservoirConstraintProto::_impl_.active_literals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ReservoirConstraintProto), alignof(ReservoirConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ReservoirConstraintProto::PlacementNew_,
                                 sizeof(ReservoirConstraintProto),
                                 alignof(ReservoirConstraintProto));
  }
}
constexpr auto ReservoirConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ReservoirConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ReservoirConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ReservoirConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ReservoirConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ReservoirConstraintProto>(), &ReservoirConstraintProto::ByteSizeLong,
              &ReservoirConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_._cached_size_),
          false,
      },
      &ReservoirConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ReservoirConstraintProto_class_data_ =
        ReservoirConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ReservoirConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ReservoirConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ReservoirConstraintProto_class_data_.tc_table);
  return ReservoirConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2>
ReservoirConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967240,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ReservoirConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::ReservoirConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 min_level = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(ReservoirConstraintProto, _impl_.min_level_), 3>(),
     {8, 3, 0,
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.min_level_)}},
    // int64 max_level = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(ReservoirConstraintProto, _impl_.max_level_), 4>(),
     {16, 4, 0,
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.max_level_)}},
    // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.time_exprs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 active_literals = 5;
    {::_pbi::TcParser::FastV32P1,
     {42, 1, 0,
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.active_literals_)}},
    // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 2, 1,
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.level_changes_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 min_level = 1;
    {PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.min_level_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 max_level = 2;
    {PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.max_level_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
    {PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.time_exprs_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 active_literals = 5;
    {PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.active_literals_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
    {PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.level_changes_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ReservoirConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ReservoirConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.time_exprs_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.active_literals_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.level_changes_.Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000018U)) {
    ::memset(&_impl_.min_level_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_level_) -
        reinterpret_cast<char*>(&_impl_.min_level_)) + sizeof(_impl_.max_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ReservoirConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ReservoirConstraintProto& this_ = static_cast<const ReservoirConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ReservoirConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ReservoirConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ReservoirConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int64 min_level = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_min_level() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<1>(
              stream, this_._internal_min_level(), target);
    }
  }

  // int64 max_level = 2;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (this_._internal_max_level() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
              stream, this_._internal_max_level(), target);
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_time_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_time_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated int32 active_literals = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._active_literals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            5, this_._internal_active_literals(), byte_size, target);
      }
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_level_changes_size());
         i < n; i++) {
      const auto& repfield = this_._internal_level_changes().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ReservoirConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ReservoirConstraintProto::ByteSizeLong(const MessageLite& base) {
  const ReservoirConstraintProto& this_ = static_cast<const ReservoirConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ReservoirConstraintProto::ByteSizeLong() const {
  const ReservoirConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ReservoirConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_time_exprs_size();
      for (const auto& msg : this_._internal_time_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated int32 active_literals = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_active_literals(), 1,
              this_._impl_._active_literals_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_level_changes_size();
      for (const auto& msg : this_._internal_level_changes()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // int64 min_level = 1;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_min_level() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_min_level());
      }
    }
    // int64 max_level = 2;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (this_._internal_max_level() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_max_level());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ReservoirConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ReservoirConstraintProto*>(&to_msg);
  auto& from = static_cast<const ReservoirConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ReservoirConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_time_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_time_exprs());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_active_literals()->MergeFrom(from._internal_active_literals());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_level_changes()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_level_changes());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_min_level() != 0) {
        _this->_impl_.min_level_ = from._impl_.min_level_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (from._internal_max_level() != 0) {
        _this->_impl_.max_level_ = from._impl_.max_level_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ReservoirConstraintProto::CopyFrom(const ReservoirConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ReservoirConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ReservoirConstraintProto::InternalSwap(ReservoirConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.time_exprs_.InternalSwap(&other->_impl_.time_exprs_);
  _impl_.active_literals_.InternalSwap(&other->_impl_.active_literals_);
  _impl_.level_changes_.InternalSwap(&other->_impl_.level_changes_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.max_level_)
      + sizeof(ReservoirConstraintProto::_impl_.max_level_)
      - PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.min_level_)>(
          reinterpret_cast<char*>(&_impl_.min_level_),
          reinterpret_cast<char*>(&other->_impl_.min_level_));
}

::google::protobuf::Metadata ReservoirConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CircuitConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CircuitConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_._has_bits_);
};

CircuitConstraintProto::CircuitConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CircuitConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CircuitConstraintProto)
}
PROTOBUF_NDEBUG_INLINE CircuitConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CircuitConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        tails_{visibility, arena, from.tails_},
        _tails_cached_byte_size_{0},
        heads_{visibility, arena, from.heads_},
        _heads_cached_byte_size_{0},
        literals_{visibility, arena, from.literals_},
        _literals_cached_byte_size_{0} {}

CircuitConstraintProto::CircuitConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CircuitConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CircuitConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CircuitConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CircuitConstraintProto)
}
PROTOBUF_NDEBUG_INLINE CircuitConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        tails_{visibility, arena},
        _tails_cached_byte_size_{0},
        heads_{visibility, arena},
        _heads_cached_byte_size_{0},
        literals_{visibility, arena},
        _literals_cached_byte_size_{0} {}

inline void CircuitConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CircuitConstraintProto::~CircuitConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CircuitConstraintProto)
  SharedDtor(*this);
}
inline void CircuitConstraintProto::SharedDtor(MessageLite& self) {
  CircuitConstraintProto& this_ = static_cast<CircuitConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CircuitConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CircuitConstraintProto(arena);
}
constexpr auto CircuitConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.tails_) +
          decltype(CircuitConstraintProto::_impl_.tails_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.heads_) +
          decltype(CircuitConstraintProto::_impl_.heads_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.literals_) +
          decltype(CircuitConstraintProto::_impl_.literals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CircuitConstraintProto), alignof(CircuitConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CircuitConstraintProto::PlacementNew_,
                                 sizeof(CircuitConstraintProto),
                                 alignof(CircuitConstraintProto));
  }
}
constexpr auto CircuitConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CircuitConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CircuitConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CircuitConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CircuitConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CircuitConstraintProto>(), &CircuitConstraintProto::ByteSizeLong,
              &CircuitConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_._cached_size_),
          false,
      },
      &CircuitConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CircuitConstraintProto_class_data_ =
        CircuitConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CircuitConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CircuitConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CircuitConstraintProto_class_data_.tc_table);
  return CircuitConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
CircuitConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    5, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967267,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CircuitConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CircuitConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 heads = 4;
    {::_pbi::TcParser::FastV32P1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.heads_)}},
    // repeated int32 literals = 5;
    {::_pbi::TcParser::FastV32P1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.literals_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 tails = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.tails_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 tails = 3;
    {PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.tails_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 heads = 4;
    {PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.heads_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 literals = 5;
    {PROTOBUF_FIELD_OFFSET(CircuitConstraintProto, _impl_.literals_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CircuitConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CircuitConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.tails_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.heads_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.literals_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CircuitConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CircuitConstraintProto& this_ = static_cast<const CircuitConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CircuitConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CircuitConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CircuitConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 tails = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._tails_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            3, this_._internal_tails(), byte_size, target);
      }
    }
  }

  // repeated int32 heads = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._heads_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            4, this_._internal_heads(), byte_size, target);
      }
    }
  }

  // repeated int32 literals = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._literals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            5, this_._internal_literals(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CircuitConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CircuitConstraintProto::ByteSizeLong(const MessageLite& base) {
  const CircuitConstraintProto& this_ = static_cast<const CircuitConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CircuitConstraintProto::ByteSizeLong() const {
  const CircuitConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CircuitConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated int32 tails = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_tails(), 1,
              this_._impl_._tails_cached_byte_size_);
    }
    // repeated int32 heads = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_heads(), 1,
              this_._impl_._heads_cached_byte_size_);
    }
    // repeated int32 literals = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_literals(), 1,
              this_._impl_._literals_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CircuitConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CircuitConstraintProto*>(&to_msg);
  auto& from = static_cast<const CircuitConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CircuitConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_tails()->MergeFrom(from._internal_tails());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_heads()->MergeFrom(from._internal_heads());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_literals()->MergeFrom(from._internal_literals());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CircuitConstraintProto::CopyFrom(const CircuitConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CircuitConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CircuitConstraintProto::InternalSwap(CircuitConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tails_.InternalSwap(&other->_impl_.tails_);
  _impl_.heads_.InternalSwap(&other->_impl_.heads_);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
}

::google::protobuf::Metadata CircuitConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RoutesConstraintProto_NodeExpressions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RoutesConstraintProto_NodeExpressions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_._has_bits_);
};

RoutesConstraintProto_NodeExpressions::RoutesConstraintProto_NodeExpressions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoutesConstraintProto_NodeExpressions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.RoutesConstraintProto.NodeExpressions)
}
PROTOBUF_NDEBUG_INLINE RoutesConstraintProto_NodeExpressions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::RoutesConstraintProto_NodeExpressions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

RoutesConstraintProto_NodeExpressions::RoutesConstraintProto_NodeExpressions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RoutesConstraintProto_NodeExpressions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoutesConstraintProto_NodeExpressions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RoutesConstraintProto_NodeExpressions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.RoutesConstraintProto.NodeExpressions)
}
PROTOBUF_NDEBUG_INLINE RoutesConstraintProto_NodeExpressions::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        exprs_{visibility, arena} {}

inline void RoutesConstraintProto_NodeExpressions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RoutesConstraintProto_NodeExpressions::~RoutesConstraintProto_NodeExpressions() {
  // @@protoc_insertion_point(destructor:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  SharedDtor(*this);
}
inline void RoutesConstraintProto_NodeExpressions::SharedDtor(MessageLite& self) {
  RoutesConstraintProto_NodeExpressions& this_ = static_cast<RoutesConstraintProto_NodeExpressions&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RoutesConstraintProto_NodeExpressions(arena);
}
constexpr auto RoutesConstraintProto_NodeExpressions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_.exprs_) +
          decltype(RoutesConstraintProto_NodeExpressions::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RoutesConstraintProto_NodeExpressions), alignof(RoutesConstraintProto_NodeExpressions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RoutesConstraintProto_NodeExpressions::PlacementNew_,
                                 sizeof(RoutesConstraintProto_NodeExpressions),
                                 alignof(RoutesConstraintProto_NodeExpressions));
  }
}
constexpr auto RoutesConstraintProto_NodeExpressions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RoutesConstraintProto_NodeExpressions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RoutesConstraintProto_NodeExpressions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RoutesConstraintProto_NodeExpressions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RoutesConstraintProto_NodeExpressions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RoutesConstraintProto_NodeExpressions>(), &RoutesConstraintProto_NodeExpressions::ByteSizeLong,
              &RoutesConstraintProto_NodeExpressions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_._cached_size_),
          false,
      },
      &RoutesConstraintProto_NodeExpressions::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_NodeExpressions_class_data_ =
        RoutesConstraintProto_NodeExpressions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RoutesConstraintProto_NodeExpressions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RoutesConstraintProto_NodeExpressions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RoutesConstraintProto_NodeExpressions_class_data_.tc_table);
  return RoutesConstraintProto_NodeExpressions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
RoutesConstraintProto_NodeExpressions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RoutesConstraintProto_NodeExpressions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::RoutesConstraintProto_NodeExpressions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_.exprs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto_NodeExpressions, _impl_.exprs_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RoutesConstraintProto_NodeExpressions::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.exprs_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RoutesConstraintProto_NodeExpressions& this_ = static_cast<const RoutesConstraintProto_NodeExpressions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RoutesConstraintProto_NodeExpressions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RoutesConstraintProto_NodeExpressions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RoutesConstraintProto_NodeExpressions::ByteSizeLong(const MessageLite& base) {
  const RoutesConstraintProto_NodeExpressions& this_ = static_cast<const RoutesConstraintProto_NodeExpressions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RoutesConstraintProto_NodeExpressions::ByteSizeLong() const {
  const RoutesConstraintProto_NodeExpressions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RoutesConstraintProto_NodeExpressions::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<RoutesConstraintProto_NodeExpressions*>(&to_msg);
  auto& from = static_cast<const RoutesConstraintProto_NodeExpressions&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
        ::google::protobuf::MessageLite::internal_visibility(), arena,
        from._internal_exprs());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void RoutesConstraintProto_NodeExpressions::CopyFrom(const RoutesConstraintProto_NodeExpressions& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.RoutesConstraintProto.NodeExpressions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RoutesConstraintProto_NodeExpressions::InternalSwap(RoutesConstraintProto_NodeExpressions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
}

::google::protobuf::Metadata RoutesConstraintProto_NodeExpressions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RoutesConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RoutesConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_._has_bits_);
};

RoutesConstraintProto::RoutesConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoutesConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.RoutesConstraintProto)
}
PROTOBUF_NDEBUG_INLINE RoutesConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::RoutesConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        tails_{visibility, arena, from.tails_},
        _tails_cached_byte_size_{0},
        heads_{visibility, arena, from.heads_},
        _heads_cached_byte_size_{0},
        literals_{visibility, arena, from.literals_},
        _literals_cached_byte_size_{0},
        demands_{visibility, arena, from.demands_},
        _demands_cached_byte_size_{0},
        dimensions_{visibility, arena, from.dimensions_} {}

RoutesConstraintProto::RoutesConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RoutesConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RoutesConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RoutesConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.capacity_ = from._impl_.capacity_;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.RoutesConstraintProto)
}
PROTOBUF_NDEBUG_INLINE RoutesConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        tails_{visibility, arena},
        _tails_cached_byte_size_{0},
        heads_{visibility, arena},
        _heads_cached_byte_size_{0},
        literals_{visibility, arena},
        _literals_cached_byte_size_{0},
        demands_{visibility, arena},
        _demands_cached_byte_size_{0},
        dimensions_{visibility, arena} {}

inline void RoutesConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.capacity_ = {};
}
RoutesConstraintProto::~RoutesConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.RoutesConstraintProto)
  SharedDtor(*this);
}
inline void RoutesConstraintProto::SharedDtor(MessageLite& self) {
  RoutesConstraintProto& this_ = static_cast<RoutesConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RoutesConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RoutesConstraintProto(arena);
}
constexpr auto RoutesConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.tails_) +
          decltype(RoutesConstraintProto::_impl_.tails_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.heads_) +
          decltype(RoutesConstraintProto::_impl_.heads_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.literals_) +
          decltype(RoutesConstraintProto::_impl_.literals_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.demands_) +
          decltype(RoutesConstraintProto::_impl_.demands_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.dimensions_) +
          decltype(RoutesConstraintProto::_impl_.dimensions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RoutesConstraintProto), alignof(RoutesConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RoutesConstraintProto::PlacementNew_,
                                 sizeof(RoutesConstraintProto),
                                 alignof(RoutesConstraintProto));
  }
}
constexpr auto RoutesConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RoutesConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RoutesConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RoutesConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RoutesConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RoutesConstraintProto>(), &RoutesConstraintProto::ByteSizeLong,
              &RoutesConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_._cached_size_),
          false,
      },
      &RoutesConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RoutesConstraintProto_class_data_ =
        RoutesConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RoutesConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RoutesConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RoutesConstraintProto_class_data_.tc_table);
  return RoutesConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2>
RoutesConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RoutesConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::RoutesConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 tails = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.tails_)}},
    // repeated int32 heads = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.heads_)}},
    // repeated int32 literals = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.literals_)}},
    // repeated int32 demands = 4;
    {::_pbi::TcParser::FastV32P1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.demands_)}},
    // int64 capacity = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RoutesConstraintProto, _impl_.capacity_), 5>(),
     {40, 5, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.capacity_)}},
    // repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 4, 0,
      PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.dimensions_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 tails = 1;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.tails_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 heads = 2;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.heads_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 literals = 3;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.literals_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 demands = 4;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.demands_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // int64 capacity = 5;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.capacity_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
    {PROTOBUF_FIELD_OFFSET(RoutesConstraintProto, _impl_.dimensions_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::RoutesConstraintProto_NodeExpressions>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void RoutesConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.RoutesConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.tails_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.heads_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.literals_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _impl_.demands_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      _impl_.dimensions_.Clear();
    }
  }
  _impl_.capacity_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RoutesConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RoutesConstraintProto& this_ = static_cast<const RoutesConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RoutesConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RoutesConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.RoutesConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 tails = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._tails_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_tails(), byte_size, target);
      }
    }
  }

  // repeated int32 heads = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._heads_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_heads(), byte_size, target);
      }
    }
  }

  // repeated int32 literals = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._literals_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            3, this_._internal_literals(), byte_size, target);
      }
    }
  }

  // repeated int32 demands = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
    {
      int byte_size = this_._impl_._demands_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            4, this_._internal_demands(), byte_size, target);
      }
    }
  }

  // int64 capacity = 5;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_capacity() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<5>(
              stream, this_._internal_capacity(), target);
    }
  }

  // repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_dimensions_size());
         i < n; i++) {
      const auto& repfield = this_._internal_dimensions().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              6, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.RoutesConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RoutesConstraintProto::ByteSizeLong(const MessageLite& base) {
  const RoutesConstraintProto& this_ = static_cast<const RoutesConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RoutesConstraintProto::ByteSizeLong() const {
  const RoutesConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.RoutesConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // repeated int32 tails = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_tails(), 1,
              this_._impl_._tails_cached_byte_size_);
    }
    // repeated int32 heads = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_heads(), 1,
              this_._impl_._heads_cached_byte_size_);
    }
    // repeated int32 literals = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_literals(), 1,
              this_._impl_._literals_cached_byte_size_);
    }
    // repeated int32 demands = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_demands(), 1,
              this_._impl_._demands_cached_byte_size_);
    }
    // repeated .operations_research.sat.RoutesConstraintProto.NodeExpressions dimensions = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      total_size += 1UL * this_._internal_dimensions_size();
      for (const auto& msg : this_._internal_dimensions()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // int64 capacity = 5;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_capacity() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_capacity());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RoutesConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<RoutesConstraintProto*>(&to_msg);
  auto& from = static_cast<const RoutesConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.RoutesConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_tails()->MergeFrom(from._internal_tails());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_heads()->MergeFrom(from._internal_heads());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_literals()->MergeFrom(from._internal_literals());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _this->_internal_mutable_demands()->MergeFrom(from._internal_demands());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      _this->_internal_mutable_dimensions()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_dimensions());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_capacity() != 0) {
        _this->_impl_.capacity_ = from._impl_.capacity_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void RoutesConstraintProto::CopyFrom(const RoutesConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.RoutesConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RoutesConstraintProto::InternalSwap(RoutesConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tails_.InternalSwap(&other->_impl_.tails_);
  _impl_.heads_.InternalSwap(&other->_impl_.heads_);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
  _impl_.demands_.InternalSwap(&other->_impl_.demands_);
  _impl_.dimensions_.InternalSwap(&other->_impl_.dimensions_);
  swap(_impl_.capacity_, other->_impl_.capacity_);
}

::google::protobuf::Metadata RoutesConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TableConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TableConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_._has_bits_);
};

TableConstraintProto::TableConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TableConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.TableConstraintProto)
}
PROTOBUF_NDEBUG_INLINE TableConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::TableConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        values_{visibility, arena, from.values_},
        _values_cached_byte_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

TableConstraintProto::TableConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TableConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TableConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TableConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.negated_ = from._impl_.negated_;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.TableConstraintProto)
}
PROTOBUF_NDEBUG_INLINE TableConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        values_{visibility, arena},
        _values_cached_byte_size_{0},
        exprs_{visibility, arena} {}

inline void TableConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.negated_ = {};
}
TableConstraintProto::~TableConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.TableConstraintProto)
  SharedDtor(*this);
}
inline void TableConstraintProto::SharedDtor(MessageLite& self) {
  TableConstraintProto& this_ = static_cast<TableConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TableConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TableConstraintProto(arena);
}
constexpr auto TableConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.vars_) +
          decltype(TableConstraintProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.values_) +
          decltype(TableConstraintProto::_impl_.values_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.exprs_) +
          decltype(TableConstraintProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(TableConstraintProto), alignof(TableConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TableConstraintProto::PlacementNew_,
                                 sizeof(TableConstraintProto),
                                 alignof(TableConstraintProto));
  }
}
constexpr auto TableConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TableConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &TableConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TableConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TableConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TableConstraintProto>(), &TableConstraintProto::ByteSizeLong,
              &TableConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_._cached_size_),
          false,
      },
      &TableConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TableConstraintProto_class_data_ =
        TableConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TableConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TableConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TableConstraintProto_class_data_.tc_table);
  return TableConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2>
TableConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    TableConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::TableConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.exprs_)}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.vars_)}},
    // repeated int64 values = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.values_)}},
    // bool negated = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TableConstraintProto, _impl_.negated_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.negated_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int64 values = 2;
    {PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.values_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // bool negated = 3;
    {PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.negated_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 4;
    {PROTOBUF_FIELD_OFFSET(TableConstraintProto, _impl_.exprs_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void TableConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.TableConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.values_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.exprs_.Clear();
    }
  }
  _impl_.negated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TableConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TableConstraintProto& this_ = static_cast<const TableConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TableConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TableConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.TableConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated int64 values = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._values_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_values(), byte_size, target);
      }
    }
  }

  // bool negated = 3;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_negated() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_negated(), target);
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.TableConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TableConstraintProto::ByteSizeLong(const MessageLite& base) {
  const TableConstraintProto& this_ = static_cast<const TableConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TableConstraintProto::ByteSizeLong() const {
  const TableConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.TableConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated int64 values = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_values(), 1,
              this_._impl_._values_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto exprs = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // bool negated = 3;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_negated() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TableConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TableConstraintProto*>(&to_msg);
  auto& from = static_cast<const TableConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.TableConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_values()->MergeFrom(from._internal_values());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_exprs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_negated() != 0) {
        _this->_impl_.negated_ = from._impl_.negated_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void TableConstraintProto::CopyFrom(const TableConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.TableConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void TableConstraintProto::InternalSwap(TableConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  swap(_impl_.negated_, other->_impl_.negated_);
}

::google::protobuf::Metadata TableConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class InverseConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<InverseConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_._has_bits_);
};

InverseConstraintProto::InverseConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InverseConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.InverseConstraintProto)
}
PROTOBUF_NDEBUG_INLINE InverseConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::InverseConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        f_direct_{visibility, arena, from.f_direct_},
        _f_direct_cached_byte_size_{0},
        f_inverse_{visibility, arena, from.f_inverse_},
        _f_inverse_cached_byte_size_{0} {}

InverseConstraintProto::InverseConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const InverseConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InverseConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InverseConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.InverseConstraintProto)
}
PROTOBUF_NDEBUG_INLINE InverseConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        f_direct_{visibility, arena},
        _f_direct_cached_byte_size_{0},
        f_inverse_{visibility, arena},
        _f_inverse_cached_byte_size_{0} {}

inline void InverseConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
InverseConstraintProto::~InverseConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.InverseConstraintProto)
  SharedDtor(*this);
}
inline void InverseConstraintProto::SharedDtor(MessageLite& self) {
  InverseConstraintProto& this_ = static_cast<InverseConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL InverseConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) InverseConstraintProto(arena);
}
constexpr auto InverseConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_direct_) +
          decltype(InverseConstraintProto::_impl_.f_direct_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_inverse_) +
          decltype(InverseConstraintProto::_impl_.f_inverse_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(InverseConstraintProto), alignof(InverseConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&InverseConstraintProto::PlacementNew_,
                                 sizeof(InverseConstraintProto),
                                 alignof(InverseConstraintProto));
  }
}
constexpr auto InverseConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_InverseConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &InverseConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<InverseConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &InverseConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<InverseConstraintProto>(), &InverseConstraintProto::ByteSizeLong,
              &InverseConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_._cached_size_),
          false,
      },
      &InverseConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull InverseConstraintProto_class_data_ =
        InverseConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
InverseConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&InverseConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(InverseConstraintProto_class_data_.tc_table);
  return InverseConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
InverseConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    InverseConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::InverseConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 f_inverse = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_inverse_)}},
    // repeated int32 f_direct = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_direct_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 f_direct = 1;
    {PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_direct_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 f_inverse = 2;
    {PROTOBUF_FIELD_OFFSET(InverseConstraintProto, _impl_.f_inverse_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void InverseConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.InverseConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.f_direct_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.f_inverse_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL InverseConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const InverseConstraintProto& this_ = static_cast<const InverseConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL InverseConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const InverseConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.InverseConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 f_direct = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._f_direct_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_f_direct(), byte_size, target);
      }
    }
  }

  // repeated int32 f_inverse = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._f_inverse_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_f_inverse(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.InverseConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t InverseConstraintProto::ByteSizeLong(const MessageLite& base) {
  const InverseConstraintProto& this_ = static_cast<const InverseConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t InverseConstraintProto::ByteSizeLong() const {
  const InverseConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.InverseConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int32 f_direct = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_f_direct(), 1,
              this_._impl_._f_direct_cached_byte_size_);
    }
    // repeated int32 f_inverse = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_f_inverse(), 1,
              this_._impl_._f_inverse_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void InverseConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<InverseConstraintProto*>(&to_msg);
  auto& from = static_cast<const InverseConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.InverseConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_f_direct()->MergeFrom(from._internal_f_direct());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_f_inverse()->MergeFrom(from._internal_f_inverse());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void InverseConstraintProto::CopyFrom(const InverseConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.InverseConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InverseConstraintProto::InternalSwap(InverseConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.f_direct_.InternalSwap(&other->_impl_.f_direct_);
  _impl_.f_inverse_.InternalSwap(&other->_impl_.f_inverse_);
}

::google::protobuf::Metadata InverseConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AutomatonConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AutomatonConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_._has_bits_);
};

AutomatonConstraintProto::AutomatonConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AutomatonConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.AutomatonConstraintProto)
}
PROTOBUF_NDEBUG_INLINE AutomatonConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::AutomatonConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        final_states_{visibility, arena, from.final_states_},
        _final_states_cached_byte_size_{0},
        transition_tail_{visibility, arena, from.transition_tail_},
        _transition_tail_cached_byte_size_{0},
        transition_head_{visibility, arena, from.transition_head_},
        _transition_head_cached_byte_size_{0},
        transition_label_{visibility, arena, from.transition_label_},
        _transition_label_cached_byte_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

AutomatonConstraintProto::AutomatonConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AutomatonConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AutomatonConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AutomatonConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.starting_state_ = from._impl_.starting_state_;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.AutomatonConstraintProto)
}
PROTOBUF_NDEBUG_INLINE AutomatonConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        final_states_{visibility, arena},
        _final_states_cached_byte_size_{0},
        transition_tail_{visibility, arena},
        _transition_tail_cached_byte_size_{0},
        transition_head_{visibility, arena},
        _transition_head_cached_byte_size_{0},
        transition_label_{visibility, arena},
        _transition_label_cached_byte_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        exprs_{visibility, arena} {}

inline void AutomatonConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.starting_state_ = {};
}
AutomatonConstraintProto::~AutomatonConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.AutomatonConstraintProto)
  SharedDtor(*this);
}
inline void AutomatonConstraintProto::SharedDtor(MessageLite& self) {
  AutomatonConstraintProto& this_ = static_cast<AutomatonConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AutomatonConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AutomatonConstraintProto(arena);
}
constexpr auto AutomatonConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.final_states_) +
          decltype(AutomatonConstraintProto::_impl_.final_states_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_tail_) +
          decltype(AutomatonConstraintProto::_impl_.transition_tail_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_head_) +
          decltype(AutomatonConstraintProto::_impl_.transition_head_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_label_) +
          decltype(AutomatonConstraintProto::_impl_.transition_label_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.vars_) +
          decltype(AutomatonConstraintProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.exprs_) +
          decltype(AutomatonConstraintProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(AutomatonConstraintProto), alignof(AutomatonConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&AutomatonConstraintProto::PlacementNew_,
                                 sizeof(AutomatonConstraintProto),
                                 alignof(AutomatonConstraintProto));
  }
}
constexpr auto AutomatonConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AutomatonConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AutomatonConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AutomatonConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AutomatonConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AutomatonConstraintProto>(), &AutomatonConstraintProto::ByteSizeLong,
              &AutomatonConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_._cached_size_),
          false,
      },
      &AutomatonConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AutomatonConstraintProto_class_data_ =
        AutomatonConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AutomatonConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AutomatonConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AutomatonConstraintProto_class_data_.tc_table);
  return AutomatonConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 2>
AutomatonConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967041,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    AutomatonConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::AutomatonConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.LinearExpressionProto exprs = 8;
    {::_pbi::TcParser::FastMtR1,
     {66, 5, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.exprs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // int64 starting_state = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(AutomatonConstraintProto, _impl_.starting_state_), 6>(),
     {16, 6, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.starting_state_)}},
    // repeated int64 final_states = 3;
    {::_pbi::TcParser::FastV64P1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.final_states_)}},
    // repeated int64 transition_tail = 4;
    {::_pbi::TcParser::FastV64P1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_tail_)}},
    // repeated int64 transition_head = 5;
    {::_pbi::TcParser::FastV64P1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_head_)}},
    // repeated int64 transition_label = 6;
    {::_pbi::TcParser::FastV64P1,
     {50, 3, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_label_)}},
    // repeated int32 vars = 7;
    {::_pbi::TcParser::FastV32P1,
     {58, 4, 0,
      PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.vars_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 starting_state = 2;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.starting_state_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // repeated int64 final_states = 3;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.final_states_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 transition_tail = 4;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_tail_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 transition_head = 5;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_head_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 transition_label = 6;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.transition_label_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int32 vars = 7;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.vars_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 8;
    {PROTOBUF_FIELD_OFFSET(AutomatonConstraintProto, _impl_.exprs_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void AutomatonConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.AutomatonConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.final_states_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.transition_tail_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.transition_head_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _impl_.transition_label_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000020U)) {
      _impl_.exprs_.Clear();
    }
  }
  _impl_.starting_state_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AutomatonConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AutomatonConstraintProto& this_ = static_cast<const AutomatonConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AutomatonConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AutomatonConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.AutomatonConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int64 starting_state = 2;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_starting_state() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<2>(
              stream, this_._internal_starting_state(), target);
    }
  }

  // repeated int64 final_states = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._final_states_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            3, this_._internal_final_states(), byte_size, target);
      }
    }
  }

  // repeated int64 transition_tail = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._transition_tail_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            4, this_._internal_transition_tail(), byte_size, target);
      }
    }
  }

  // repeated int64 transition_head = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._transition_head_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            5, this_._internal_transition_head(), byte_size, target);
      }
    }
  }

  // repeated int64 transition_label = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
    {
      int byte_size = this_._impl_._transition_label_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            6, this_._internal_transition_label(), byte_size, target);
      }
    }
  }

  // repeated int32 vars = 7;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            7, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 8;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000020U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              8, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.AutomatonConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AutomatonConstraintProto::ByteSizeLong(const MessageLite& base) {
  const AutomatonConstraintProto& this_ = static_cast<const AutomatonConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AutomatonConstraintProto::ByteSizeLong() const {
  const AutomatonConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.AutomatonConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // repeated int64 final_states = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_final_states(), 1,
              this_._impl_._final_states_cached_byte_size_);
    }
    // repeated int64 transition_tail = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_transition_tail(), 1,
              this_._impl_._transition_tail_cached_byte_size_);
    }
    // repeated int64 transition_head = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_transition_head(), 1,
              this_._impl_._transition_head_cached_byte_size_);
    }
    // repeated int64 transition_label = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_transition_label(), 1,
              this_._impl_._transition_label_cached_byte_size_);
    }
    // repeated int32 vars = 7;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto exprs = 8;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000020U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // int64 starting_state = 2;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_starting_state() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_starting_state());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AutomatonConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<AutomatonConstraintProto*>(&to_msg);
  auto& from = static_cast<const AutomatonConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.AutomatonConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_final_states()->MergeFrom(from._internal_final_states());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_transition_tail()->MergeFrom(from._internal_transition_tail());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_transition_head()->MergeFrom(from._internal_transition_head());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _this->_internal_mutable_transition_label()->MergeFrom(from._internal_transition_label());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000010U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000020U)) {
      _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_exprs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_starting_state() != 0) {
        _this->_impl_.starting_state_ = from._impl_.starting_state_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void AutomatonConstraintProto::CopyFrom(const AutomatonConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.AutomatonConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AutomatonConstraintProto::InternalSwap(AutomatonConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.final_states_.InternalSwap(&other->_impl_.final_states_);
  _impl_.transition_tail_.InternalSwap(&other->_impl_.transition_tail_);
  _impl_.transition_head_.InternalSwap(&other->_impl_.transition_head_);
  _impl_.transition_label_.InternalSwap(&other->_impl_.transition_label_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  swap(_impl_.starting_state_, other->_impl_.starting_state_);
}

::google::protobuf::Metadata AutomatonConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ListOfVariablesProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ListOfVariablesProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_._has_bits_);
};

ListOfVariablesProto::ListOfVariablesProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ListOfVariablesProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ListOfVariablesProto)
}
PROTOBUF_NDEBUG_INLINE ListOfVariablesProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::ListOfVariablesProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0} {}

ListOfVariablesProto::ListOfVariablesProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ListOfVariablesProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ListOfVariablesProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ListOfVariablesProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ListOfVariablesProto)
}
PROTOBUF_NDEBUG_INLINE ListOfVariablesProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0} {}

inline void ListOfVariablesProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ListOfVariablesProto::~ListOfVariablesProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ListOfVariablesProto)
  SharedDtor(*this);
}
inline void ListOfVariablesProto::SharedDtor(MessageLite& self) {
  ListOfVariablesProto& this_ = static_cast<ListOfVariablesProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ListOfVariablesProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ListOfVariablesProto(arena);
}
constexpr auto ListOfVariablesProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_.vars_) +
          decltype(ListOfVariablesProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(ListOfVariablesProto), alignof(ListOfVariablesProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ListOfVariablesProto::PlacementNew_,
                                 sizeof(ListOfVariablesProto),
                                 alignof(ListOfVariablesProto));
  }
}
constexpr auto ListOfVariablesProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ListOfVariablesProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ListOfVariablesProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ListOfVariablesProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ListOfVariablesProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ListOfVariablesProto>(), &ListOfVariablesProto::ByteSizeLong,
              &ListOfVariablesProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_._cached_size_),
          false,
      },
      &ListOfVariablesProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ListOfVariablesProto_class_data_ =
        ListOfVariablesProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ListOfVariablesProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ListOfVariablesProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ListOfVariablesProto_class_data_.tc_table);
  return ListOfVariablesProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
ListOfVariablesProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ListOfVariablesProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::ListOfVariablesProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_.vars_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(ListOfVariablesProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ListOfVariablesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ListOfVariablesProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.vars_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ListOfVariablesProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ListOfVariablesProto& this_ = static_cast<const ListOfVariablesProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ListOfVariablesProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ListOfVariablesProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ListOfVariablesProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ListOfVariablesProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ListOfVariablesProto::ByteSizeLong(const MessageLite& base) {
  const ListOfVariablesProto& this_ = static_cast<const ListOfVariablesProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ListOfVariablesProto::ByteSizeLong() const {
  const ListOfVariablesProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ListOfVariablesProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int32 vars = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ListOfVariablesProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ListOfVariablesProto*>(&to_msg);
  auto& from = static_cast<const ListOfVariablesProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ListOfVariablesProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ListOfVariablesProto::CopyFrom(const ListOfVariablesProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ListOfVariablesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ListOfVariablesProto::InternalSwap(ListOfVariablesProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
}

::google::protobuf::Metadata ListOfVariablesProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ConstraintProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ConstraintProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_._oneof_case_);
};

void ConstraintProto::set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE bool_or) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (bool_or) {
    ::google::protobuf::Arena* submessage_arena = bool_or->GetArena();
    if (message_arena != submessage_arena) {
      bool_or = ::google::protobuf::internal::GetOwnedMessage(message_arena, bool_or, submessage_arena);
    }
    set_has_bool_or();
    _impl_.constraint_.bool_or_ = bool_or;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_or)
}
void ConstraintProto::set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE bool_and) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (bool_and) {
    ::google::protobuf::Arena* submessage_arena = bool_and->GetArena();
    if (message_arena != submessage_arena) {
      bool_and = ::google::protobuf::internal::GetOwnedMessage(message_arena, bool_and, submessage_arena);
    }
    set_has_bool_and();
    _impl_.constraint_.bool_and_ = bool_and;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_and)
}
void ConstraintProto::set_allocated_at_most_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE at_most_one) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (at_most_one) {
    ::google::protobuf::Arena* submessage_arena = at_most_one->GetArena();
    if (message_arena != submessage_arena) {
      at_most_one = ::google::protobuf::internal::GetOwnedMessage(message_arena, at_most_one, submessage_arena);
    }
    set_has_at_most_one();
    _impl_.constraint_.at_most_one_ = at_most_one;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.at_most_one)
}
void ConstraintProto::set_allocated_exactly_one(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE exactly_one) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (exactly_one) {
    ::google::protobuf::Arena* submessage_arena = exactly_one->GetArena();
    if (message_arena != submessage_arena) {
      exactly_one = ::google::protobuf::internal::GetOwnedMessage(message_arena, exactly_one, submessage_arena);
    }
    set_has_exactly_one();
    _impl_.constraint_.exactly_one_ = exactly_one;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.exactly_one)
}
void ConstraintProto::set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* PROTOBUF_NULLABLE bool_xor) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (bool_xor) {
    ::google::protobuf::Arena* submessage_arena = bool_xor->GetArena();
    if (message_arena != submessage_arena) {
      bool_xor = ::google::protobuf::internal::GetOwnedMessage(message_arena, bool_xor, submessage_arena);
    }
    set_has_bool_xor();
    _impl_.constraint_.bool_xor_ = bool_xor;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_xor)
}
void ConstraintProto::set_allocated_int_div(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE int_div) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (int_div) {
    ::google::protobuf::Arena* submessage_arena = int_div->GetArena();
    if (message_arena != submessage_arena) {
      int_div = ::google::protobuf::internal::GetOwnedMessage(message_arena, int_div, submessage_arena);
    }
    set_has_int_div();
    _impl_.constraint_.int_div_ = int_div;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_div)
}
void ConstraintProto::set_allocated_int_mod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE int_mod) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (int_mod) {
    ::google::protobuf::Arena* submessage_arena = int_mod->GetArena();
    if (message_arena != submessage_arena) {
      int_mod = ::google::protobuf::internal::GetOwnedMessage(message_arena, int_mod, submessage_arena);
    }
    set_has_int_mod();
    _impl_.constraint_.int_mod_ = int_mod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_mod)
}
void ConstraintProto::set_allocated_int_prod(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE int_prod) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (int_prod) {
    ::google::protobuf::Arena* submessage_arena = int_prod->GetArena();
    if (message_arena != submessage_arena) {
      int_prod = ::google::protobuf::internal::GetOwnedMessage(message_arena, int_prod, submessage_arena);
    }
    set_has_int_prod();
    _impl_.constraint_.int_prod_ = int_prod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_prod)
}
void ConstraintProto::set_allocated_lin_max(::operations_research::sat::LinearArgumentProto* PROTOBUF_NULLABLE lin_max) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (lin_max) {
    ::google::protobuf::Arena* submessage_arena = lin_max->GetArena();
    if (message_arena != submessage_arena) {
      lin_max = ::google::protobuf::internal::GetOwnedMessage(message_arena, lin_max, submessage_arena);
    }
    set_has_lin_max();
    _impl_.constraint_.lin_max_ = lin_max;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.lin_max)
}
void ConstraintProto::set_allocated_linear(::operations_research::sat::LinearConstraintProto* PROTOBUF_NULLABLE linear) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (linear) {
    ::google::protobuf::Arena* submessage_arena = linear->GetArena();
    if (message_arena != submessage_arena) {
      linear = ::google::protobuf::internal::GetOwnedMessage(message_arena, linear, submessage_arena);
    }
    set_has_linear();
    _impl_.constraint_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.linear)
}
void ConstraintProto::set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* PROTOBUF_NULLABLE all_diff) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (all_diff) {
    ::google::protobuf::Arena* submessage_arena = all_diff->GetArena();
    if (message_arena != submessage_arena) {
      all_diff = ::google::protobuf::internal::GetOwnedMessage(message_arena, all_diff, submessage_arena);
    }
    set_has_all_diff();
    _impl_.constraint_.all_diff_ = all_diff;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.all_diff)
}
void ConstraintProto::set_allocated_element(::operations_research::sat::ElementConstraintProto* PROTOBUF_NULLABLE element) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (element) {
    ::google::protobuf::Arena* submessage_arena = element->GetArena();
    if (message_arena != submessage_arena) {
      element = ::google::protobuf::internal::GetOwnedMessage(message_arena, element, submessage_arena);
    }
    set_has_element();
    _impl_.constraint_.element_ = element;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.element)
}
void ConstraintProto::set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* PROTOBUF_NULLABLE circuit) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (circuit) {
    ::google::protobuf::Arena* submessage_arena = circuit->GetArena();
    if (message_arena != submessage_arena) {
      circuit = ::google::protobuf::internal::GetOwnedMessage(message_arena, circuit, submessage_arena);
    }
    set_has_circuit();
    _impl_.constraint_.circuit_ = circuit;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.circuit)
}
void ConstraintProto::set_allocated_routes(::operations_research::sat::RoutesConstraintProto* PROTOBUF_NULLABLE routes) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (routes) {
    ::google::protobuf::Arena* submessage_arena = routes->GetArena();
    if (message_arena != submessage_arena) {
      routes = ::google::protobuf::internal::GetOwnedMessage(message_arena, routes, submessage_arena);
    }
    set_has_routes();
    _impl_.constraint_.routes_ = routes;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.routes)
}
void ConstraintProto::set_allocated_table(::operations_research::sat::TableConstraintProto* PROTOBUF_NULLABLE table) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (table) {
    ::google::protobuf::Arena* submessage_arena = table->GetArena();
    if (message_arena != submessage_arena) {
      table = ::google::protobuf::internal::GetOwnedMessage(message_arena, table, submessage_arena);
    }
    set_has_table();
    _impl_.constraint_.table_ = table;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.table)
}
void ConstraintProto::set_allocated_automaton(::operations_research::sat::AutomatonConstraintProto* PROTOBUF_NULLABLE automaton) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (automaton) {
    ::google::protobuf::Arena* submessage_arena = automaton->GetArena();
    if (message_arena != submessage_arena) {
      automaton = ::google::protobuf::internal::GetOwnedMessage(message_arena, automaton, submessage_arena);
    }
    set_has_automaton();
    _impl_.constraint_.automaton_ = automaton;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.automaton)
}
void ConstraintProto::set_allocated_inverse(::operations_research::sat::InverseConstraintProto* PROTOBUF_NULLABLE inverse) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (inverse) {
    ::google::protobuf::Arena* submessage_arena = inverse->GetArena();
    if (message_arena != submessage_arena) {
      inverse = ::google::protobuf::internal::GetOwnedMessage(message_arena, inverse, submessage_arena);
    }
    set_has_inverse();
    _impl_.constraint_.inverse_ = inverse;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.inverse)
}
void ConstraintProto::set_allocated_reservoir(::operations_research::sat::ReservoirConstraintProto* PROTOBUF_NULLABLE reservoir) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (reservoir) {
    ::google::protobuf::Arena* submessage_arena = reservoir->GetArena();
    if (message_arena != submessage_arena) {
      reservoir = ::google::protobuf::internal::GetOwnedMessage(message_arena, reservoir, submessage_arena);
    }
    set_has_reservoir();
    _impl_.constraint_.reservoir_ = reservoir;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.reservoir)
}
void ConstraintProto::set_allocated_interval(::operations_research::sat::IntervalConstraintProto* PROTOBUF_NULLABLE interval) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (interval) {
    ::google::protobuf::Arena* submessage_arena = interval->GetArena();
    if (message_arena != submessage_arena) {
      interval = ::google::protobuf::internal::GetOwnedMessage(message_arena, interval, submessage_arena);
    }
    set_has_interval();
    _impl_.constraint_.interval_ = interval;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.interval)
}
void ConstraintProto::set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* PROTOBUF_NULLABLE no_overlap) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (no_overlap) {
    ::google::protobuf::Arena* submessage_arena = no_overlap->GetArena();
    if (message_arena != submessage_arena) {
      no_overlap = ::google::protobuf::internal::GetOwnedMessage(message_arena, no_overlap, submessage_arena);
    }
    set_has_no_overlap();
    _impl_.constraint_.no_overlap_ = no_overlap;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap)
}
void ConstraintProto::set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* PROTOBUF_NULLABLE no_overlap_2d) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (no_overlap_2d) {
    ::google::protobuf::Arena* submessage_arena = no_overlap_2d->GetArena();
    if (message_arena != submessage_arena) {
      no_overlap_2d = ::google::protobuf::internal::GetOwnedMessage(message_arena, no_overlap_2d, submessage_arena);
    }
    set_has_no_overlap_2d();
    _impl_.constraint_.no_overlap_2d_ = no_overlap_2d;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap_2d)
}
void ConstraintProto::set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* PROTOBUF_NULLABLE cumulative) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (cumulative) {
    ::google::protobuf::Arena* submessage_arena = cumulative->GetArena();
    if (message_arena != submessage_arena) {
      cumulative = ::google::protobuf::internal::GetOwnedMessage(message_arena, cumulative, submessage_arena);
    }
    set_has_cumulative();
    _impl_.constraint_.cumulative_ = cumulative;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.cumulative)
}
void ConstraintProto::set_allocated_dummy_constraint(::operations_research::sat::ListOfVariablesProto* PROTOBUF_NULLABLE dummy_constraint) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_constraint();
  if (dummy_constraint) {
    ::google::protobuf::Arena* submessage_arena = dummy_constraint->GetArena();
    if (message_arena != submessage_arena) {
      dummy_constraint = ::google::protobuf::internal::GetOwnedMessage(message_arena, dummy_constraint, submessage_arena);
    }
    set_has_dummy_constraint();
    _impl_.constraint_.dummy_constraint_ = dummy_constraint;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.dummy_constraint)
}
ConstraintProto::ConstraintProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::ConstraintProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        enforcement_literal_{visibility, arena, from.enforcement_literal_},
        _enforcement_literal_cached_byte_size_{0},
        name_(arena, from.name_),
        constraint_{},
        _oneof_case_{from._oneof_case_[0]} {}

ConstraintProto::ConstraintProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ConstraintProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ConstraintProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ConstraintProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (constraint_case()) {
    case CONSTRAINT_NOT_SET:
      break;
      case kBoolOr:
        _impl_.constraint_.bool_or_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_or_);
        break;
      case kBoolAnd:
        _impl_.constraint_.bool_and_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_and_);
        break;
      case kAtMostOne:
        _impl_.constraint_.at_most_one_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.at_most_one_);
        break;
      case kExactlyOne:
        _impl_.constraint_.exactly_one_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.exactly_one_);
        break;
      case kBoolXor:
        _impl_.constraint_.bool_xor_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_xor_);
        break;
      case kIntDiv:
        _impl_.constraint_.int_div_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_div_);
        break;
      case kIntMod:
        _impl_.constraint_.int_mod_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_mod_);
        break;
      case kIntProd:
        _impl_.constraint_.int_prod_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_prod_);
        break;
      case kLinMax:
        _impl_.constraint_.lin_max_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.lin_max_);
        break;
      case kLinear:
        _impl_.constraint_.linear_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.linear_);
        break;
      case kAllDiff:
        _impl_.constraint_.all_diff_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.all_diff_);
        break;
      case kElement:
        _impl_.constraint_.element_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.element_);
        break;
      case kCircuit:
        _impl_.constraint_.circuit_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.circuit_);
        break;
      case kRoutes:
        _impl_.constraint_.routes_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.routes_);
        break;
      case kTable:
        _impl_.constraint_.table_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.table_);
        break;
      case kAutomaton:
        _impl_.constraint_.automaton_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.automaton_);
        break;
      case kInverse:
        _impl_.constraint_.inverse_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.inverse_);
        break;
      case kReservoir:
        _impl_.constraint_.reservoir_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.reservoir_);
        break;
      case kInterval:
        _impl_.constraint_.interval_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.interval_);
        break;
      case kNoOverlap:
        _impl_.constraint_.no_overlap_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.no_overlap_);
        break;
      case kNoOverlap2D:
        _impl_.constraint_.no_overlap_2d_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.no_overlap_2d_);
        break;
      case kCumulative:
        _impl_.constraint_.cumulative_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.cumulative_);
        break;
      case kDummyConstraint:
        _impl_.constraint_.dummy_constraint_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.dummy_constraint_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ConstraintProto)
}
PROTOBUF_NDEBUG_INLINE ConstraintProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        enforcement_literal_{visibility, arena},
        _enforcement_literal_cached_byte_size_{0},
        name_(arena),
        constraint_{},
        _oneof_case_{} {}

inline void ConstraintProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ConstraintProto::~ConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ConstraintProto)
  SharedDtor(*this);
}
inline void ConstraintProto::SharedDtor(MessageLite& self) {
  ConstraintProto& this_ = static_cast<ConstraintProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  if (this_.has_constraint()) {
    this_.clear_constraint();
  }
  this_._impl_.~Impl_();
}

void ConstraintProto::clear_constraint() {
// @@protoc_insertion_point(one_of_clear_start:operations_research.sat.ConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (constraint_case()) {
    case kBoolOr: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.bool_or_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_or_);
      }
      break;
    }
    case kBoolAnd: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.bool_and_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_and_);
      }
      break;
    }
    case kAtMostOne: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.at_most_one_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.at_most_one_);
      }
      break;
    }
    case kExactlyOne: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.exactly_one_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.exactly_one_);
      }
      break;
    }
    case kBoolXor: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.bool_xor_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.bool_xor_);
      }
      break;
    }
    case kIntDiv: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.int_div_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_div_);
      }
      break;
    }
    case kIntMod: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.int_mod_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_mod_);
      }
      break;
    }
    case kIntProd: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.int_prod_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.int_prod_);
      }
      break;
    }
    case kLinMax: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.lin_max_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.lin_max_);
      }
      break;
    }
    case kLinear: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.linear_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.linear_);
      }
      break;
    }
    case kAllDiff: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.all_diff_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.all_diff_);
      }
      break;
    }
    case kElement: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.element_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.element_);
      }
      break;
    }
    case kCircuit: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.circuit_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.circuit_);
      }
      break;
    }
    case kRoutes: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.routes_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.routes_);
      }
      break;
    }
    case kTable: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.table_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.table_);
      }
      break;
    }
    case kAutomaton: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.automaton_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.automaton_);
      }
      break;
    }
    case kInverse: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.inverse_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.inverse_);
      }
      break;
    }
    case kReservoir: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.reservoir_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.reservoir_);
      }
      break;
    }
    case kInterval: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.interval_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.interval_);
      }
      break;
    }
    case kNoOverlap: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.no_overlap_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.no_overlap_);
      }
      break;
    }
    case kNoOverlap2D: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.no_overlap_2d_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.no_overlap_2d_);
      }
      break;
    }
    case kCumulative: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.cumulative_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.cumulative_);
      }
      break;
    }
    case kDummyConstraint: {
      if (GetArena() == nullptr) {
        delete _impl_.constraint_.dummy_constraint_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.constraint_.dummy_constraint_);
      }
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CONSTRAINT_NOT_SET;
}


inline void* PROTOBUF_NONNULL ConstraintProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ConstraintProto(arena);
}
constexpr auto ConstraintProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.enforcement_literal_) +
          decltype(ConstraintProto::_impl_.enforcement_literal_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ConstraintProto), alignof(ConstraintProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ConstraintProto::PlacementNew_,
                                 sizeof(ConstraintProto),
                                 alignof(ConstraintProto));
  }
}
constexpr auto ConstraintProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ConstraintProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ConstraintProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ConstraintProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ConstraintProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ConstraintProto>(), &ConstraintProto::ByteSizeLong,
              &ConstraintProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_._cached_size_),
          false,
      },
      &ConstraintProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ConstraintProto_class_data_ =
        ConstraintProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ConstraintProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ConstraintProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ConstraintProto_class_data_.tc_table);
  return ConstraintProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 25, 23, 76, 2>
ConstraintProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_._has_bits_),
    0, // no _extensions_
    30, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    3372221216,  // skipmap
    offsetof(decltype(_table_), field_entries),
    25,  // num_field_entries
    23,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ConstraintProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::ConstraintProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 enforcement_literal = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.enforcement_literal_)}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 1, 0,
      PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.name_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated int32 enforcement_literal = 2;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.enforcement_literal_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // .operations_research.sat.BoolArgumentProto bool_or = 3;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.bool_or_), _Internal::kOneofCaseOffset + 0, 0, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.BoolArgumentProto bool_and = 4;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.bool_and_), _Internal::kOneofCaseOffset + 0, 1, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.BoolArgumentProto bool_xor = 5;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.bool_xor_), _Internal::kOneofCaseOffset + 0, 2, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearArgumentProto int_div = 7;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.int_div_), _Internal::kOneofCaseOffset + 0, 3, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearArgumentProto int_mod = 8;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.int_mod_), _Internal::kOneofCaseOffset + 0, 4, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearArgumentProto int_prod = 11;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.int_prod_), _Internal::kOneofCaseOffset + 0, 5, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearConstraintProto linear = 12;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.linear_), _Internal::kOneofCaseOffset + 0, 6, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.all_diff_), _Internal::kOneofCaseOffset + 0, 7, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.ElementConstraintProto element = 14;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.element_), _Internal::kOneofCaseOffset + 0, 8, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.CircuitConstraintProto circuit = 15;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.circuit_), _Internal::kOneofCaseOffset + 0, 9, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.TableConstraintProto table = 16;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.table_), _Internal::kOneofCaseOffset + 0, 10, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.AutomatonConstraintProto automaton = 17;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.automaton_), _Internal::kOneofCaseOffset + 0, 11, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.InverseConstraintProto inverse = 18;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.inverse_), _Internal::kOneofCaseOffset + 0, 12, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.IntervalConstraintProto interval = 19;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.interval_), _Internal::kOneofCaseOffset + 0, 13, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.no_overlap_), _Internal::kOneofCaseOffset + 0, 14, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.no_overlap_2d_), _Internal::kOneofCaseOffset + 0, 15, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.cumulative_), _Internal::kOneofCaseOffset + 0, 16, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.RoutesConstraintProto routes = 23;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.routes_), _Internal::kOneofCaseOffset + 0, 17, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.reservoir_), _Internal::kOneofCaseOffset + 0, 18, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.BoolArgumentProto at_most_one = 26;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.at_most_one_), _Internal::kOneofCaseOffset + 0, 19, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.LinearArgumentProto lin_max = 27;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.lin_max_), _Internal::kOneofCaseOffset + 0, 20, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.BoolArgumentProto exactly_one = 29;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.exactly_one_), _Internal::kOneofCaseOffset + 0, 21, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
    {PROTOBUF_FIELD_OFFSET(ConstraintProto, _impl_.constraint_.dummy_constraint_), _Internal::kOneofCaseOffset + 0, 22, (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::AllDifferentConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::ElementConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::CircuitConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::TableConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::AutomatonConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::InverseConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::IntervalConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::NoOverlapConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::NoOverlap2DConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::CumulativeConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::RoutesConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::ReservoirConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::BoolArgumentProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::ListOfVariablesProto>()},
  }},
  {{
    "\47\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "operations_research.sat.ConstraintProto"
    "name"
  }},
};
PROTOBUF_NOINLINE void ConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ConstraintProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.enforcement_literal_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  clear_constraint();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ConstraintProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ConstraintProto& this_ = static_cast<const ConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ConstraintProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ConstraintProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (!this_._internal_name().empty()) {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "operations_research.sat.ConstraintProto.name");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated int32 enforcement_literal = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._enforcement_literal_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_enforcement_literal(), byte_size, target);
      }
    }
  }

  switch (this_.constraint_case()) {
    case kBoolOr: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.constraint_.bool_or_, this_._impl_.constraint_.bool_or_->GetCachedSize(), target,
          stream);
      break;
    }
    case kBoolAnd: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.constraint_.bool_and_, this_._impl_.constraint_.bool_and_->GetCachedSize(), target,
          stream);
      break;
    }
    case kBoolXor: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.constraint_.bool_xor_, this_._impl_.constraint_.bool_xor_->GetCachedSize(), target,
          stream);
      break;
    }
    case kIntDiv: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.constraint_.int_div_, this_._impl_.constraint_.int_div_->GetCachedSize(), target,
          stream);
      break;
    }
    case kIntMod: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, *this_._impl_.constraint_.int_mod_, this_._impl_.constraint_.int_mod_->GetCachedSize(), target,
          stream);
      break;
    }
    case kIntProd: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.constraint_.int_prod_, this_._impl_.constraint_.int_prod_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLinear: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.constraint_.linear_, this_._impl_.constraint_.linear_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAllDiff: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.constraint_.all_diff_, this_._impl_.constraint_.all_diff_->GetCachedSize(), target,
          stream);
      break;
    }
    case kElement: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *this_._impl_.constraint_.element_, this_._impl_.constraint_.element_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCircuit: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          15, *this_._impl_.constraint_.circuit_, this_._impl_.constraint_.circuit_->GetCachedSize(), target,
          stream);
      break;
    }
    case kTable: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          16, *this_._impl_.constraint_.table_, this_._impl_.constraint_.table_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAutomaton: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          17, *this_._impl_.constraint_.automaton_, this_._impl_.constraint_.automaton_->GetCachedSize(), target,
          stream);
      break;
    }
    case kInverse: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          18, *this_._impl_.constraint_.inverse_, this_._impl_.constraint_.inverse_->GetCachedSize(), target,
          stream);
      break;
    }
    case kInterval: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          19, *this_._impl_.constraint_.interval_, this_._impl_.constraint_.interval_->GetCachedSize(), target,
          stream);
      break;
    }
    case kNoOverlap: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          20, *this_._impl_.constraint_.no_overlap_, this_._impl_.constraint_.no_overlap_->GetCachedSize(), target,
          stream);
      break;
    }
    case kNoOverlap2D: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          21, *this_._impl_.constraint_.no_overlap_2d_, this_._impl_.constraint_.no_overlap_2d_->GetCachedSize(), target,
          stream);
      break;
    }
    case kCumulative: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          22, *this_._impl_.constraint_.cumulative_, this_._impl_.constraint_.cumulative_->GetCachedSize(), target,
          stream);
      break;
    }
    case kRoutes: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          23, *this_._impl_.constraint_.routes_, this_._impl_.constraint_.routes_->GetCachedSize(), target,
          stream);
      break;
    }
    case kReservoir: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          24, *this_._impl_.constraint_.reservoir_, this_._impl_.constraint_.reservoir_->GetCachedSize(), target,
          stream);
      break;
    }
    case kAtMostOne: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          26, *this_._impl_.constraint_.at_most_one_, this_._impl_.constraint_.at_most_one_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLinMax: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          27, *this_._impl_.constraint_.lin_max_, this_._impl_.constraint_.lin_max_->GetCachedSize(), target,
          stream);
      break;
    }
    case kExactlyOne: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          29, *this_._impl_.constraint_.exactly_one_, this_._impl_.constraint_.exactly_one_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDummyConstraint: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          30, *this_._impl_.constraint_.dummy_constraint_, this_._impl_.constraint_.dummy_constraint_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ConstraintProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ConstraintProto::ByteSizeLong(const MessageLite& base) {
  const ConstraintProto& this_ = static_cast<const ConstraintProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ConstraintProto::ByteSizeLong() const {
  const ConstraintProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ConstraintProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int32 enforcement_literal = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_enforcement_literal(), 1,
              this_._impl_._enforcement_literal_cached_byte_size_);
    }
    // string name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!this_._internal_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_name());
      }
    }
  }
  switch (this_.constraint_case()) {
    // .operations_research.sat.BoolArgumentProto bool_or = 3;
    case kBoolOr: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.bool_or_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto bool_and = 4;
    case kBoolAnd: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.bool_and_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto at_most_one = 26;
    case kAtMostOne: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.at_most_one_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto exactly_one = 29;
    case kExactlyOne: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.exactly_one_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto bool_xor = 5;
    case kBoolXor: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.bool_xor_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_div = 7;
    case kIntDiv: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.int_div_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_mod = 8;
    case kIntMod: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.int_mod_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_prod = 11;
    case kIntProd: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.int_prod_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto lin_max = 27;
    case kLinMax: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.lin_max_);
      break;
    }
    // .operations_research.sat.LinearConstraintProto linear = 12;
    case kLinear: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.linear_);
      break;
    }
    // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
    case kAllDiff: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.all_diff_);
      break;
    }
    // .operations_research.sat.ElementConstraintProto element = 14;
    case kElement: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.element_);
      break;
    }
    // .operations_research.sat.CircuitConstraintProto circuit = 15;
    case kCircuit: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.circuit_);
      break;
    }
    // .operations_research.sat.RoutesConstraintProto routes = 23;
    case kRoutes: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.routes_);
      break;
    }
    // .operations_research.sat.TableConstraintProto table = 16;
    case kTable: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.table_);
      break;
    }
    // .operations_research.sat.AutomatonConstraintProto automaton = 17;
    case kAutomaton: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.automaton_);
      break;
    }
    // .operations_research.sat.InverseConstraintProto inverse = 18;
    case kInverse: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.inverse_);
      break;
    }
    // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
    case kReservoir: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.reservoir_);
      break;
    }
    // .operations_research.sat.IntervalConstraintProto interval = 19;
    case kInterval: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.interval_);
      break;
    }
    // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
    case kNoOverlap: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.no_overlap_);
      break;
    }
    // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
    case kNoOverlap2D: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.no_overlap_2d_);
      break;
    }
    // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
    case kCumulative: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.cumulative_);
      break;
    }
    // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
    case kDummyConstraint: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.constraint_.dummy_constraint_);
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ConstraintProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ConstraintProto*>(&to_msg);
  auto& from = static_cast<const ConstraintProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ConstraintProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_enforcement_literal()->MergeFrom(from._internal_enforcement_literal());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
      } else {
        if (_this->_impl_.name_.IsDefault()) {
          _this->_internal_set_name("");
        }
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case =
          from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_constraint();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kBoolOr: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.bool_or_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_or_);
        } else {
          _this->_impl_.constraint_.bool_or_->MergeFrom(*from._impl_.constraint_.bool_or_);
        }
        break;
      }
      case kBoolAnd: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.bool_and_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_and_);
        } else {
          _this->_impl_.constraint_.bool_and_->MergeFrom(*from._impl_.constraint_.bool_and_);
        }
        break;
      }
      case kAtMostOne: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.at_most_one_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.at_most_one_);
        } else {
          _this->_impl_.constraint_.at_most_one_->MergeFrom(*from._impl_.constraint_.at_most_one_);
        }
        break;
      }
      case kExactlyOne: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.exactly_one_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.exactly_one_);
        } else {
          _this->_impl_.constraint_.exactly_one_->MergeFrom(*from._impl_.constraint_.exactly_one_);
        }
        break;
      }
      case kBoolXor: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.bool_xor_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.bool_xor_);
        } else {
          _this->_impl_.constraint_.bool_xor_->MergeFrom(*from._impl_.constraint_.bool_xor_);
        }
        break;
      }
      case kIntDiv: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.int_div_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_div_);
        } else {
          _this->_impl_.constraint_.int_div_->MergeFrom(*from._impl_.constraint_.int_div_);
        }
        break;
      }
      case kIntMod: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.int_mod_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_mod_);
        } else {
          _this->_impl_.constraint_.int_mod_->MergeFrom(*from._impl_.constraint_.int_mod_);
        }
        break;
      }
      case kIntProd: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.int_prod_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.int_prod_);
        } else {
          _this->_impl_.constraint_.int_prod_->MergeFrom(*from._impl_.constraint_.int_prod_);
        }
        break;
      }
      case kLinMax: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.lin_max_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.lin_max_);
        } else {
          _this->_impl_.constraint_.lin_max_->MergeFrom(*from._impl_.constraint_.lin_max_);
        }
        break;
      }
      case kLinear: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.linear_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.linear_);
        } else {
          _this->_impl_.constraint_.linear_->MergeFrom(*from._impl_.constraint_.linear_);
        }
        break;
      }
      case kAllDiff: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.all_diff_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.all_diff_);
        } else {
          _this->_impl_.constraint_.all_diff_->MergeFrom(*from._impl_.constraint_.all_diff_);
        }
        break;
      }
      case kElement: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.element_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.element_);
        } else {
          _this->_impl_.constraint_.element_->MergeFrom(*from._impl_.constraint_.element_);
        }
        break;
      }
      case kCircuit: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.circuit_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.circuit_);
        } else {
          _this->_impl_.constraint_.circuit_->MergeFrom(*from._impl_.constraint_.circuit_);
        }
        break;
      }
      case kRoutes: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.routes_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.routes_);
        } else {
          _this->_impl_.constraint_.routes_->MergeFrom(*from._impl_.constraint_.routes_);
        }
        break;
      }
      case kTable: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.table_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.table_);
        } else {
          _this->_impl_.constraint_.table_->MergeFrom(*from._impl_.constraint_.table_);
        }
        break;
      }
      case kAutomaton: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.automaton_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.automaton_);
        } else {
          _this->_impl_.constraint_.automaton_->MergeFrom(*from._impl_.constraint_.automaton_);
        }
        break;
      }
      case kInverse: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.inverse_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.inverse_);
        } else {
          _this->_impl_.constraint_.inverse_->MergeFrom(*from._impl_.constraint_.inverse_);
        }
        break;
      }
      case kReservoir: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.reservoir_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.reservoir_);
        } else {
          _this->_impl_.constraint_.reservoir_->MergeFrom(*from._impl_.constraint_.reservoir_);
        }
        break;
      }
      case kInterval: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.interval_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.interval_);
        } else {
          _this->_impl_.constraint_.interval_->MergeFrom(*from._impl_.constraint_.interval_);
        }
        break;
      }
      case kNoOverlap: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.no_overlap_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.no_overlap_);
        } else {
          _this->_impl_.constraint_.no_overlap_->MergeFrom(*from._impl_.constraint_.no_overlap_);
        }
        break;
      }
      case kNoOverlap2D: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.no_overlap_2d_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.no_overlap_2d_);
        } else {
          _this->_impl_.constraint_.no_overlap_2d_->MergeFrom(*from._impl_.constraint_.no_overlap_2d_);
        }
        break;
      }
      case kCumulative: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.cumulative_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.cumulative_);
        } else {
          _this->_impl_.constraint_.cumulative_->MergeFrom(*from._impl_.constraint_.cumulative_);
        }
        break;
      }
      case kDummyConstraint: {
        if (oneof_needs_init) {
          _this->_impl_.constraint_.dummy_constraint_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.constraint_.dummy_constraint_);
        } else {
          _this->_impl_.constraint_.dummy_constraint_->MergeFrom(*from._impl_.constraint_.dummy_constraint_);
        }
        break;
      }
      case CONSTRAINT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ConstraintProto::CopyFrom(const ConstraintProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ConstraintProto::InternalSwap(ConstraintProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.enforcement_literal_.InternalSwap(&other->_impl_.enforcement_literal_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  swap(_impl_.constraint_, other->_impl_.constraint_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ConstraintProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CpObjectiveProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CpObjectiveProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_._has_bits_);
};

CpObjectiveProto::CpObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpObjectiveProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpObjectiveProto)
}
PROTOBUF_NDEBUG_INLINE CpObjectiveProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CpObjectiveProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena, from.coeffs_},
        _coeffs_cached_byte_size_{0},
        domain_{visibility, arena, from.domain_},
        _domain_cached_byte_size_{0} {}

CpObjectiveProto::CpObjectiveProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CpObjectiveProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpObjectiveProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CpObjectiveProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, offset_),
           offsetof(Impl_, scaling_was_exact_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::scaling_was_exact_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpObjectiveProto)
}
PROTOBUF_NDEBUG_INLINE CpObjectiveProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena},
        _coeffs_cached_byte_size_{0},
        domain_{visibility, arena},
        _domain_cached_byte_size_{0} {}

inline void CpObjectiveProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           0,
           offsetof(Impl_, scaling_was_exact_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::scaling_was_exact_));
}
CpObjectiveProto::~CpObjectiveProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpObjectiveProto)
  SharedDtor(*this);
}
inline void CpObjectiveProto::SharedDtor(MessageLite& self) {
  CpObjectiveProto& this_ = static_cast<CpObjectiveProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CpObjectiveProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CpObjectiveProto(arena);
}
constexpr auto CpObjectiveProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.vars_) +
          decltype(CpObjectiveProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.coeffs_) +
          decltype(CpObjectiveProto::_impl_.coeffs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.domain_) +
          decltype(CpObjectiveProto::_impl_.domain_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CpObjectiveProto), alignof(CpObjectiveProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CpObjectiveProto::PlacementNew_,
                                 sizeof(CpObjectiveProto),
                                 alignof(CpObjectiveProto));
  }
}
constexpr auto CpObjectiveProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CpObjectiveProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CpObjectiveProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CpObjectiveProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CpObjectiveProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CpObjectiveProto>(), &CpObjectiveProto::ByteSizeLong,
              &CpObjectiveProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_._cached_size_),
          false,
      },
      &CpObjectiveProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CpObjectiveProto_class_data_ =
        CpObjectiveProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CpObjectiveProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CpObjectiveProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CpObjectiveProto_class_data_.tc_table);
  return CpObjectiveProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 0, 2>
CpObjectiveProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CpObjectiveProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CpObjectiveProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.vars_)}},
    // double offset = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 3, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.offset_)}},
    // double scaling_factor = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 4, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_factor_)}},
    // repeated int64 coeffs = 4;
    {::_pbi::TcParser::FastV64P1,
     {34, 1, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.coeffs_)}},
    // repeated int64 domain = 5;
    {::_pbi::TcParser::FastV64P1,
     {42, 2, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.domain_)}},
    // bool scaling_was_exact = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CpObjectiveProto, _impl_.scaling_was_exact_), 8>(),
     {48, 8, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_was_exact_)}},
    // int64 integer_before_offset = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpObjectiveProto, _impl_.integer_before_offset_), 5>(),
     {56, 5, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_before_offset_)}},
    // int64 integer_scaling_factor = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpObjectiveProto, _impl_.integer_scaling_factor_), 6>(),
     {64, 6, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_scaling_factor_)}},
    // int64 integer_after_offset = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpObjectiveProto, _impl_.integer_after_offset_), 7>(),
     {72, 7, 0,
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_after_offset_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // double offset = 2;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.offset_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double scaling_factor = 3;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_factor_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // repeated int64 coeffs = 4;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.coeffs_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 domain = 5;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.domain_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // bool scaling_was_exact = 6;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_was_exact_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // int64 integer_before_offset = 7;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_before_offset_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 integer_scaling_factor = 8;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_scaling_factor_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 integer_after_offset = 9;
    {PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.integer_after_offset_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CpObjectiveProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpObjectiveProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.coeffs_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.domain_.Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000f8U)) {
    ::memset(&_impl_.offset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.integer_after_offset_) -
        reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.integer_after_offset_));
  }
  _impl_.scaling_was_exact_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CpObjectiveProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CpObjectiveProto& this_ = static_cast<const CpObjectiveProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CpObjectiveProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CpObjectiveProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpObjectiveProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // double offset = 2;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_offset()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          2, this_._internal_offset(), target);
    }
  }

  // double scaling_factor = 3;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_scaling_factor()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          3, this_._internal_scaling_factor(), target);
    }
  }

  // repeated int64 coeffs = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._coeffs_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            4, this_._internal_coeffs(), byte_size, target);
      }
    }
  }

  // repeated int64 domain = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._domain_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            5, this_._internal_domain(), byte_size, target);
      }
    }
  }

  // bool scaling_was_exact = 6;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    if (this_._internal_scaling_was_exact() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_scaling_was_exact(), target);
    }
  }

  // int64 integer_before_offset = 7;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (this_._internal_integer_before_offset() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<7>(
              stream, this_._internal_integer_before_offset(), target);
    }
  }

  // int64 integer_scaling_factor = 8;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    if (this_._internal_integer_scaling_factor() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<8>(
              stream, this_._internal_integer_scaling_factor(), target);
    }
  }

  // int64 integer_after_offset = 9;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (this_._internal_integer_after_offset() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<9>(
              stream, this_._internal_integer_after_offset(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpObjectiveProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CpObjectiveProto::ByteSizeLong(const MessageLite& base) {
  const CpObjectiveProto& this_ = static_cast<const CpObjectiveProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CpObjectiveProto::ByteSizeLong() const {
  const CpObjectiveProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpObjectiveProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated int64 coeffs = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_coeffs(), 1,
              this_._impl_._coeffs_cached_byte_size_);
    }
    // repeated int64 domain = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_domain(), 1,
              this_._impl_._domain_cached_byte_size_);
    }
    // double offset = 2;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_offset()) != 0) {
        total_size += 9;
      }
    }
    // double scaling_factor = 3;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_scaling_factor()) != 0) {
        total_size += 9;
      }
    }
    // int64 integer_before_offset = 7;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (this_._internal_integer_before_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_integer_before_offset());
      }
    }
    // int64 integer_scaling_factor = 8;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (this_._internal_integer_scaling_factor() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_integer_scaling_factor());
      }
    }
    // int64 integer_after_offset = 9;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (this_._internal_integer_after_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_integer_after_offset());
      }
    }
  }
   {
    // bool scaling_was_exact = 6;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      if (this_._internal_scaling_was_exact() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CpObjectiveProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CpObjectiveProto*>(&to_msg);
  auto& from = static_cast<const CpObjectiveProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpObjectiveProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_coeffs()->MergeFrom(from._internal_coeffs());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_domain()->MergeFrom(from._internal_domain());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_offset()) != 0) {
        _this->_impl_.offset_ = from._impl_.offset_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_scaling_factor()) != 0) {
        _this->_impl_.scaling_factor_ = from._impl_.scaling_factor_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (from._internal_integer_before_offset() != 0) {
        _this->_impl_.integer_before_offset_ = from._impl_.integer_before_offset_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      if (from._internal_integer_scaling_factor() != 0) {
        _this->_impl_.integer_scaling_factor_ = from._impl_.integer_scaling_factor_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (from._internal_integer_after_offset() != 0) {
        _this->_impl_.integer_after_offset_ = from._impl_.integer_after_offset_;
      }
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    if (from._internal_scaling_was_exact() != 0) {
      _this->_impl_.scaling_was_exact_ = from._impl_.scaling_was_exact_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CpObjectiveProto::CopyFrom(const CpObjectiveProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpObjectiveProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CpObjectiveProto::InternalSwap(CpObjectiveProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_was_exact_)
      + sizeof(CpObjectiveProto::_impl_.scaling_was_exact_)
      - PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::google::protobuf::Metadata CpObjectiveProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FloatObjectiveProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FloatObjectiveProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_._has_bits_);
};

FloatObjectiveProto::FloatObjectiveProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FloatObjectiveProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.FloatObjectiveProto)
}
PROTOBUF_NDEBUG_INLINE FloatObjectiveProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::FloatObjectiveProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena, from.coeffs_} {}

FloatObjectiveProto::FloatObjectiveProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FloatObjectiveProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FloatObjectiveProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FloatObjectiveProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, offset_),
           offsetof(Impl_, maximize_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::maximize_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.FloatObjectiveProto)
}
PROTOBUF_NDEBUG_INLINE FloatObjectiveProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        coeffs_{visibility, arena} {}

inline void FloatObjectiveProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, offset_),
           0,
           offsetof(Impl_, maximize_) -
               offsetof(Impl_, offset_) +
               sizeof(Impl_::maximize_));
}
FloatObjectiveProto::~FloatObjectiveProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.FloatObjectiveProto)
  SharedDtor(*this);
}
inline void FloatObjectiveProto::SharedDtor(MessageLite& self) {
  FloatObjectiveProto& this_ = static_cast<FloatObjectiveProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FloatObjectiveProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FloatObjectiveProto(arena);
}
constexpr auto FloatObjectiveProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.vars_) +
          decltype(FloatObjectiveProto::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.coeffs_) +
          decltype(FloatObjectiveProto::_impl_.coeffs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(FloatObjectiveProto), alignof(FloatObjectiveProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&FloatObjectiveProto::PlacementNew_,
                                 sizeof(FloatObjectiveProto),
                                 alignof(FloatObjectiveProto));
  }
}
constexpr auto FloatObjectiveProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FloatObjectiveProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FloatObjectiveProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FloatObjectiveProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FloatObjectiveProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FloatObjectiveProto>(), &FloatObjectiveProto::ByteSizeLong,
              &FloatObjectiveProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_._cached_size_),
          false,
      },
      &FloatObjectiveProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FloatObjectiveProto_class_data_ =
        FloatObjectiveProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FloatObjectiveProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FloatObjectiveProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FloatObjectiveProto_class_data_.tc_table);
  return FloatObjectiveProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
FloatObjectiveProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    FloatObjectiveProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::FloatObjectiveProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool maximize = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FloatObjectiveProto, _impl_.maximize_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.maximize_)}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.vars_)}},
    // repeated double coeffs = 2;
    {::_pbi::TcParser::FastF64P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.coeffs_)}},
    // double offset = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 2, 0,
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.offset_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated double coeffs = 2;
    {PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.coeffs_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedDouble)},
    // double offset = 3;
    {PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.offset_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // bool maximize = 4;
    {PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.maximize_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void FloatObjectiveProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.FloatObjectiveProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.coeffs_.Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.offset_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.maximize_) -
        reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.maximize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FloatObjectiveProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FloatObjectiveProto& this_ = static_cast<const FloatObjectiveProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FloatObjectiveProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FloatObjectiveProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.FloatObjectiveProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated double coeffs = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    if (this_._internal_coeffs_size() > 0) {
      target = stream->WriteFixedPacked(2, this_._internal_coeffs(), target);
    }
  }

  // double offset = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_offset()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          3, this_._internal_offset(), target);
    }
  }

  // bool maximize = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_maximize() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_maximize(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.FloatObjectiveProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FloatObjectiveProto::ByteSizeLong(const MessageLite& base) {
  const FloatObjectiveProto& this_ = static_cast<const FloatObjectiveProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FloatObjectiveProto::ByteSizeLong() const {
  const FloatObjectiveProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.FloatObjectiveProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated double coeffs = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::size_t{8} *
          ::_pbi::FromIntSize(this_._internal_coeffs_size());
      ::size_t tag_size = data_size == 0
          ? 0
          : 1 + ::_pbi::WireFormatLite::Int32Size(
                              static_cast<::int32_t>(data_size));
      total_size += tag_size + data_size;
    }
    // double offset = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_offset()) != 0) {
        total_size += 9;
      }
    }
    // bool maximize = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_maximize() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FloatObjectiveProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<FloatObjectiveProto*>(&to_msg);
  auto& from = static_cast<const FloatObjectiveProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.FloatObjectiveProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_coeffs()->MergeFrom(from._internal_coeffs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_offset()) != 0) {
        _this->_impl_.offset_ = from._impl_.offset_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_maximize() != 0) {
        _this->_impl_.maximize_ = from._impl_.maximize_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void FloatObjectiveProto::CopyFrom(const FloatObjectiveProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.FloatObjectiveProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FloatObjectiveProto::InternalSwap(FloatObjectiveProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.maximize_)
      + sizeof(FloatObjectiveProto::_impl_.maximize_)
      - PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::google::protobuf::Metadata FloatObjectiveProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DecisionStrategyProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DecisionStrategyProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_._has_bits_);
};

DecisionStrategyProto::DecisionStrategyProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DecisionStrategyProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.DecisionStrategyProto)
}
PROTOBUF_NDEBUG_INLINE DecisionStrategyProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::DecisionStrategyProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        variables_{visibility, arena, from.variables_},
        _variables_cached_byte_size_{0},
        exprs_{visibility, arena, from.exprs_} {}

DecisionStrategyProto::DecisionStrategyProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DecisionStrategyProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DecisionStrategyProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DecisionStrategyProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, variable_selection_strategy_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, variable_selection_strategy_),
           offsetof(Impl_, domain_reduction_strategy_) -
               offsetof(Impl_, variable_selection_strategy_) +
               sizeof(Impl_::domain_reduction_strategy_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.DecisionStrategyProto)
}
PROTOBUF_NDEBUG_INLINE DecisionStrategyProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        variables_{visibility, arena},
        _variables_cached_byte_size_{0},
        exprs_{visibility, arena} {}

inline void DecisionStrategyProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, variable_selection_strategy_),
           0,
           offsetof(Impl_, domain_reduction_strategy_) -
               offsetof(Impl_, variable_selection_strategy_) +
               sizeof(Impl_::domain_reduction_strategy_));
}
DecisionStrategyProto::~DecisionStrategyProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.DecisionStrategyProto)
  SharedDtor(*this);
}
inline void DecisionStrategyProto::SharedDtor(MessageLite& self) {
  DecisionStrategyProto& this_ = static_cast<DecisionStrategyProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DecisionStrategyProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DecisionStrategyProto(arena);
}
constexpr auto DecisionStrategyProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variables_) +
          decltype(DecisionStrategyProto::_impl_.variables_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.exprs_) +
          decltype(DecisionStrategyProto::_impl_.exprs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DecisionStrategyProto), alignof(DecisionStrategyProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DecisionStrategyProto::PlacementNew_,
                                 sizeof(DecisionStrategyProto),
                                 alignof(DecisionStrategyProto));
  }
}
constexpr auto DecisionStrategyProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DecisionStrategyProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DecisionStrategyProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DecisionStrategyProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DecisionStrategyProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DecisionStrategyProto>(), &DecisionStrategyProto::ByteSizeLong,
              &DecisionStrategyProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_._cached_size_),
          false,
      },
      &DecisionStrategyProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DecisionStrategyProto_class_data_ =
        DecisionStrategyProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DecisionStrategyProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DecisionStrategyProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DecisionStrategyProto_class_data_.tc_table);
  return DecisionStrategyProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 1, 0, 2>
DecisionStrategyProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    DecisionStrategyProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::DecisionStrategyProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 variables = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variables_)}},
    // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DecisionStrategyProto, _impl_.variable_selection_strategy_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variable_selection_strategy_)}},
    // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DecisionStrategyProto, _impl_.domain_reduction_strategy_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.domain_reduction_strategy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 1, 0,
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.exprs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 variables = 1;
    {PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variables_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
    {PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variable_selection_strategy_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
    {PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.domain_reduction_strategy_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // repeated .operations_research.sat.LinearExpressionProto exprs = 5;
    {PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.exprs_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::LinearExpressionProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void DecisionStrategyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.DecisionStrategyProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.variables_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.exprs_.Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.variable_selection_strategy_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.domain_reduction_strategy_) -
        reinterpret_cast<char*>(&_impl_.variable_selection_strategy_)) + sizeof(_impl_.domain_reduction_strategy_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DecisionStrategyProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DecisionStrategyProto& this_ = static_cast<const DecisionStrategyProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DecisionStrategyProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DecisionStrategyProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.DecisionStrategyProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 variables = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._variables_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_variables(), byte_size, target);
      }
    }
  }

  // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_variable_selection_strategy() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          2, this_._internal_variable_selection_strategy(), target);
    }
  }

  // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    if (this_._internal_domain_reduction_strategy() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_domain_reduction_strategy(), target);
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_exprs_size());
         i < n; i++) {
      const auto& repfield = this_._internal_exprs().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              5, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.DecisionStrategyProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DecisionStrategyProto::ByteSizeLong(const MessageLite& base) {
  const DecisionStrategyProto& this_ = static_cast<const DecisionStrategyProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DecisionStrategyProto::ByteSizeLong() const {
  const DecisionStrategyProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.DecisionStrategyProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated int32 variables = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_variables(), 1,
              this_._impl_._variables_cached_byte_size_);
    }
    // repeated .operations_research.sat.LinearExpressionProto exprs = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_exprs_size();
      for (const auto& msg : this_._internal_exprs()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_variable_selection_strategy() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_variable_selection_strategy());
      }
    }
    // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (this_._internal_domain_reduction_strategy() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_domain_reduction_strategy());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DecisionStrategyProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DecisionStrategyProto*>(&to_msg);
  auto& from = static_cast<const DecisionStrategyProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.DecisionStrategyProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_variables()->MergeFrom(from._internal_variables());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_exprs()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_exprs());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_variable_selection_strategy() != 0) {
        _this->_impl_.variable_selection_strategy_ = from._impl_.variable_selection_strategy_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      if (from._internal_domain_reduction_strategy() != 0) {
        _this->_impl_.domain_reduction_strategy_ = from._impl_.domain_reduction_strategy_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DecisionStrategyProto::CopyFrom(const DecisionStrategyProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.DecisionStrategyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DecisionStrategyProto::InternalSwap(DecisionStrategyProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.variables_.InternalSwap(&other->_impl_.variables_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.domain_reduction_strategy_)
      + sizeof(DecisionStrategyProto::_impl_.domain_reduction_strategy_)
      - PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variable_selection_strategy_)>(
          reinterpret_cast<char*>(&_impl_.variable_selection_strategy_),
          reinterpret_cast<char*>(&other->_impl_.variable_selection_strategy_));
}

::google::protobuf::Metadata DecisionStrategyProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PartialVariableAssignment::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PartialVariableAssignment>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_._has_bits_);
};

PartialVariableAssignment::PartialVariableAssignment(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PartialVariableAssignment_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.PartialVariableAssignment)
}
PROTOBUF_NDEBUG_INLINE PartialVariableAssignment::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::PartialVariableAssignment& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        vars_{visibility, arena, from.vars_},
        _vars_cached_byte_size_{0},
        values_{visibility, arena, from.values_},
        _values_cached_byte_size_{0} {}

PartialVariableAssignment::PartialVariableAssignment(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PartialVariableAssignment& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PartialVariableAssignment_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PartialVariableAssignment* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.PartialVariableAssignment)
}
PROTOBUF_NDEBUG_INLINE PartialVariableAssignment::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        vars_{visibility, arena},
        _vars_cached_byte_size_{0},
        values_{visibility, arena},
        _values_cached_byte_size_{0} {}

inline void PartialVariableAssignment::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PartialVariableAssignment::~PartialVariableAssignment() {
  // @@protoc_insertion_point(destructor:operations_research.sat.PartialVariableAssignment)
  SharedDtor(*this);
}
inline void PartialVariableAssignment::SharedDtor(MessageLite& self) {
  PartialVariableAssignment& this_ = static_cast<PartialVariableAssignment&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PartialVariableAssignment::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PartialVariableAssignment(arena);
}
constexpr auto PartialVariableAssignment::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.vars_) +
          decltype(PartialVariableAssignment::_impl_.vars_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.values_) +
          decltype(PartialVariableAssignment::_impl_.values_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(PartialVariableAssignment), alignof(PartialVariableAssignment), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&PartialVariableAssignment::PlacementNew_,
                                 sizeof(PartialVariableAssignment),
                                 alignof(PartialVariableAssignment));
  }
}
constexpr auto PartialVariableAssignment::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PartialVariableAssignment_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PartialVariableAssignment::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PartialVariableAssignment>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PartialVariableAssignment::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PartialVariableAssignment>(), &PartialVariableAssignment::ByteSizeLong,
              &PartialVariableAssignment::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_._cached_size_),
          false,
      },
      &PartialVariableAssignment::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PartialVariableAssignment_class_data_ =
        PartialVariableAssignment::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PartialVariableAssignment::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PartialVariableAssignment_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PartialVariableAssignment_class_data_.tc_table);
  return PartialVariableAssignment_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
PartialVariableAssignment::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PartialVariableAssignment_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::PartialVariableAssignment>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int64 values = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.values_)}},
    // repeated int32 vars = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.vars_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 vars = 1;
    {PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.vars_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int64 values = 2;
    {PROTOBUF_FIELD_OFFSET(PartialVariableAssignment, _impl_.values_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PartialVariableAssignment::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.PartialVariableAssignment)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.vars_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.values_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PartialVariableAssignment::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PartialVariableAssignment& this_ = static_cast<const PartialVariableAssignment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PartialVariableAssignment::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PartialVariableAssignment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.PartialVariableAssignment)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 vars = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._vars_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_vars(), byte_size, target);
      }
    }
  }

  // repeated int64 values = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._values_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_values(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.PartialVariableAssignment)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PartialVariableAssignment::ByteSizeLong(const MessageLite& base) {
  const PartialVariableAssignment& this_ = static_cast<const PartialVariableAssignment&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PartialVariableAssignment::ByteSizeLong() const {
  const PartialVariableAssignment& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.PartialVariableAssignment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int32 vars = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_vars(), 1,
              this_._impl_._vars_cached_byte_size_);
    }
    // repeated int64 values = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_values(), 1,
              this_._impl_._values_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PartialVariableAssignment::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PartialVariableAssignment*>(&to_msg);
  auto& from = static_cast<const PartialVariableAssignment&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.PartialVariableAssignment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_vars()->MergeFrom(from._internal_vars());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_values()->MergeFrom(from._internal_values());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PartialVariableAssignment::CopyFrom(const PartialVariableAssignment& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.PartialVariableAssignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PartialVariableAssignment::InternalSwap(PartialVariableAssignment* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
}

::google::protobuf::Metadata PartialVariableAssignment::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SparsePermutationProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SparsePermutationProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_._has_bits_);
};

SparsePermutationProto::SparsePermutationProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SparsePermutationProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.SparsePermutationProto)
}
PROTOBUF_NDEBUG_INLINE SparsePermutationProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::SparsePermutationProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        support_{visibility, arena, from.support_},
        _support_cached_byte_size_{0},
        cycle_sizes_{visibility, arena, from.cycle_sizes_},
        _cycle_sizes_cached_byte_size_{0} {}

SparsePermutationProto::SparsePermutationProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SparsePermutationProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SparsePermutationProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SparsePermutationProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.SparsePermutationProto)
}
PROTOBUF_NDEBUG_INLINE SparsePermutationProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        support_{visibility, arena},
        _support_cached_byte_size_{0},
        cycle_sizes_{visibility, arena},
        _cycle_sizes_cached_byte_size_{0} {}

inline void SparsePermutationProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SparsePermutationProto::~SparsePermutationProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.SparsePermutationProto)
  SharedDtor(*this);
}
inline void SparsePermutationProto::SharedDtor(MessageLite& self) {
  SparsePermutationProto& this_ = static_cast<SparsePermutationProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SparsePermutationProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SparsePermutationProto(arena);
}
constexpr auto SparsePermutationProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.support_) +
          decltype(SparsePermutationProto::_impl_.support_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.cycle_sizes_) +
          decltype(SparsePermutationProto::_impl_.cycle_sizes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SparsePermutationProto), alignof(SparsePermutationProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SparsePermutationProto::PlacementNew_,
                                 sizeof(SparsePermutationProto),
                                 alignof(SparsePermutationProto));
  }
}
constexpr auto SparsePermutationProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SparsePermutationProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SparsePermutationProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SparsePermutationProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SparsePermutationProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SparsePermutationProto>(), &SparsePermutationProto::ByteSizeLong,
              &SparsePermutationProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_._cached_size_),
          false,
      },
      &SparsePermutationProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SparsePermutationProto_class_data_ =
        SparsePermutationProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SparsePermutationProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SparsePermutationProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SparsePermutationProto_class_data_.tc_table);
  return SparsePermutationProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
SparsePermutationProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SparsePermutationProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::SparsePermutationProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 cycle_sizes = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.cycle_sizes_)}},
    // repeated int32 support = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.support_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 support = 1;
    {PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.support_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 cycle_sizes = 2;
    {PROTOBUF_FIELD_OFFSET(SparsePermutationProto, _impl_.cycle_sizes_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SparsePermutationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.SparsePermutationProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.support_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.cycle_sizes_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SparsePermutationProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SparsePermutationProto& this_ = static_cast<const SparsePermutationProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SparsePermutationProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SparsePermutationProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.SparsePermutationProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int32 support = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._support_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            1, this_._internal_support(), byte_size, target);
      }
    }
  }

  // repeated int32 cycle_sizes = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    {
      int byte_size = this_._impl_._cycle_sizes_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            2, this_._internal_cycle_sizes(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.SparsePermutationProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SparsePermutationProto::ByteSizeLong(const MessageLite& base) {
  const SparsePermutationProto& this_ = static_cast<const SparsePermutationProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SparsePermutationProto::ByteSizeLong() const {
  const SparsePermutationProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.SparsePermutationProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated int32 support = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_support(), 1,
              this_._impl_._support_cached_byte_size_);
    }
    // repeated int32 cycle_sizes = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_cycle_sizes(), 1,
              this_._impl_._cycle_sizes_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SparsePermutationProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<SparsePermutationProto*>(&to_msg);
  auto& from = static_cast<const SparsePermutationProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.SparsePermutationProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_support()->MergeFrom(from._internal_support());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_cycle_sizes()->MergeFrom(from._internal_cycle_sizes());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void SparsePermutationProto::CopyFrom(const SparsePermutationProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.SparsePermutationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SparsePermutationProto::InternalSwap(SparsePermutationProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.support_.InternalSwap(&other->_impl_.support_);
  _impl_.cycle_sizes_.InternalSwap(&other->_impl_.cycle_sizes_);
}

::google::protobuf::Metadata SparsePermutationProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DenseMatrixProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DenseMatrixProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_._has_bits_);
};

DenseMatrixProto::DenseMatrixProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DenseMatrixProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.DenseMatrixProto)
}
PROTOBUF_NDEBUG_INLINE DenseMatrixProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::DenseMatrixProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        entries_{visibility, arena, from.entries_},
        _entries_cached_byte_size_{0} {}

DenseMatrixProto::DenseMatrixProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DenseMatrixProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DenseMatrixProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DenseMatrixProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, num_rows_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, num_rows_),
           offsetof(Impl_, num_cols_) -
               offsetof(Impl_, num_rows_) +
               sizeof(Impl_::num_cols_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.DenseMatrixProto)
}
PROTOBUF_NDEBUG_INLINE DenseMatrixProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        entries_{visibility, arena},
        _entries_cached_byte_size_{0} {}

inline void DenseMatrixProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, num_rows_),
           0,
           offsetof(Impl_, num_cols_) -
               offsetof(Impl_, num_rows_) +
               sizeof(Impl_::num_cols_));
}
DenseMatrixProto::~DenseMatrixProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.DenseMatrixProto)
  SharedDtor(*this);
}
inline void DenseMatrixProto::SharedDtor(MessageLite& self) {
  DenseMatrixProto& this_ = static_cast<DenseMatrixProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DenseMatrixProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DenseMatrixProto(arena);
}
constexpr auto DenseMatrixProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.entries_) +
          decltype(DenseMatrixProto::_impl_.entries_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(DenseMatrixProto), alignof(DenseMatrixProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&DenseMatrixProto::PlacementNew_,
                                 sizeof(DenseMatrixProto),
                                 alignof(DenseMatrixProto));
  }
}
constexpr auto DenseMatrixProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DenseMatrixProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DenseMatrixProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DenseMatrixProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DenseMatrixProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DenseMatrixProto>(), &DenseMatrixProto::ByteSizeLong,
              &DenseMatrixProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_._cached_size_),
          false,
      },
      &DenseMatrixProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DenseMatrixProto_class_data_ =
        DenseMatrixProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DenseMatrixProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DenseMatrixProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DenseMatrixProto_class_data_.tc_table);
  return DenseMatrixProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
DenseMatrixProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DenseMatrixProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::DenseMatrixProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 num_rows = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DenseMatrixProto, _impl_.num_rows_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_rows_)}},
    // int32 num_cols = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DenseMatrixProto, _impl_.num_cols_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_cols_)}},
    // repeated int32 entries = 3;
    {::_pbi::TcParser::FastV32P1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.entries_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 num_rows = 1;
    {PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_rows_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 num_cols = 2;
    {PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_cols_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated int32 entries = 3;
    {PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.entries_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void DenseMatrixProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.DenseMatrixProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.entries_.Clear();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    ::memset(&_impl_.num_rows_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.num_cols_) -
        reinterpret_cast<char*>(&_impl_.num_rows_)) + sizeof(_impl_.num_cols_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DenseMatrixProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DenseMatrixProto& this_ = static_cast<const DenseMatrixProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DenseMatrixProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DenseMatrixProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.DenseMatrixProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // int32 num_rows = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    if (this_._internal_num_rows() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_num_rows(), target);
    }
  }

  // int32 num_cols = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    if (this_._internal_num_cols() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
              stream, this_._internal_num_cols(), target);
    }
  }

  // repeated int32 entries = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._entries_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            3, this_._internal_entries(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.DenseMatrixProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DenseMatrixProto::ByteSizeLong(const MessageLite& base) {
  const DenseMatrixProto& this_ = static_cast<const DenseMatrixProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DenseMatrixProto::ByteSizeLong() const {
  const DenseMatrixProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.DenseMatrixProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated int32 entries = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_entries(), 1,
              this_._impl_._entries_cached_byte_size_);
    }
    // int32 num_rows = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (this_._internal_num_rows() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_num_rows());
      }
    }
    // int32 num_cols = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (this_._internal_num_cols() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_num_cols());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DenseMatrixProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<DenseMatrixProto*>(&to_msg);
  auto& from = static_cast<const DenseMatrixProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.DenseMatrixProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_entries()->MergeFrom(from._internal_entries());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      if (from._internal_num_rows() != 0) {
        _this->_impl_.num_rows_ = from._impl_.num_rows_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      if (from._internal_num_cols() != 0) {
        _this->_impl_.num_cols_ = from._impl_.num_cols_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void DenseMatrixProto::CopyFrom(const DenseMatrixProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.DenseMatrixProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DenseMatrixProto::InternalSwap(DenseMatrixProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_cols_)
      + sizeof(DenseMatrixProto::_impl_.num_cols_)
      - PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_rows_)>(
          reinterpret_cast<char*>(&_impl_.num_rows_),
          reinterpret_cast<char*>(&other->_impl_.num_rows_));
}

::google::protobuf::Metadata DenseMatrixProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SymmetryProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SymmetryProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_._has_bits_);
};

SymmetryProto::SymmetryProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SymmetryProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.SymmetryProto)
}
PROTOBUF_NDEBUG_INLINE SymmetryProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::SymmetryProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        permutations_{visibility, arena, from.permutations_},
        orbitopes_{visibility, arena, from.orbitopes_} {}

SymmetryProto::SymmetryProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SymmetryProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SymmetryProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SymmetryProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.SymmetryProto)
}
PROTOBUF_NDEBUG_INLINE SymmetryProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        permutations_{visibility, arena},
        orbitopes_{visibility, arena} {}

inline void SymmetryProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SymmetryProto::~SymmetryProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.SymmetryProto)
  SharedDtor(*this);
}
inline void SymmetryProto::SharedDtor(MessageLite& self) {
  SymmetryProto& this_ = static_cast<SymmetryProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SymmetryProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SymmetryProto(arena);
}
constexpr auto SymmetryProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.permutations_) +
          decltype(SymmetryProto::_impl_.permutations_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.orbitopes_) +
          decltype(SymmetryProto::_impl_.orbitopes_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SymmetryProto), alignof(SymmetryProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SymmetryProto::PlacementNew_,
                                 sizeof(SymmetryProto),
                                 alignof(SymmetryProto));
  }
}
constexpr auto SymmetryProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SymmetryProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SymmetryProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SymmetryProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SymmetryProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SymmetryProto>(), &SymmetryProto::ByteSizeLong,
              &SymmetryProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_._cached_size_),
          false,
      },
      &SymmetryProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SymmetryProto_class_data_ =
        SymmetryProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SymmetryProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SymmetryProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SymmetryProto_class_data_.tc_table);
  return SymmetryProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2>
SymmetryProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    SymmetryProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::SymmetryProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 1, 1,
      PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.orbitopes_)}},
    // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.permutations_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
    {PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.permutations_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
    {PROTOBUF_FIELD_OFFSET(SymmetryProto, _impl_.orbitopes_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::SparsePermutationProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::DenseMatrixProto>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void SymmetryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.SymmetryProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.permutations_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.orbitopes_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SymmetryProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SymmetryProto& this_ = static_cast<const SymmetryProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SymmetryProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SymmetryProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.SymmetryProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_permutations_size());
         i < n; i++) {
      const auto& repfield = this_._internal_permutations().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_orbitopes_size());
         i < n; i++) {
      const auto& repfield = this_._internal_orbitopes().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.SymmetryProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SymmetryProto::ByteSizeLong(const MessageLite& base) {
  const SymmetryProto& this_ = static_cast<const SymmetryProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SymmetryProto::ByteSizeLong() const {
  const SymmetryProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.SymmetryProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_permutations_size();
      for (const auto& msg : this_._internal_permutations()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_orbitopes_size();
      for (const auto& msg : this_._internal_orbitopes()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SymmetryProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<SymmetryProto*>(&to_msg);
  auto& from = static_cast<const SymmetryProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.SymmetryProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_permutations()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_permutations());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_orbitopes()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_orbitopes());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void SymmetryProto::CopyFrom(const SymmetryProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.SymmetryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SymmetryProto::InternalSwap(SymmetryProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.permutations_.InternalSwap(&other->_impl_.permutations_);
  _impl_.orbitopes_.InternalSwap(&other->_impl_.orbitopes_);
}

::google::protobuf::Metadata SymmetryProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CpModelProto::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CpModelProto>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_._has_bits_);
};

CpModelProto::CpModelProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpModelProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpModelProto)
}
PROTOBUF_NDEBUG_INLINE CpModelProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CpModelProto& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        variables_{visibility, arena, from.variables_},
        constraints_{visibility, arena, from.constraints_},
        search_strategy_{visibility, arena, from.search_strategy_},
        assumptions_{visibility, arena, from.assumptions_},
        _assumptions_cached_byte_size_{0},
        name_(arena, from.name_) {}

CpModelProto::CpModelProto(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CpModelProto& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpModelProto_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CpModelProto* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.objective_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.objective_)
                : nullptr;
  _impl_.solution_hint_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.solution_hint_)
                : nullptr;
  _impl_.symmetry_ = (CheckHasBit(cached_has_bits, 0x00000080U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.symmetry_)
                : nullptr;
  _impl_.floating_point_objective_ = (CheckHasBit(cached_has_bits, 0x00000100U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.floating_point_objective_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpModelProto)
}
PROTOBUF_NDEBUG_INLINE CpModelProto::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        variables_{visibility, arena},
        constraints_{visibility, arena},
        search_strategy_{visibility, arena},
        assumptions_{visibility, arena},
        _assumptions_cached_byte_size_{0},
        name_(arena) {}

inline void CpModelProto::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, objective_),
           0,
           offsetof(Impl_, floating_point_objective_) -
               offsetof(Impl_, objective_) +
               sizeof(Impl_::floating_point_objective_));
}
CpModelProto::~CpModelProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpModelProto)
  SharedDtor(*this);
}
inline void CpModelProto::SharedDtor(MessageLite& self) {
  CpModelProto& this_ = static_cast<CpModelProto&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  delete this_._impl_.objective_;
  delete this_._impl_.solution_hint_;
  delete this_._impl_.symmetry_;
  delete this_._impl_.floating_point_objective_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CpModelProto::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CpModelProto(arena);
}
constexpr auto CpModelProto::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.variables_) +
          decltype(CpModelProto::_impl_.variables_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.constraints_) +
          decltype(CpModelProto::_impl_.constraints_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.search_strategy_) +
          decltype(CpModelProto::_impl_.search_strategy_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.assumptions_) +
          decltype(CpModelProto::_impl_.assumptions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CpModelProto), alignof(CpModelProto), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CpModelProto::PlacementNew_,
                                 sizeof(CpModelProto),
                                 alignof(CpModelProto));
  }
}
constexpr auto CpModelProto::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CpModelProto_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CpModelProto::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CpModelProto>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CpModelProto::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CpModelProto>(), &CpModelProto::ByteSizeLong,
              &CpModelProto::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_._cached_size_),
          false,
      },
      &CpModelProto::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CpModelProto_class_data_ =
        CpModelProto::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CpModelProto::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CpModelProto_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CpModelProto_class_data_.tc_table);
  return CpModelProto_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 7, 57, 2>
CpModelProto::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CpModelProto_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CpModelProto>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 4, 0,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.name_)}},
    // repeated .operations_research.sat.IntegerVariableProto variables = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.variables_)}},
    // repeated .operations_research.sat.ConstraintProto constraints = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 1, 1,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.constraints_)}},
    // .operations_research.sat.CpObjectiveProto objective = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 5, 2,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.objective_)}},
    // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 2, 3,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.search_strategy_)}},
    // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 6, 4,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.solution_hint_)}},
    // repeated int32 assumptions = 7;
    {::_pbi::TcParser::FastV32P1,
     {58, 3, 0,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.assumptions_)}},
    // .operations_research.sat.SymmetryProto symmetry = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 7, 5,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.symmetry_)}},
    // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 8, 6,
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.floating_point_objective_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.name_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .operations_research.sat.IntegerVariableProto variables = 2;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.variables_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .operations_research.sat.ConstraintProto constraints = 3;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.constraints_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.CpObjectiveProto objective = 4;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.objective_), _Internal::kHasBitsOffset + 5, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.search_strategy_), _Internal::kHasBitsOffset + 2, 3, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.solution_hint_), _Internal::kHasBitsOffset + 6, 4, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 assumptions = 7;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.assumptions_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // .operations_research.sat.SymmetryProto symmetry = 8;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.symmetry_), _Internal::kHasBitsOffset + 7, 5, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
    {PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.floating_point_objective_), _Internal::kHasBitsOffset + 8, 6, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::IntegerVariableProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::ConstraintProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::CpObjectiveProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::DecisionStrategyProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::PartialVariableAssignment>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::SymmetryProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::FloatObjectiveProto>()},
  }},
  {{
    "\44\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "operations_research.sat.CpModelProto"
    "name"
  }},
};
PROTOBUF_NOINLINE void CpModelProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpModelProto)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.variables_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.constraints_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.search_strategy_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _impl_.assumptions_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.objective_ != nullptr);
      _impl_.objective_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.solution_hint_ != nullptr);
      _impl_.solution_hint_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(_impl_.symmetry_ != nullptr);
      _impl_.symmetry_->Clear();
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    ABSL_DCHECK(_impl_.floating_point_objective_ != nullptr);
    _impl_.floating_point_objective_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CpModelProto::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CpModelProto& this_ = static_cast<const CpModelProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CpModelProto::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CpModelProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpModelProto)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // string name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_name().empty()) {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "operations_research.sat.CpModelProto.name");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // repeated .operations_research.sat.IntegerVariableProto variables = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_variables_size());
         i < n; i++) {
      const auto& repfield = this_._internal_variables().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .operations_research.sat.ConstraintProto constraints = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_constraints_size());
         i < n; i++) {
      const auto& repfield = this_._internal_constraints().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .operations_research.sat.CpObjectiveProto objective = 4;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.objective_, this_._impl_.objective_->GetCachedSize(), target,
        stream);
  }

  // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_search_strategy_size());
         i < n; i++) {
      const auto& repfield = this_._internal_search_strategy().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              5, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.solution_hint_, this_._impl_.solution_hint_->GetCachedSize(), target,
        stream);
  }

  // repeated int32 assumptions = 7;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
    {
      int byte_size = this_._impl_._assumptions_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            7, this_._internal_assumptions(), byte_size, target);
      }
    }
  }

  // .operations_research.sat.SymmetryProto symmetry = 8;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, *this_._impl_.symmetry_, this_._impl_.symmetry_->GetCachedSize(), target,
        stream);
  }

  // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, *this_._impl_.floating_point_objective_, this_._impl_.floating_point_objective_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpModelProto)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CpModelProto::ByteSizeLong(const MessageLite& base) {
  const CpModelProto& this_ = static_cast<const CpModelProto&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CpModelProto::ByteSizeLong() const {
  const CpModelProto& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpModelProto)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated .operations_research.sat.IntegerVariableProto variables = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_variables_size();
      for (const auto& msg : this_._internal_variables()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .operations_research.sat.ConstraintProto constraints = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_constraints_size();
      for (const auto& msg : this_._internal_constraints()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size += 1UL * this_._internal_search_strategy_size();
      for (const auto& msg : this_._internal_search_strategy()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated int32 assumptions = 7;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_assumptions(), 1,
              this_._impl_._assumptions_cached_byte_size_);
    }
    // string name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_name());
      }
    }
    // .operations_research.sat.CpObjectiveProto objective = 4;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.objective_);
    }
    // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.solution_hint_);
    }
    // .operations_research.sat.SymmetryProto symmetry = 8;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.symmetry_);
    }
  }
   {
    // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.floating_point_objective_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CpModelProto::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CpModelProto*>(&to_msg);
  auto& from = static_cast<const CpModelProto&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpModelProto)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_variables()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_variables());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_constraints()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_constraints());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_search_strategy()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_search_strategy());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _this->_internal_mutable_assumptions()->MergeFrom(from._internal_assumptions());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
      } else {
        if (_this->_impl_.name_.IsDefault()) {
          _this->_internal_set_name("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.objective_ != nullptr);
      if (_this->_impl_.objective_ == nullptr) {
        _this->_impl_.objective_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.objective_);
      } else {
        _this->_impl_.objective_->MergeFrom(*from._impl_.objective_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.solution_hint_ != nullptr);
      if (_this->_impl_.solution_hint_ == nullptr) {
        _this->_impl_.solution_hint_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.solution_hint_);
      } else {
        _this->_impl_.solution_hint_->MergeFrom(*from._impl_.solution_hint_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      ABSL_DCHECK(from._impl_.symmetry_ != nullptr);
      if (_this->_impl_.symmetry_ == nullptr) {
        _this->_impl_.symmetry_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.symmetry_);
      } else {
        _this->_impl_.symmetry_->MergeFrom(*from._impl_.symmetry_);
      }
    }
  }
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    ABSL_DCHECK(from._impl_.floating_point_objective_ != nullptr);
    if (_this->_impl_.floating_point_objective_ == nullptr) {
      _this->_impl_.floating_point_objective_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.floating_point_objective_);
    } else {
      _this->_impl_.floating_point_objective_->MergeFrom(*from._impl_.floating_point_objective_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CpModelProto::CopyFrom(const CpModelProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpModelProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CpModelProto::InternalSwap(CpModelProto* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.variables_.InternalSwap(&other->_impl_.variables_);
  _impl_.constraints_.InternalSwap(&other->_impl_.constraints_);
  _impl_.search_strategy_.InternalSwap(&other->_impl_.search_strategy_);
  _impl_.assumptions_.InternalSwap(&other->_impl_.assumptions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.floating_point_objective_)
      + sizeof(CpModelProto::_impl_.floating_point_objective_)
      - PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.objective_)>(
          reinterpret_cast<char*>(&_impl_.objective_),
          reinterpret_cast<char*>(&other->_impl_.objective_));
}

::google::protobuf::Metadata CpModelProto::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CpSolverSolution::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CpSolverSolution>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_._has_bits_);
};

CpSolverSolution::CpSolverSolution(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpSolverSolution_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpSolverSolution)
}
PROTOBUF_NDEBUG_INLINE CpSolverSolution::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CpSolverSolution& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        values_{visibility, arena, from.values_},
        _values_cached_byte_size_{0} {}

CpSolverSolution::CpSolverSolution(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CpSolverSolution& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpSolverSolution_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CpSolverSolution* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpSolverSolution)
}
PROTOBUF_NDEBUG_INLINE CpSolverSolution::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        values_{visibility, arena},
        _values_cached_byte_size_{0} {}

inline void CpSolverSolution::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CpSolverSolution::~CpSolverSolution() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpSolverSolution)
  SharedDtor(*this);
}
inline void CpSolverSolution::SharedDtor(MessageLite& self) {
  CpSolverSolution& this_ = static_cast<CpSolverSolution&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CpSolverSolution::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CpSolverSolution(arena);
}
constexpr auto CpSolverSolution::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_.values_) +
          decltype(CpSolverSolution::_impl_.values_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CpSolverSolution), alignof(CpSolverSolution), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CpSolverSolution::PlacementNew_,
                                 sizeof(CpSolverSolution),
                                 alignof(CpSolverSolution));
  }
}
constexpr auto CpSolverSolution::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CpSolverSolution_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CpSolverSolution::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CpSolverSolution>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CpSolverSolution::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CpSolverSolution>(), &CpSolverSolution::ByteSizeLong,
              &CpSolverSolution::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_._cached_size_),
          false,
      },
      &CpSolverSolution::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CpSolverSolution_class_data_ =
        CpSolverSolution::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CpSolverSolution::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CpSolverSolution_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CpSolverSolution_class_data_.tc_table);
  return CpSolverSolution_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
CpSolverSolution::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CpSolverSolution_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CpSolverSolution>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int64 values = 1;
    {::_pbi::TcParser::FastV64P1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_.values_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int64 values = 1;
    {PROTOBUF_FIELD_OFFSET(CpSolverSolution, _impl_.values_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CpSolverSolution::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpSolverSolution)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.values_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CpSolverSolution::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CpSolverSolution& this_ = static_cast<const CpSolverSolution&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CpSolverSolution::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CpSolverSolution& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpSolverSolution)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated int64 values = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._values_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            1, this_._internal_values(), byte_size, target);
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpSolverSolution)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CpSolverSolution::ByteSizeLong(const MessageLite& base) {
  const CpSolverSolution& this_ = static_cast<const CpSolverSolution&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CpSolverSolution::ByteSizeLong() const {
  const CpSolverSolution& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpSolverSolution)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated int64 values = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_values(), 1,
              this_._impl_._values_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CpSolverSolution::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CpSolverSolution*>(&to_msg);
  auto& from = static_cast<const CpSolverSolution&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpSolverSolution)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_values()->MergeFrom(from._internal_values());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CpSolverSolution::CopyFrom(const CpSolverSolution& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpSolverSolution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CpSolverSolution::InternalSwap(CpSolverSolution* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
}

::google::protobuf::Metadata CpSolverSolution::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CpSolverResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CpSolverResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_._has_bits_);
};

CpSolverResponse::CpSolverResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpSolverResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpSolverResponse)
}
PROTOBUF_NDEBUG_INLINE CpSolverResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::operations_research::sat::CpSolverResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        solution_{visibility, arena, from.solution_},
        _solution_cached_byte_size_{0},
        tightened_variables_{visibility, arena, from.tightened_variables_},
        sufficient_assumptions_for_infeasibility_{visibility, arena, from.sufficient_assumptions_for_infeasibility_},
        _sufficient_assumptions_for_infeasibility_cached_byte_size_{0},
        additional_solutions_{visibility, arena, from.additional_solutions_},
        solution_info_(arena, from.solution_info_),
        solve_log_(arena, from.solve_log_) {}

CpSolverResponse::CpSolverResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CpSolverResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CpSolverResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CpSolverResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.integer_objective_ = (CheckHasBit(cached_has_bits, 0x00000040U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.integer_objective_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, objective_value_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, objective_value_),
           offsetof(Impl_, status_) -
               offsetof(Impl_, objective_value_) +
               sizeof(Impl_::status_));

  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpSolverResponse)
}
PROTOBUF_NDEBUG_INLINE CpSolverResponse::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        solution_{visibility, arena},
        _solution_cached_byte_size_{0},
        tightened_variables_{visibility, arena},
        sufficient_assumptions_for_infeasibility_{visibility, arena},
        _sufficient_assumptions_for_infeasibility_cached_byte_size_{0},
        additional_solutions_{visibility, arena},
        solution_info_(arena),
        solve_log_(arena) {}

inline void CpSolverResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, integer_objective_),
           0,
           offsetof(Impl_, status_) -
               offsetof(Impl_, integer_objective_) +
               sizeof(Impl_::status_));
}
CpSolverResponse::~CpSolverResponse() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpSolverResponse)
  SharedDtor(*this);
}
inline void CpSolverResponse::SharedDtor(MessageLite& self) {
  CpSolverResponse& this_ = static_cast<CpSolverResponse&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.solution_info_.Destroy();
  this_._impl_.solve_log_.Destroy();
  delete this_._impl_.integer_objective_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CpSolverResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CpSolverResponse(arena);
}
constexpr auto CpSolverResponse::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solution_) +
          decltype(CpSolverResponse::_impl_.solution_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.additional_solutions_) +
          decltype(CpSolverResponse::_impl_.additional_solutions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.tightened_variables_) +
          decltype(CpSolverResponse::_impl_.tightened_variables_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.sufficient_assumptions_for_infeasibility_) +
          decltype(CpSolverResponse::_impl_.sufficient_assumptions_for_infeasibility_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CpSolverResponse), alignof(CpSolverResponse), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CpSolverResponse::PlacementNew_,
                                 sizeof(CpSolverResponse),
                                 alignof(CpSolverResponse));
  }
}
constexpr auto CpSolverResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CpSolverResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CpSolverResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CpSolverResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CpSolverResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CpSolverResponse>(), &CpSolverResponse::ByteSizeLong,
              &CpSolverResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_._cached_size_),
          false,
      },
      &CpSolverResponse::kDescriptorMethods,
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CpSolverResponse_class_data_ =
        CpSolverResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CpSolverResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CpSolverResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CpSolverResponse_class_data_.tc_table);
  return CpSolverResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 24, 3, 95, 2>
CpSolverResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_._has_bits_),
    0, // no _extensions_
    31, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    2147877360,  // skipmap
    offsetof(decltype(_table_), field_entries),
    24,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    CpSolverResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::sat::CpSolverResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .operations_research.sat.CpSolverStatus status = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CpSolverResponse, _impl_.status_), 23>(),
     {8, 23, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.status_)}},
    // repeated int64 solution = 2;
    {::_pbi::TcParser::FastV64P1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solution_)}},
    // double objective_value = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 7, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.objective_value_)}},
    // double best_objective_bound = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 8, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.best_objective_bound_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // int64 num_booleans = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpSolverResponse, _impl_.num_booleans_), 9>(),
     {80, 9, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_booleans_)}},
    // int64 num_conflicts = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpSolverResponse, _impl_.num_conflicts_), 10>(),
     {88, 10, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_conflicts_)}},
    // int64 num_branches = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpSolverResponse, _impl_.num_branches_), 11>(),
     {96, 11, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_branches_)}},
    // int64 num_binary_propagations = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpSolverResponse, _impl_.num_binary_propagations_), 12>(),
     {104, 12, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_binary_propagations_)}},
    // int64 num_integer_propagations = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CpSolverResponse, _impl_.num_integer_propagations_), 13>(),
     {112, 13, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_integer_propagations_)}},
    // double wall_time = 15;
    {::_pbi::TcParser::FastF64S1,
     {121, 14, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.wall_time_)}},
    // double user_time = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 15, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.user_time_)}},
    // double deterministic_time = 17;
    {::_pbi::TcParser::FastF64S2,
     {393, 16, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.deterministic_time_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // string solution_info = 20;
    {::_pbi::TcParser::FastUS2,
     {418, 4, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solution_info_)}},
    // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
    {::_pbi::TcParser::FastMtR2,
     {426, 1, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.tightened_variables_)}},
    // double gap_integral = 22;
    {::_pbi::TcParser::FastF64S2,
     {433, 17, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.gap_integral_)}},
    // repeated int32 sufficient_assumptions_for_infeasibility = 23;
    {::_pbi::TcParser::FastV32P2,
     {442, 2, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.sufficient_assumptions_for_infeasibility_)}},
    // int64 num_restarts = 24;
    {::_pbi::TcParser::FastV64S2,
     {448, 18, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_restarts_)}},
    // int64 num_lp_iterations = 25;
    {::_pbi::TcParser::FastV64S2,
     {456, 19, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_lp_iterations_)}},
    // string solve_log = 26;
    {::_pbi::TcParser::FastUS2,
     {466, 5, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solve_log_)}},
    // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
    {::_pbi::TcParser::FastMtR2,
     {474, 3, 1,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.additional_solutions_)}},
    // .operations_research.sat.CpObjectiveProto integer_objective = 28;
    {::_pbi::TcParser::FastMtS2,
     {482, 6, 2,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.integer_objective_)}},
    // int64 inner_objective_lower_bound = 29;
    {::_pbi::TcParser::FastV64S2,
     {488, 20, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.inner_objective_lower_bound_)}},
    // int64 num_integers = 30;
    {::_pbi::TcParser::FastV64S2,
     {496, 21, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_integers_)}},
    // int64 num_fixed_booleans = 31;
    {::_pbi::TcParser::FastV64S2,
     {504, 22, 0,
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_fixed_booleans_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .operations_research.sat.CpSolverStatus status = 1;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.status_), _Internal::kHasBitsOffset + 23, 0, (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // repeated int64 solution = 2;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solution_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // double objective_value = 3;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.objective_value_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double best_objective_bound = 4;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.best_objective_bound_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // int64 num_booleans = 10;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_booleans_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_conflicts = 11;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_conflicts_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_branches = 12;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_branches_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_binary_propagations = 13;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_binary_propagations_), _Internal::kHasBitsOffset + 12, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_integer_propagations = 14;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_integer_propagations_), _Internal::kHasBitsOffset + 13, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // double wall_time = 15;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.wall_time_), _Internal::kHasBitsOffset + 14, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double user_time = 16;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.user_time_), _Internal::kHasBitsOffset + 15, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double deterministic_time = 17;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.deterministic_time_), _Internal::kHasBitsOffset + 16, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // string solution_info = 20;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solution_info_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.tightened_variables_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // double gap_integral = 22;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.gap_integral_), _Internal::kHasBitsOffset + 17, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // repeated int32 sufficient_assumptions_for_infeasibility = 23;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.sufficient_assumptions_for_infeasibility_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // int64 num_restarts = 24;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_restarts_), _Internal::kHasBitsOffset + 18, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_lp_iterations = 25;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_lp_iterations_), _Internal::kHasBitsOffset + 19, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // string solve_log = 26;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.solve_log_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.additional_solutions_), _Internal::kHasBitsOffset + 3, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .operations_research.sat.CpObjectiveProto integer_objective = 28;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.integer_objective_), _Internal::kHasBitsOffset + 6, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int64 inner_objective_lower_bound = 29;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.inner_objective_lower_bound_), _Internal::kHasBitsOffset + 20, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_integers = 30;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_integers_), _Internal::kHasBitsOffset + 21, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 num_fixed_booleans = 31;
    {PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.num_fixed_booleans_), _Internal::kHasBitsOffset + 22, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::operations_research::sat::IntegerVariableProto>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::CpSolverSolution>()},
      {::_pbi::TcParser::GetTable<::operations_research::sat::CpObjectiveProto>()},
  }},
  {{
    "\50\0\0\0\0\0\0\0\0\0\0\0\0\15\0\0\0\0\0\11\0\0\0\0\0\0\0\0\0\0\0\0"
    "operations_research.sat.CpSolverResponse"
    "solution_info"
    "solve_log"
  }},
};
PROTOBUF_NOINLINE void CpSolverResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpSolverResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.solution_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.tightened_variables_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.sufficient_assumptions_for_infeasibility_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _impl_.additional_solutions_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.solution_info_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.solve_log_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(_impl_.integer_objective_ != nullptr);
      _impl_.integer_objective_->Clear();
    }
  }
  _impl_.objective_value_ = 0;
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    ::memset(&_impl_.best_objective_bound_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.user_time_) -
        reinterpret_cast<char*>(&_impl_.best_objective_bound_)) + sizeof(_impl_.user_time_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    ::memset(&_impl_.deterministic_time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.deterministic_time_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CpSolverResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CpSolverResponse& this_ = static_cast<const CpSolverResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CpSolverResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CpSolverResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpSolverResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // .operations_research.sat.CpSolverStatus status = 1;
  if (CheckHasBit(cached_has_bits, 0x00800000U)) {
    if (this_._internal_status() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_status(), target);
    }
  }

  // repeated int64 solution = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    {
      int byte_size = this_._impl_._solution_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt64Packed(
            2, this_._internal_solution(), byte_size, target);
      }
    }
  }

  // double objective_value = 3;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_objective_value()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          3, this_._internal_objective_value(), target);
    }
  }

  // double best_objective_bound = 4;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_best_objective_bound()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          4, this_._internal_best_objective_bound(), target);
    }
  }

  // int64 num_booleans = 10;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    if (this_._internal_num_booleans() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<10>(
              stream, this_._internal_num_booleans(), target);
    }
  }

  // int64 num_conflicts = 11;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    if (this_._internal_num_conflicts() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<11>(
              stream, this_._internal_num_conflicts(), target);
    }
  }

  // int64 num_branches = 12;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    if (this_._internal_num_branches() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<12>(
              stream, this_._internal_num_branches(), target);
    }
  }

  // int64 num_binary_propagations = 13;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    if (this_._internal_num_binary_propagations() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<13>(
              stream, this_._internal_num_binary_propagations(), target);
    }
  }

  // int64 num_integer_propagations = 14;
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    if (this_._internal_num_integer_propagations() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt64ToArrayWithField<14>(
              stream, this_._internal_num_integer_propagations(), target);
    }
  }

  // double wall_time = 15;
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_wall_time()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          15, this_._internal_wall_time(), target);
    }
  }

  // double user_time = 16;
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_user_time()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          16, this_._internal_user_time(), target);
    }
  }

  // double deterministic_time = 17;
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_deterministic_time()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          17, this_._internal_deterministic_time(), target);
    }
  }

  // string solution_info = 20;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    if (!this_._internal_solution_info().empty()) {
      const ::std::string& _s = this_._internal_solution_info();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "operations_research.sat.CpSolverResponse.solution_info");
      target = stream->WriteStringMaybeAliased(20, _s, target);
    }
  }

  // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_tightened_variables_size());
         i < n; i++) {
      const auto& repfield = this_._internal_tightened_variables().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              21, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // double gap_integral = 22;
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    if (::absl::bit_cast<::uint64_t>(this_._internal_gap_integral()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          22, this_._internal_gap_integral(), target);
    }
  }

  // repeated int32 sufficient_assumptions_for_infeasibility = 23;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    {
      int byte_size = this_._impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_.Get();
      if (byte_size > 0) {
        target = stream->WriteInt32Packed(
            23, this_._internal_sufficient_assumptions_for_infeasibility(), byte_size, target);
      }
    }
  }

  // int64 num_restarts = 24;
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    if (this_._internal_num_restarts() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          24, this_._internal_num_restarts(), target);
    }
  }

  // int64 num_lp_iterations = 25;
  if (CheckHasBit(cached_has_bits, 0x00080000U)) {
    if (this_._internal_num_lp_iterations() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          25, this_._internal_num_lp_iterations(), target);
    }
  }

  // string solve_log = 26;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    if (!this_._internal_solve_log().empty()) {
      const ::std::string& _s = this_._internal_solve_log();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "operations_research.sat.CpSolverResponse.solve_log");
      target = stream->WriteStringMaybeAliased(26, _s, target);
    }
  }

  // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_additional_solutions_size());
         i < n; i++) {
      const auto& repfield = this_._internal_additional_solutions().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              27, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // .operations_research.sat.CpObjectiveProto integer_objective = 28;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        28, *this_._impl_.integer_objective_, this_._impl_.integer_objective_->GetCachedSize(), target,
        stream);
  }

  // int64 inner_objective_lower_bound = 29;
  if (CheckHasBit(cached_has_bits, 0x00100000U)) {
    if (this_._internal_inner_objective_lower_bound() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          29, this_._internal_inner_objective_lower_bound(), target);
    }
  }

  // int64 num_integers = 30;
  if (CheckHasBit(cached_has_bits, 0x00200000U)) {
    if (this_._internal_num_integers() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          30, this_._internal_num_integers(), target);
    }
  }

  // int64 num_fixed_booleans = 31;
  if (CheckHasBit(cached_has_bits, 0x00400000U)) {
    if (this_._internal_num_fixed_booleans() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(
          31, this_._internal_num_fixed_booleans(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpSolverResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CpSolverResponse::ByteSizeLong(const MessageLite& base) {
  const CpSolverResponse& this_ = static_cast<const CpSolverResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CpSolverResponse::ByteSizeLong() const {
  const CpSolverResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpSolverResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated int64 solution = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int64SizeWithPackedTagSize(
              this_._internal_solution(), 1,
              this_._impl_._solution_cached_byte_size_);
    }
    // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 2UL * this_._internal_tightened_variables_size();
      for (const auto& msg : this_._internal_tightened_variables()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated int32 sufficient_assumptions_for_infeasibility = 23;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_sufficient_assumptions_for_infeasibility(), 2,
              this_._impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_);
    }
    // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      total_size += 2UL * this_._internal_additional_solutions_size();
      for (const auto& msg : this_._internal_additional_solutions()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // string solution_info = 20;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!this_._internal_solution_info().empty()) {
        total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_solution_info());
      }
    }
    // string solve_log = 26;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (!this_._internal_solve_log().empty()) {
        total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_solve_log());
      }
    }
    // .operations_research.sat.CpObjectiveProto integer_objective = 28;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.integer_objective_);
    }
    // double objective_value = 3;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_objective_value()) != 0) {
        total_size += 9;
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    // double best_objective_bound = 4;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_best_objective_bound()) != 0) {
        total_size += 9;
      }
    }
    // int64 num_booleans = 10;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      if (this_._internal_num_booleans() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_num_booleans());
      }
    }
    // int64 num_conflicts = 11;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      if (this_._internal_num_conflicts() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_num_conflicts());
      }
    }
    // int64 num_branches = 12;
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      if (this_._internal_num_branches() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_num_branches());
      }
    }
    // int64 num_binary_propagations = 13;
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      if (this_._internal_num_binary_propagations() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_num_binary_propagations());
      }
    }
    // int64 num_integer_propagations = 14;
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      if (this_._internal_num_integer_propagations() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
            this_._internal_num_integer_propagations());
      }
    }
    // double wall_time = 15;
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_wall_time()) != 0) {
        total_size += 9;
      }
    }
    // double user_time = 16;
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_user_time()) != 0) {
        total_size += 10;
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    // double deterministic_time = 17;
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_deterministic_time()) != 0) {
        total_size += 10;
      }
    }
    // double gap_integral = 22;
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      if (::absl::bit_cast<::uint64_t>(this_._internal_gap_integral()) != 0) {
        total_size += 10;
      }
    }
    // int64 num_restarts = 24;
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      if (this_._internal_num_restarts() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                        this_._internal_num_restarts());
      }
    }
    // int64 num_lp_iterations = 25;
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      if (this_._internal_num_lp_iterations() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                        this_._internal_num_lp_iterations());
      }
    }
    // int64 inner_objective_lower_bound = 29;
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      if (this_._internal_inner_objective_lower_bound() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                        this_._internal_inner_objective_lower_bound());
      }
    }
    // int64 num_integers = 30;
    if (CheckHasBit(cached_has_bits, 0x00200000U)) {
      if (this_._internal_num_integers() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                        this_._internal_num_integers());
      }
    }
    // int64 num_fixed_booleans = 31;
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      if (this_._internal_num_fixed_booleans() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                        this_._internal_num_fixed_booleans());
      }
    }
    // .operations_research.sat.CpSolverStatus status = 1;
    if (CheckHasBit(cached_has_bits, 0x00800000U)) {
      if (this_._internal_status() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_status());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CpSolverResponse::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CpSolverResponse*>(&to_msg);
  auto& from = static_cast<const CpSolverResponse&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpSolverResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_solution()->MergeFrom(from._internal_solution());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_tightened_variables()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_tightened_variables());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_sufficient_assumptions_for_infeasibility()->MergeFrom(from._internal_sufficient_assumptions_for_infeasibility());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000008U)) {
      _this->_internal_mutable_additional_solutions()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_additional_solutions());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      if (!from._internal_solution_info().empty()) {
        _this->_internal_set_solution_info(from._internal_solution_info());
      } else {
        if (_this->_impl_.solution_info_.IsDefault()) {
          _this->_internal_set_solution_info("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      if (!from._internal_solve_log().empty()) {
        _this->_internal_set_solve_log(from._internal_solve_log());
      } else {
        if (_this->_impl_.solve_log_.IsDefault()) {
          _this->_internal_set_solve_log("");
        }
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      ABSL_DCHECK(from._impl_.integer_objective_ != nullptr);
      if (_this->_impl_.integer_objective_ == nullptr) {
        _this->_impl_.integer_objective_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.integer_objective_);
      } else {
        _this->_impl_.integer_objective_->MergeFrom(*from._impl_.integer_objective_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_objective_value()) != 0) {
        _this->_impl_.objective_value_ = from._impl_.objective_value_;
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_best_objective_bound()) != 0) {
        _this->_impl_.best_objective_bound_ = from._impl_.best_objective_bound_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      if (from._internal_num_booleans() != 0) {
        _this->_impl_.num_booleans_ = from._impl_.num_booleans_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      if (from._internal_num_conflicts() != 0) {
        _this->_impl_.num_conflicts_ = from._impl_.num_conflicts_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      if (from._internal_num_branches() != 0) {
        _this->_impl_.num_branches_ = from._impl_.num_branches_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      if (from._internal_num_binary_propagations() != 0) {
        _this->_impl_.num_binary_propagations_ = from._impl_.num_binary_propagations_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      if (from._internal_num_integer_propagations() != 0) {
        _this->_impl_.num_integer_propagations_ = from._impl_.num_integer_propagations_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_wall_time()) != 0) {
        _this->_impl_.wall_time_ = from._impl_.wall_time_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_user_time()) != 0) {
        _this->_impl_.user_time_ = from._impl_.user_time_;
      }
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_deterministic_time()) != 0) {
        _this->_impl_.deterministic_time_ = from._impl_.deterministic_time_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      if (::absl::bit_cast<::uint64_t>(from._internal_gap_integral()) != 0) {
        _this->_impl_.gap_integral_ = from._impl_.gap_integral_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      if (from._internal_num_restarts() != 0) {
        _this->_impl_.num_restarts_ = from._impl_.num_restarts_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      if (from._internal_num_lp_iterations() != 0) {
        _this->_impl_.num_lp_iterations_ = from._impl_.num_lp_iterations_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      if (from._internal_inner_objective_lower_bound() != 0) {
        _this->_impl_.inner_objective_lower_bound_ = from._impl_.inner_objective_lower_bound_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00200000U)) {
      if (from._internal_num_integers() != 0) {
        _this->_impl_.num_integers_ = from._impl_.num_integers_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      if (from._internal_num_fixed_booleans() != 0) {
        _this->_impl_.num_fixed_booleans_ = from._impl_.num_fixed_booleans_;
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00800000U)) {
      if (from._internal_status() != 0) {
        _this->_impl_.status_ = from._impl_.status_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CpSolverResponse::CopyFrom(const CpSolverResponse& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpSolverResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CpSolverResponse::InternalSwap(CpSolverResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.solution_.InternalSwap(&other->_impl_.solution_);
  _impl_.tightened_variables_.InternalSwap(&other->_impl_.tightened_variables_);
  _impl_.sufficient_assumptions_for_infeasibility_.InternalSwap(&other->_impl_.sufficient_assumptions_for_infeasibility_);
  _impl_.additional_solutions_.InternalSwap(&other->_impl_.additional_solutions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.solution_info_, &other->_impl_.solution_info_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.solve_log_, &other->_impl_.solve_log_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.status_)
      + sizeof(CpSolverResponse::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.integer_objective_)>(
          reinterpret_cast<char*>(&_impl_.integer_objective_),
          reinterpret_cast<char*>(&other->_impl_.integer_objective_));
}

::google::protobuf::Metadata CpSolverResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace sat
}  // namespace operations_research
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
