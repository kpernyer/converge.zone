// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ortools/glop/parameters.proto
// Protobuf C++ Version: 6.33.1

#include "ortools/glop/parameters.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace operations_research {
namespace glop {

inline constexpr GlopParameters::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        use_dual_simplex_{false},
        feasibility_rule_{static_cast< ::operations_research::glop::GlopParameters_PricingRule >(1)},
        optimization_rule_{static_cast< ::operations_research::glop::GlopParameters_PricingRule >(1)},
        refactorization_threshold_{1e-09},
        recompute_reduced_costs_threshold_{1e-08},
        recompute_edges_norm_threshold_{100},
        primal_feasibility_tolerance_{1e-08},
        dual_feasibility_tolerance_{1e-08},
        ratio_test_zero_threshold_{1e-09},
        harris_tolerance_ratio_{0.5},
        small_pivot_threshold_{1e-06},
        minimum_acceptable_pivot_{1e-06},
        initial_basis_{static_cast< ::operations_research::glop::GlopParameters_InitialBasisHeuristic >(2)},
        basis_refactorization_period_{64},
        use_scaling_{true},
        use_transposed_matrix_{true},
        provide_strong_optimal_guarantee_{true},
        solve_dual_problem_{static_cast< ::operations_research::glop::GlopParameters_SolverBehavior >(2)},
        dualizer_threshold_{1.5},
        solution_feasibility_tolerance_{1e-06},
        lu_factorization_pivot_threshold_{0.01},
        max_time_in_seconds_{std::numeric_limits<double>::infinity()},
        max_number_of_iterations_{::int64_t{-1}},
        markowitz_singularity_threshold_{1e-15},
        markowitz_zlatev_parameter_{3},
        num_omp_threads_{1},
        preprocessor_zero_tolerance_{1e-09},
        allow_simplex_algorithm_change_{false},
        perturb_costs_in_dual_simplex_{false},
        log_search_progress_{false},
        dual_price_prioritize_norm_{false},
        use_absl_random_{false},
        devex_weights_reset_period_{150},
        use_preprocessing_{true},
        use_middle_product_form_update_{true},
        initialize_devex_with_column_norms_{true},
        exploit_singleton_column_in_initial_basis_{true},
        dual_small_pivot_threshold_{0.0001},
        objective_lower_limit_{-std::numeric_limits<double>::infinity()},
        objective_upper_limit_{std::numeric_limits<double>::infinity()},
        degenerate_ministep_factor_{0.01},
        max_deterministic_time_{std::numeric_limits<double>::infinity()},
        random_seed_{1},
        scaling_method_{static_cast< ::operations_research::glop::GlopParameters_ScalingAlgorithm >(1)},
        drop_tolerance_{1e-14},
        relative_cost_perturbation_{1e-05},
        relative_max_cost_perturbation_{1e-07},
        max_number_of_reoptimizations_{40},
        initial_condition_number_threshold_{1e+50},
        cost_scaling_{static_cast< ::operations_research::glop::GlopParameters_CostScalingAlgorithm >(1)},
        change_status_to_imprecise_{true},
        use_dedicated_dual_feasibility_algorithm_{true},
        dynamically_adjust_refactorization_period_{true},
        push_to_vertex_{true},
        crossover_bound_snapping_distance_{std::numeric_limits<double>::infinity()},
        max_valid_magnitude_{1e+30},
        drop_magnitude_{1e-30},
        log_to_stdout_{true},
        use_implied_free_preprocessor_{true} {}

template <typename>
PROTOBUF_CONSTEXPR GlopParameters::GlopParameters(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(GlopParameters_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct GlopParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlopParametersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlopParametersDefaultTypeInternal() {}
  union {
    GlopParameters _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OR_PROTO_DLL
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlopParametersDefaultTypeInternal _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor* PROTOBUF_NONNULL* PROTOBUF_NULLABLE
    file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto = nullptr;
const ::uint32_t
    TableStruct_ortools_2fglop_2fparameters_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_._has_bits_),
        62, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.scaling_method_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.feasibility_rule_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.optimization_rule_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.refactorization_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.recompute_reduced_costs_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.recompute_edges_norm_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.primal_feasibility_tolerance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_feasibility_tolerance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.ratio_test_zero_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.harris_tolerance_ratio_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.small_pivot_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.minimum_acceptable_pivot_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.drop_tolerance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_scaling_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.cost_scaling_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initial_basis_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_transposed_matrix_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.basis_refactorization_period_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dynamically_adjust_refactorization_period_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.solve_dual_problem_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dualizer_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.solution_feasibility_tolerance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.provide_strong_optimal_guarantee_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.change_status_to_imprecise_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_number_of_reoptimizations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.lu_factorization_pivot_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_time_in_seconds_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_deterministic_time_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_number_of_iterations_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.markowitz_zlatev_parameter_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.markowitz_singularity_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_dual_simplex_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.allow_simplex_algorithm_change_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.devex_weights_reset_period_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_preprocessing_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_middle_product_form_update_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initialize_devex_with_column_norms_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.exploit_singleton_column_in_initial_basis_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_small_pivot_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.preprocessor_zero_tolerance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.objective_lower_limit_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.objective_upper_limit_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.degenerate_ministep_factor_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.random_seed_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_absl_random_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.num_omp_threads_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.perturb_costs_in_dual_simplex_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_dedicated_dual_feasibility_algorithm_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.relative_cost_perturbation_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.relative_max_cost_perturbation_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initial_condition_number_threshold_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.log_search_progress_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.log_to_stdout_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.crossover_bound_snapping_distance_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.push_to_vertex_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_implied_free_preprocessor_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_valid_magnitude_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.drop_magnitude_),
        PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_price_prioritize_norm_),
        43,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        44,
        14,
        49,
        12,
        15,
        13,
        52,
        17,
        18,
        19,
        16,
        50,
        47,
        20,
        21,
        41,
        22,
        24,
        23,
        0,
        27,
        32,
        33,
        34,
        35,
        36,
        37,
        26,
        38,
        39,
        40,
        42,
        31,
        25,
        28,
        51,
        45,
        46,
        48,
        29,
        57,
        54,
        53,
        58,
        55,
        56,
        30,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::operations_research::glop::GlopParameters)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::operations_research::glop::_GlopParameters_default_instance_._instance,
};
const char descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\035ortools/glop/parameters.proto\022\030operati"
    "ons_research.glop\"\360\030\n\016GlopParameters\022`\n\016"
    "scaling_method\0309 \001(\01629.operations_resear"
    "ch.glop.GlopParameters.ScalingAlgorithm:"
    "\rEQUILIBRATION\022]\n\020feasibility_rule\030\001 \001(\016"
    "24.operations_research.glop.GlopParamete"
    "rs.PricingRule:\rSTEEPEST_EDGE\022^\n\021optimiz"
    "ation_rule\030\002 \001(\01624.operations_research.g"
    "lop.GlopParameters.PricingRule:\rSTEEPEST"
    "_EDGE\022(\n\031refactorization_threshold\030\006 \001(\001"
    ":\0051e-09\0220\n!recompute_reduced_costs_thres"
    "hold\030\010 \001(\001:\0051e-08\022+\n\036recompute_edges_nor"
    "m_threshold\030\t \001(\001:\003100\022+\n\034primal_feasibi"
    "lity_tolerance\030\n \001(\001:\0051e-08\022)\n\032dual_feas"
    "ibility_tolerance\030\013 \001(\001:\0051e-08\022(\n\031ratio_"
    "test_zero_threshold\030\014 \001(\001:\0051e-09\022#\n\026harr"
    "is_tolerance_ratio\030\r \001(\001:\0030.5\022$\n\025small_p"
    "ivot_threshold\030\016 \001(\001:\0051e-06\022\'\n\030minimum_a"
    "cceptable_pivot\030\017 \001(\001:\0051e-06\022\035\n\016drop_tol"
    "erance\0304 \001(\001:\0051e-14\022\031\n\013use_scaling\030\020 \001(\010"
    ":\004true\022m\n\014cost_scaling\030< \001(\0162=.operation"
    "s_research.glop.GlopParameters.CostScali"
    "ngAlgorithm:\030CONTAIN_ONE_COST_SCALING\022a\n"
    "\rinitial_basis\030\021 \001(\0162>.operations_resear"
    "ch.glop.GlopParameters.InitialBasisHeuri"
    "stic:\nTRIANGULAR\022#\n\025use_transposed_matri"
    "x\030\022 \001(\010:\004true\022(\n\034basis_refactorization_p"
    "eriod\030\023 \001(\005:\00264\0227\n)dynamically_adjust_re"
    "factorization_period\030\? \001(\010:\004true\022f\n\022solv"
    "e_dual_problem\030\024 \001(\01627.operations_resear"
    "ch.glop.GlopParameters.SolverBehavior:\021L"
    "ET_SOLVER_DECIDE\022\037\n\022dualizer_threshold\030\025"
    " \001(\001:\0031.5\022-\n\036solution_feasibility_tolera"
    "nce\030\026 \001(\001:\0051e-06\022.\n provide_strong_optim"
    "al_guarantee\030\030 \001(\010:\004true\022(\n\032change_statu"
    "s_to_imprecise\030: \001(\010:\004true\022)\n\035max_number"
    "_of_reoptimizations\0308 \001(\001:\00240\022.\n lu_fact"
    "orization_pivot_threshold\030\031 \001(\001:\0040.01\022 \n"
    "\023max_time_in_seconds\030\032 \001(\001:\003inf\022#\n\026max_d"
    "eterministic_time\030- \001(\001:\003inf\022$\n\030max_numb"
    "er_of_iterations\030\033 \001(\003:\002-1\022%\n\032markowitz_"
    "zlatev_parameter\030\035 \001(\005:\0013\022.\n\037markowitz_s"
    "ingularity_threshold\030\036 \001(\001:\0051e-15\022\037\n\020use"
    "_dual_simplex\030\037 \001(\010:\005false\022-\n\036allow_simp"
    "lex_algorithm_change\030  \001(\010:\005false\022\'\n\032dev"
    "ex_weights_reset_period\030! \001(\005:\003150\022\037\n\021us"
    "e_preprocessing\030\" \001(\010:\004true\022,\n\036use_middl"
    "e_product_form_update\030# \001(\010:\004true\0220\n\"ini"
    "tialize_devex_with_column_norms\030$ \001(\010:\004t"
    "rue\0227\n)exploit_singleton_column_in_initi"
    "al_basis\030% \001(\010:\004true\022*\n\032dual_small_pivot"
    "_threshold\030& \001(\001:\0060.0001\022*\n\033preprocessor"
    "_zero_tolerance\030\' \001(\001:\0051e-09\022#\n\025objectiv"
    "e_lower_limit\030( \001(\001:\004-inf\022\"\n\025objective_u"
    "pper_limit\030) \001(\001:\003inf\022(\n\032degenerate_mini"
    "step_factor\030* \001(\001:\0040.01\022\026\n\013random_seed\030+"
    " \001(\005:\0011\022\036\n\017use_absl_random\030H \001(\010:\005false\022"
    "\032\n\017num_omp_threads\030, \001(\005:\0011\022,\n\035perturb_c"
    "osts_in_dual_simplex\0305 \001(\010:\005false\0226\n(use"
    "_dedicated_dual_feasibility_algorithm\030> "
    "\001(\010:\004true\022)\n\032relative_cost_perturbation\030"
    "6 \001(\001:\0051e-05\022-\n\036relative_max_cost_pertur"
    "bation\0307 \001(\001:\0051e-07\0221\n\"initial_condition"
    "_number_threshold\030; \001(\001:\0051e+50\022\"\n\023log_se"
    "arch_progress\030= \001(\010:\005false\022\033\n\rlog_to_std"
    "out\030B \001(\010:\004true\022.\n!crossover_bound_snapp"
    "ing_distance\030@ \001(\001:\003inf\022\034\n\016push_to_verte"
    "x\030A \001(\010:\004true\022+\n\035use_implied_free_prepro"
    "cessor\030C \001(\010:\004true\022\"\n\023max_valid_magnitud"
    "e\030F \001(\001:\0051e+30\022\035\n\016drop_magnitude\030G \001(\001:\005"
    "1e-30\022)\n\032dual_price_prioritize_norm\030E \001("
    "\010:\005false\"F\n\020ScalingAlgorithm\022\013\n\007DEFAULT\020"
    "\000\022\021\n\rEQUILIBRATION\020\001\022\022\n\016LINEAR_PROGRAM\020\002"
    "\"D\n\016SolverBehavior\022\r\n\tALWAYS_DO\020\000\022\014\n\010NEV"
    "ER_DO\020\001\022\025\n\021LET_SOLVER_DECIDE\020\002\"8\n\013Pricin"
    "gRule\022\013\n\007DANTZIG\020\000\022\021\n\rSTEEPEST_EDGE\020\001\022\t\n"
    "\005DEVEX\020\002\"G\n\025InitialBasisHeuristic\022\010\n\004NON"
    "E\020\000\022\t\n\005BIXBY\020\001\022\016\n\nTRIANGULAR\020\002\022\t\n\005MAROS\020"
    "\003\"y\n\024CostScalingAlgorithm\022\023\n\017NO_COST_SCA"
    "LING\020\000\022\034\n\030CONTAIN_ONE_COST_SCALING\020\001\022\025\n\021"
    "MEAN_COST_SCALING\020\002\022\027\n\023MEDIAN_COST_SCALI"
    "NG\020\003B1\n\027com.google.ortools.glopP\001\252\002\023Goog"
    "le.OrTools.Glop"
};
static ::absl::once_flag descriptor_table_ortools_2fglop_2fparameters_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_ortools_2fglop_2fparameters_2eproto = {
    false,
    false,
    3295,
    descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto,
    "ortools/glop/parameters.proto",
    &descriptor_table_ortools_2fglop_2fparameters_2eproto_once,
    nullptr,
    0,
    1,
    schemas,
    file_default_instances,
    TableStruct_ortools_2fglop_2fparameters_2eproto::offsets,
    file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto,
    file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto,
};
namespace operations_research {
namespace glop {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlopParameters_ScalingAlgorithm_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t GlopParameters_ScalingAlgorithm_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlopParameters_SolverBehavior_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t GlopParameters_SolverBehavior_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlopParameters_PricingRule_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t GlopParameters_PricingRule_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlopParameters_InitialBasisHeuristic_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t GlopParameters_InitialBasisHeuristic_internal_data_[] = {
    262144u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GlopParameters_CostScalingAlgorithm_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t GlopParameters_CostScalingAlgorithm_internal_data_[] = {
    262144u, 0u, };
// ===================================================================

class GlopParameters::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<GlopParameters>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_._has_bits_);
};

GlopParameters::GlopParameters(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GlopParameters_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:operations_research.glop.GlopParameters)
}
GlopParameters::GlopParameters(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GlopParameters& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, GlopParameters_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE GlopParameters::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        feasibility_rule_{static_cast< ::operations_research::glop::GlopParameters_PricingRule >(1)},
        optimization_rule_{static_cast< ::operations_research::glop::GlopParameters_PricingRule >(1)},
        refactorization_threshold_{1e-09},
        recompute_reduced_costs_threshold_{1e-08},
        recompute_edges_norm_threshold_{100},
        primal_feasibility_tolerance_{1e-08},
        dual_feasibility_tolerance_{1e-08},
        ratio_test_zero_threshold_{1e-09},
        harris_tolerance_ratio_{0.5},
        small_pivot_threshold_{1e-06},
        minimum_acceptable_pivot_{1e-06},
        initial_basis_{static_cast< ::operations_research::glop::GlopParameters_InitialBasisHeuristic >(2)},
        basis_refactorization_period_{64},
        use_scaling_{true},
        use_transposed_matrix_{true},
        provide_strong_optimal_guarantee_{true},
        solve_dual_problem_{static_cast< ::operations_research::glop::GlopParameters_SolverBehavior >(2)},
        dualizer_threshold_{1.5},
        solution_feasibility_tolerance_{1e-06},
        lu_factorization_pivot_threshold_{0.01},
        max_time_in_seconds_{std::numeric_limits<double>::infinity()},
        max_number_of_iterations_{::int64_t{-1}},
        markowitz_singularity_threshold_{1e-15},
        markowitz_zlatev_parameter_{3},
        num_omp_threads_{1},
        preprocessor_zero_tolerance_{1e-09},
        devex_weights_reset_period_{150},
        use_preprocessing_{true},
        use_middle_product_form_update_{true},
        initialize_devex_with_column_norms_{true},
        exploit_singleton_column_in_initial_basis_{true},
        dual_small_pivot_threshold_{0.0001},
        objective_lower_limit_{-std::numeric_limits<double>::infinity()},
        objective_upper_limit_{std::numeric_limits<double>::infinity()},
        degenerate_ministep_factor_{0.01},
        max_deterministic_time_{std::numeric_limits<double>::infinity()},
        random_seed_{1},
        scaling_method_{static_cast< ::operations_research::glop::GlopParameters_ScalingAlgorithm >(1)},
        drop_tolerance_{1e-14},
        relative_cost_perturbation_{1e-05},
        relative_max_cost_perturbation_{1e-07},
        max_number_of_reoptimizations_{40},
        initial_condition_number_threshold_{1e+50},
        cost_scaling_{static_cast< ::operations_research::glop::GlopParameters_CostScalingAlgorithm >(1)},
        change_status_to_imprecise_{true},
        use_dedicated_dual_feasibility_algorithm_{true},
        dynamically_adjust_refactorization_period_{true},
        push_to_vertex_{true},
        crossover_bound_snapping_distance_{std::numeric_limits<double>::infinity()},
        max_valid_magnitude_{1e+30},
        drop_magnitude_{1e-30},
        log_to_stdout_{true},
        use_implied_free_preprocessor_{true} {}

inline void GlopParameters::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.use_dual_simplex_ = {};
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, allow_simplex_algorithm_change_),
           0,
           offsetof(Impl_, use_absl_random_) -
               offsetof(Impl_, allow_simplex_algorithm_change_) +
               sizeof(Impl_::use_absl_random_));
}
GlopParameters::~GlopParameters() {
  // @@protoc_insertion_point(destructor:operations_research.glop.GlopParameters)
  SharedDtor(*this);
}
inline void GlopParameters::SharedDtor(MessageLite& self) {
  GlopParameters& this_ = static_cast<GlopParameters&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL GlopParameters::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) GlopParameters(arena);
}
constexpr auto GlopParameters::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(GlopParameters),
                                            alignof(GlopParameters));
}
constexpr auto GlopParameters::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_GlopParameters_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &GlopParameters::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<GlopParameters>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &GlopParameters::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<GlopParameters>(), &GlopParameters::ByteSizeLong,
              &GlopParameters::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_._cached_size_),
          false,
      },
      &GlopParameters::kDescriptorMethods,
      &descriptor_table_ortools_2fglop_2fparameters_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull GlopParameters_class_data_ =
        GlopParameters::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
GlopParameters::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&GlopParameters_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(GlopParameters_class_data_.tc_table);
  return GlopParameters_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 59, 6, 0, 11>
GlopParameters::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_._has_bits_),
    0, // no _extensions_
    72, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    138412124,  // skipmap
    offsetof(decltype(_table_), field_entries),
    59,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    GlopParameters_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::operations_research::glop::GlopParameters>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 2,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.feasibility_rule_)}},
    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    {::_pbi::TcParser::FastEr0S1,
     {16, 2, 2,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.optimization_rule_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional double refactorization_threshold = 6 [default = 1e-09];
    {::_pbi::TcParser::FastF64S1,
     {49, 3, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.refactorization_threshold_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
    {::_pbi::TcParser::FastF64S1,
     {65, 4, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.recompute_reduced_costs_threshold_)}},
    // optional double recompute_edges_norm_threshold = 9 [default = 100];
    {::_pbi::TcParser::FastF64S1,
     {73, 5, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.recompute_edges_norm_threshold_)}},
    // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
    {::_pbi::TcParser::FastF64S1,
     {81, 6, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.primal_feasibility_tolerance_)}},
    // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
    {::_pbi::TcParser::FastF64S1,
     {89, 7, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dual_feasibility_tolerance_)}},
    // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
    {::_pbi::TcParser::FastF64S1,
     {97, 8, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.ratio_test_zero_threshold_)}},
    // optional double harris_tolerance_ratio = 13 [default = 0.5];
    {::_pbi::TcParser::FastF64S1,
     {105, 9, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.harris_tolerance_ratio_)}},
    // optional double small_pivot_threshold = 14 [default = 1e-06];
    {::_pbi::TcParser::FastF64S1,
     {113, 10, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.small_pivot_threshold_)}},
    // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
    {::_pbi::TcParser::FastF64S1,
     {121, 11, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.minimum_acceptable_pivot_)}},
    // optional bool use_scaling = 16 [default = true];
    {::_pbi::TcParser::FastV8S2,
     {384, 14, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_scaling_)}},
    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    {::_pbi::TcParser::FastEr0S2,
     {392, 12, 3,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.initial_basis_)}},
    // optional bool use_transposed_matrix = 18 [default = true];
    {::_pbi::TcParser::FastV8S2,
     {400, 15, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_transposed_matrix_)}},
    // optional int32 basis_refactorization_period = 19 [default = 64];
    {::_pbi::TcParser::FastV32S2,
     {408, 13, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.basis_refactorization_period_)}},
    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    {::_pbi::TcParser::FastEr0S2,
     {416, 17, 2,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.solve_dual_problem_)}},
    // optional double dualizer_threshold = 21 [default = 1.5];
    {::_pbi::TcParser::FastF64S2,
     {425, 18, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dualizer_threshold_)}},
    // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
    {::_pbi::TcParser::FastF64S2,
     {433, 19, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.solution_feasibility_tolerance_)}},
    // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
    {::_pbi::TcParser::FastF64S2,
     {697, 26, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.preprocessor_zero_tolerance_)}},
    // optional bool provide_strong_optimal_guarantee = 24 [default = true];
    {::_pbi::TcParser::FastV8S2,
     {448, 16, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.provide_strong_optimal_guarantee_)}},
    // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
    {::_pbi::TcParser::FastF64S2,
     {457, 20, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.lu_factorization_pivot_threshold_)}},
    // optional double max_time_in_seconds = 26 [default = inf];
    {::_pbi::TcParser::FastF64S2,
     {465, 21, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_time_in_seconds_)}},
    // optional int64 max_number_of_iterations = 27 [default = -1];
    {::_pbi::TcParser::FastV64S2,
     {472, 22, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_number_of_iterations_)}},
    // optional int32 num_omp_threads = 44 [default = 1];
    {::_pbi::TcParser::FastV32S2,
     {736, 25, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.num_omp_threads_)}},
    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    {::_pbi::TcParser::FastV32S2,
     {488, 24, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.markowitz_zlatev_parameter_)}},
    // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
    {::_pbi::TcParser::FastF64S2,
     {497, 23, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.markowitz_singularity_threshold_)}},
    // optional bool use_dual_simplex = 31 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {504, 0, 0,
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_dual_simplex_)}},
  }}, {{
    33, 0, 3,
    57344, 26,
    7, 39,
    65288, 52,
    65535, 65535
  }}, {{
    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.feasibility_rule_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.optimization_rule_), _Internal::kHasBitsOffset + 2, 1, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double refactorization_threshold = 6 [default = 1e-09];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.refactorization_threshold_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.recompute_reduced_costs_threshold_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double recompute_edges_norm_threshold = 9 [default = 100];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.recompute_edges_norm_threshold_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.primal_feasibility_tolerance_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dual_feasibility_tolerance_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.ratio_test_zero_threshold_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double harris_tolerance_ratio = 13 [default = 0.5];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.harris_tolerance_ratio_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double small_pivot_threshold = 14 [default = 1e-06];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.small_pivot_threshold_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.minimum_acceptable_pivot_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool use_scaling = 16 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_scaling_), _Internal::kHasBitsOffset + 14, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.initial_basis_), _Internal::kHasBitsOffset + 12, 2, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool use_transposed_matrix = 18 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_transposed_matrix_), _Internal::kHasBitsOffset + 15, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 basis_refactorization_period = 19 [default = 64];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.basis_refactorization_period_), _Internal::kHasBitsOffset + 13, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.solve_dual_problem_), _Internal::kHasBitsOffset + 17, 3, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional double dualizer_threshold = 21 [default = 1.5];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dualizer_threshold_), _Internal::kHasBitsOffset + 18, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.solution_feasibility_tolerance_), _Internal::kHasBitsOffset + 19, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool provide_strong_optimal_guarantee = 24 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.provide_strong_optimal_guarantee_), _Internal::kHasBitsOffset + 16, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.lu_factorization_pivot_threshold_), _Internal::kHasBitsOffset + 20, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double max_time_in_seconds = 26 [default = inf];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_time_in_seconds_), _Internal::kHasBitsOffset + 21, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional int64 max_number_of_iterations = 27 [default = -1];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_number_of_iterations_), _Internal::kHasBitsOffset + 22, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.markowitz_zlatev_parameter_), _Internal::kHasBitsOffset + 24, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.markowitz_singularity_threshold_), _Internal::kHasBitsOffset + 23, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool use_dual_simplex = 31 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_dual_simplex_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool allow_simplex_algorithm_change = 32 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.allow_simplex_algorithm_change_), _Internal::kHasBitsOffset + 27, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 devex_weights_reset_period = 33 [default = 150];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.devex_weights_reset_period_), _Internal::kHasBitsOffset + 32, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool use_preprocessing = 34 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_preprocessing_), _Internal::kHasBitsOffset + 33, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool use_middle_product_form_update = 35 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_middle_product_form_update_), _Internal::kHasBitsOffset + 34, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool initialize_devex_with_column_norms = 36 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.initialize_devex_with_column_norms_), _Internal::kHasBitsOffset + 35, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.exploit_singleton_column_in_initial_basis_), _Internal::kHasBitsOffset + 36, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dual_small_pivot_threshold_), _Internal::kHasBitsOffset + 37, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.preprocessor_zero_tolerance_), _Internal::kHasBitsOffset + 26, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double objective_lower_limit = 40 [default = -inf];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.objective_lower_limit_), _Internal::kHasBitsOffset + 38, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double objective_upper_limit = 41 [default = inf];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.objective_upper_limit_), _Internal::kHasBitsOffset + 39, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double degenerate_ministep_factor = 42 [default = 0.01];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.degenerate_ministep_factor_), _Internal::kHasBitsOffset + 40, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional int32 random_seed = 43 [default = 1];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.random_seed_), _Internal::kHasBitsOffset + 42, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 num_omp_threads = 44 [default = 1];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.num_omp_threads_), _Internal::kHasBitsOffset + 25, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional double max_deterministic_time = 45 [default = inf];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_deterministic_time_), _Internal::kHasBitsOffset + 41, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double drop_tolerance = 52 [default = 1e-14];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.drop_tolerance_), _Internal::kHasBitsOffset + 44, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.perturb_costs_in_dual_simplex_), _Internal::kHasBitsOffset + 28, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double relative_cost_perturbation = 54 [default = 1e-05];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.relative_cost_perturbation_), _Internal::kHasBitsOffset + 45, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.relative_max_cost_perturbation_), _Internal::kHasBitsOffset + 46, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double max_number_of_reoptimizations = 56 [default = 40];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_number_of_reoptimizations_), _Internal::kHasBitsOffset + 47, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.scaling_method_), _Internal::kHasBitsOffset + 43, 4, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool change_status_to_imprecise = 58 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.change_status_to_imprecise_), _Internal::kHasBitsOffset + 50, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double initial_condition_number_threshold = 59 [default = 1e+50];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.initial_condition_number_threshold_), _Internal::kHasBitsOffset + 48, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.cost_scaling_), _Internal::kHasBitsOffset + 49, 5, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool log_search_progress = 61 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.log_search_progress_), _Internal::kHasBitsOffset + 29, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_dedicated_dual_feasibility_algorithm_), _Internal::kHasBitsOffset + 51, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dynamically_adjust_refactorization_period_), _Internal::kHasBitsOffset + 52, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double crossover_bound_snapping_distance = 64 [default = inf];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.crossover_bound_snapping_distance_), _Internal::kHasBitsOffset + 54, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool push_to_vertex = 65 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.push_to_vertex_), _Internal::kHasBitsOffset + 53, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool log_to_stdout = 66 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.log_to_stdout_), _Internal::kHasBitsOffset + 57, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool use_implied_free_preprocessor = 67 [default = true];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_implied_free_preprocessor_), _Internal::kHasBitsOffset + 58, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool dual_price_prioritize_norm = 69 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dual_price_prioritize_norm_), _Internal::kHasBitsOffset + 30, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional double max_valid_magnitude = 70 [default = 1e+30];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.max_valid_magnitude_), _Internal::kHasBitsOffset + 55, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double drop_magnitude = 71 [default = 1e-30];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.drop_magnitude_), _Internal::kHasBitsOffset + 56, 0, (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional bool use_absl_random = 72 [default = false];
    {PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_absl_random_), _Internal::kHasBitsOffset + 31, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {0, 2},
      {0, 2},
      {0, 3},
      {0, 2},
      {0, 2},
      {0, 3},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void GlopParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.glop.GlopParameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    _impl_.use_dual_simplex_ = false;
    _impl_.feasibility_rule_ = 1;
    _impl_.optimization_rule_ = 1;
    _impl_.refactorization_threshold_ = 1e-09;
    _impl_.recompute_reduced_costs_threshold_ = 1e-08;
    _impl_.recompute_edges_norm_threshold_ = 100;
    _impl_.primal_feasibility_tolerance_ = 1e-08;
    _impl_.dual_feasibility_tolerance_ = 1e-08;
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    _impl_.ratio_test_zero_threshold_ = 1e-09;
    _impl_.harris_tolerance_ratio_ = 0.5;
    _impl_.small_pivot_threshold_ = 1e-06;
    _impl_.minimum_acceptable_pivot_ = 1e-06;
    _impl_.initial_basis_ = 2;
    _impl_.basis_refactorization_period_ = 64;
    _impl_.use_scaling_ = true;
    _impl_.use_transposed_matrix_ = true;
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    _impl_.provide_strong_optimal_guarantee_ = true;
    _impl_.solve_dual_problem_ = 2;
    _impl_.dualizer_threshold_ = 1.5;
    _impl_.solution_feasibility_tolerance_ = 1e-06;
    _impl_.lu_factorization_pivot_threshold_ = 0.01;
    _impl_.max_time_in_seconds_ = std::numeric_limits<double>::infinity();
    _impl_.max_number_of_iterations_ = ::int64_t{-1};
    _impl_.markowitz_singularity_threshold_ = 1e-15;
  }
  if (BatchCheckHasBit(cached_has_bits, 0x07000000U)) {
    _impl_.markowitz_zlatev_parameter_ = 3;
    _impl_.num_omp_threads_ = 1;
    _impl_.preprocessor_zero_tolerance_ = 1e-09;
  }
  if (BatchCheckHasBit(cached_has_bits, 0xf8000000U)) {
    ::memset(&_impl_.allow_simplex_algorithm_change_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.use_absl_random_) -
        reinterpret_cast<char*>(&_impl_.allow_simplex_algorithm_change_)) + sizeof(_impl_.use_absl_random_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    _impl_.devex_weights_reset_period_ = 150;
    _impl_.use_preprocessing_ = true;
    _impl_.use_middle_product_form_update_ = true;
    _impl_.initialize_devex_with_column_norms_ = true;
    _impl_.exploit_singleton_column_in_initial_basis_ = true;
    _impl_.dual_small_pivot_threshold_ = 0.0001;
    _impl_.objective_lower_limit_ = -std::numeric_limits<double>::infinity();
    _impl_.objective_upper_limit_ = std::numeric_limits<double>::infinity();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    _impl_.degenerate_ministep_factor_ = 0.01;
    _impl_.max_deterministic_time_ = std::numeric_limits<double>::infinity();
    _impl_.random_seed_ = 1;
    _impl_.scaling_method_ = 1;
    _impl_.drop_tolerance_ = 1e-14;
    _impl_.relative_cost_perturbation_ = 1e-05;
    _impl_.relative_max_cost_perturbation_ = 1e-07;
    _impl_.max_number_of_reoptimizations_ = 40;
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    _impl_.initial_condition_number_threshold_ = 1e+50;
    _impl_.cost_scaling_ = 1;
    _impl_.change_status_to_imprecise_ = true;
    _impl_.use_dedicated_dual_feasibility_algorithm_ = true;
    _impl_.dynamically_adjust_refactorization_period_ = true;
    _impl_.push_to_vertex_ = true;
    _impl_.crossover_bound_snapping_distance_ = std::numeric_limits<double>::infinity();
    _impl_.max_valid_magnitude_ = 1e+30;
  }
  if (BatchCheckHasBit(cached_has_bits, 0x07000000U)) {
    _impl_.drop_magnitude_ = 1e-30;
    _impl_.log_to_stdout_ = true;
    _impl_.use_implied_free_preprocessor_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL GlopParameters::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const GlopParameters& this_ = static_cast<const GlopParameters&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL GlopParameters::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const GlopParameters& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.glop.GlopParameters)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_feasibility_rule(), target);
  }

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this_._internal_optimization_rule(), target);
  }

  // optional double refactorization_threshold = 6 [default = 1e-09];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this_._internal_refactorization_threshold(), target);
  }

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-08];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this_._internal_recompute_reduced_costs_threshold(), target);
  }

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this_._internal_recompute_edges_norm_threshold(), target);
  }

  // optional double primal_feasibility_tolerance = 10 [default = 1e-08];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        10, this_._internal_primal_feasibility_tolerance(), target);
  }

  // optional double dual_feasibility_tolerance = 11 [default = 1e-08];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        11, this_._internal_dual_feasibility_tolerance(), target);
  }

  // optional double ratio_test_zero_threshold = 12 [default = 1e-09];
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        12, this_._internal_ratio_test_zero_threshold(), target);
  }

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        13, this_._internal_harris_tolerance_ratio(), target);
  }

  // optional double small_pivot_threshold = 14 [default = 1e-06];
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this_._internal_small_pivot_threshold(), target);
  }

  // optional double minimum_acceptable_pivot = 15 [default = 1e-06];
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        15, this_._internal_minimum_acceptable_pivot(), target);
  }

  // optional bool use_scaling = 16 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        16, this_._internal_use_scaling(), target);
  }

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        17, this_._internal_initial_basis(), target);
  }

  // optional bool use_transposed_matrix = 18 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this_._internal_use_transposed_matrix(), target);
  }

  // optional int32 basis_refactorization_period = 19 [default = 64];
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        19, this_._internal_basis_refactorization_period(), target);
  }

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        20, this_._internal_solve_dual_problem(), target);
  }

  // optional double dualizer_threshold = 21 [default = 1.5];
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        21, this_._internal_dualizer_threshold(), target);
  }

  // optional double solution_feasibility_tolerance = 22 [default = 1e-06];
  if (CheckHasBit(cached_has_bits, 0x00080000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        22, this_._internal_solution_feasibility_tolerance(), target);
  }

  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        24, this_._internal_provide_strong_optimal_guarantee(), target);
  }

  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  if (CheckHasBit(cached_has_bits, 0x00100000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        25, this_._internal_lu_factorization_pivot_threshold(), target);
  }

  // optional double max_time_in_seconds = 26 [default = inf];
  if (CheckHasBit(cached_has_bits, 0x00200000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        26, this_._internal_max_time_in_seconds(), target);
  }

  // optional int64 max_number_of_iterations = 27 [default = -1];
  if (CheckHasBit(cached_has_bits, 0x00400000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        27, this_._internal_max_number_of_iterations(), target);
  }

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  if (CheckHasBit(cached_has_bits, 0x01000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this_._internal_markowitz_zlatev_parameter(), target);
  }

  // optional double markowitz_singularity_threshold = 30 [default = 1e-15];
  if (CheckHasBit(cached_has_bits, 0x00800000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        30, this_._internal_markowitz_singularity_threshold(), target);
  }

  // optional bool use_dual_simplex = 31 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        31, this_._internal_use_dual_simplex(), target);
  }

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  if (CheckHasBit(cached_has_bits, 0x08000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        32, this_._internal_allow_simplex_algorithm_change(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional int32 devex_weights_reset_period = 33 [default = 150];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        33, this_._internal_devex_weights_reset_period(), target);
  }

  // optional bool use_preprocessing = 34 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        34, this_._internal_use_preprocessing(), target);
  }

  // optional bool use_middle_product_form_update = 35 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        35, this_._internal_use_middle_product_form_update(), target);
  }

  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        36, this_._internal_initialize_devex_with_column_norms(), target);
  }

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        37, this_._internal_exploit_singleton_column_in_initial_basis(), target);
  }

  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        38, this_._internal_dual_small_pivot_threshold(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional double preprocessor_zero_tolerance = 39 [default = 1e-09];
  if (CheckHasBit(cached_has_bits, 0x04000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        39, this_._internal_preprocessor_zero_tolerance(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional double objective_lower_limit = 40 [default = -inf];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        40, this_._internal_objective_lower_limit(), target);
  }

  // optional double objective_upper_limit = 41 [default = inf];
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        41, this_._internal_objective_upper_limit(), target);
  }

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        42, this_._internal_degenerate_ministep_factor(), target);
  }

  // optional int32 random_seed = 43 [default = 1];
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        43, this_._internal_random_seed(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional int32 num_omp_threads = 44 [default = 1];
  if (CheckHasBit(cached_has_bits, 0x02000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        44, this_._internal_num_omp_threads(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional double max_deterministic_time = 45 [default = inf];
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        45, this_._internal_max_deterministic_time(), target);
  }

  // optional double drop_tolerance = 52 [default = 1e-14];
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        52, this_._internal_drop_tolerance(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  if (CheckHasBit(cached_has_bits, 0x10000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        53, this_._internal_perturb_costs_in_dual_simplex(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional double relative_cost_perturbation = 54 [default = 1e-05];
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        54, this_._internal_relative_cost_perturbation(), target);
  }

  // optional double relative_max_cost_perturbation = 55 [default = 1e-07];
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        55, this_._internal_relative_max_cost_perturbation(), target);
  }

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        56, this_._internal_max_number_of_reoptimizations(), target);
  }

  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        57, this_._internal_scaling_method(), target);
  }

  // optional bool change_status_to_imprecise = 58 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        58, this_._internal_change_status_to_imprecise(), target);
  }

  // optional double initial_condition_number_threshold = 59 [default = 1e+50];
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        59, this_._internal_initial_condition_number_threshold(), target);
  }

  // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        60, this_._internal_cost_scaling(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool log_search_progress = 61 [default = false];
  if (CheckHasBit(cached_has_bits, 0x20000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        61, this_._internal_log_search_progress(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00080000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        62, this_._internal_use_dedicated_dual_feasibility_algorithm(), target);
  }

  // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00100000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        63, this_._internal_dynamically_adjust_refactorization_period(), target);
  }

  // optional double crossover_bound_snapping_distance = 64 [default = inf];
  if (CheckHasBit(cached_has_bits, 0x00400000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        64, this_._internal_crossover_bound_snapping_distance(), target);
  }

  // optional bool push_to_vertex = 65 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00200000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        65, this_._internal_push_to_vertex(), target);
  }

  // optional bool log_to_stdout = 66 [default = true];
  if (CheckHasBit(cached_has_bits, 0x02000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        66, this_._internal_log_to_stdout(), target);
  }

  // optional bool use_implied_free_preprocessor = 67 [default = true];
  if (CheckHasBit(cached_has_bits, 0x04000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        67, this_._internal_use_implied_free_preprocessor(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool dual_price_prioritize_norm = 69 [default = false];
  if (CheckHasBit(cached_has_bits, 0x40000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        69, this_._internal_dual_price_prioritize_norm(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[1];
  // optional double max_valid_magnitude = 70 [default = 1e+30];
  if (CheckHasBit(cached_has_bits, 0x00800000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        70, this_._internal_max_valid_magnitude(), target);
  }

  // optional double drop_magnitude = 71 [default = 1e-30];
  if (CheckHasBit(cached_has_bits, 0x01000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        71, this_._internal_drop_magnitude(), target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool use_absl_random = 72 [default = false];
  if (CheckHasBit(cached_has_bits, 0x80000000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        72, this_._internal_use_absl_random(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.glop.GlopParameters)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t GlopParameters::ByteSizeLong(const MessageLite& base) {
  const GlopParameters& this_ = static_cast<const GlopParameters&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t GlopParameters::ByteSizeLong() const {
  const GlopParameters& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:operations_research.glop.GlopParameters)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x04bc0000U & cached_has_bits) * 10;
  total_size += ::absl::popcount(0x00000ff8U & cached_has_bits) * 9;
  total_size += ::absl::popcount(0xf801c001U & cached_has_bits) * 3;
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_feasibility_rule());
    }
    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_optimization_rule());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00003000U)) {
    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_initial_basis());
    }
    // optional int32 basis_refactorization_period = 19 [default = 64];
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_basis_refactorization_period());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00420000U)) {
    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_solve_dual_problem());
    }
    // optional int64 max_number_of_iterations = 27 [default = -1];
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                      this_._internal_max_number_of_iterations());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x03000000U)) {
    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    if (CheckHasBit(cached_has_bits, 0x01000000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_markowitz_zlatev_parameter());
    }
    // optional int32 num_omp_threads = 44 [default = 1];
    if (CheckHasBit(cached_has_bits, 0x02000000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_num_omp_threads());
    }
  }
  cached_has_bits = this_._impl_._has_bits_[1];
  total_size += ::absl::popcount(0x01c1f3e0U & cached_has_bits) * 10;
  total_size += ::absl::popcount(0x063c001eU & cached_has_bits) * 3;
   {
    // optional int32 devex_weights_reset_period = 33 [default = 150];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_devex_weights_reset_period());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000c00U)) {
    // optional int32 random_seed = 43 [default = 1];
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this_._internal_random_seed());
    }
    // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_scaling_method());
    }
  }
   {
    // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_cost_scaling());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void GlopParameters::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<GlopParameters*>(&to_msg);
  auto& from = static_cast<const GlopParameters&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.glop.GlopParameters)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.use_dual_simplex_ = from._impl_.use_dual_simplex_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.feasibility_rule_ = from._impl_.feasibility_rule_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.optimization_rule_ = from._impl_.optimization_rule_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.refactorization_threshold_ = from._impl_.refactorization_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.recompute_reduced_costs_threshold_ = from._impl_.recompute_reduced_costs_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.recompute_edges_norm_threshold_ = from._impl_.recompute_edges_norm_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.primal_feasibility_tolerance_ = from._impl_.primal_feasibility_tolerance_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.dual_feasibility_tolerance_ = from._impl_.dual_feasibility_tolerance_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.ratio_test_zero_threshold_ = from._impl_.ratio_test_zero_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.harris_tolerance_ratio_ = from._impl_.harris_tolerance_ratio_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.small_pivot_threshold_ = from._impl_.small_pivot_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.minimum_acceptable_pivot_ = from._impl_.minimum_acceptable_pivot_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.initial_basis_ = from._impl_.initial_basis_;
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _this->_impl_.basis_refactorization_period_ = from._impl_.basis_refactorization_period_;
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _this->_impl_.use_scaling_ = from._impl_.use_scaling_;
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      _this->_impl_.use_transposed_matrix_ = from._impl_.use_transposed_matrix_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      _this->_impl_.provide_strong_optimal_guarantee_ = from._impl_.provide_strong_optimal_guarantee_;
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      _this->_impl_.solve_dual_problem_ = from._impl_.solve_dual_problem_;
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      _this->_impl_.dualizer_threshold_ = from._impl_.dualizer_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      _this->_impl_.solution_feasibility_tolerance_ = from._impl_.solution_feasibility_tolerance_;
    }
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      _this->_impl_.lu_factorization_pivot_threshold_ = from._impl_.lu_factorization_pivot_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00200000U)) {
      _this->_impl_.max_time_in_seconds_ = from._impl_.max_time_in_seconds_;
    }
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      _this->_impl_.max_number_of_iterations_ = from._impl_.max_number_of_iterations_;
    }
    if (CheckHasBit(cached_has_bits, 0x00800000U)) {
      _this->_impl_.markowitz_singularity_threshold_ = from._impl_.markowitz_singularity_threshold_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0xff000000U)) {
    if (CheckHasBit(cached_has_bits, 0x01000000U)) {
      _this->_impl_.markowitz_zlatev_parameter_ = from._impl_.markowitz_zlatev_parameter_;
    }
    if (CheckHasBit(cached_has_bits, 0x02000000U)) {
      _this->_impl_.num_omp_threads_ = from._impl_.num_omp_threads_;
    }
    if (CheckHasBit(cached_has_bits, 0x04000000U)) {
      _this->_impl_.preprocessor_zero_tolerance_ = from._impl_.preprocessor_zero_tolerance_;
    }
    if (CheckHasBit(cached_has_bits, 0x08000000U)) {
      _this->_impl_.allow_simplex_algorithm_change_ = from._impl_.allow_simplex_algorithm_change_;
    }
    if (CheckHasBit(cached_has_bits, 0x10000000U)) {
      _this->_impl_.perturb_costs_in_dual_simplex_ = from._impl_.perturb_costs_in_dual_simplex_;
    }
    if (CheckHasBit(cached_has_bits, 0x20000000U)) {
      _this->_impl_.log_search_progress_ = from._impl_.log_search_progress_;
    }
    if (CheckHasBit(cached_has_bits, 0x40000000U)) {
      _this->_impl_.dual_price_prioritize_norm_ = from._impl_.dual_price_prioritize_norm_;
    }
    if (CheckHasBit(cached_has_bits, 0x80000000U)) {
      _this->_impl_.use_absl_random_ = from._impl_.use_absl_random_;
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.devex_weights_reset_period_ = from._impl_.devex_weights_reset_period_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.use_preprocessing_ = from._impl_.use_preprocessing_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.use_middle_product_form_update_ = from._impl_.use_middle_product_form_update_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.initialize_devex_with_column_norms_ = from._impl_.initialize_devex_with_column_norms_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.exploit_singleton_column_in_initial_basis_ = from._impl_.exploit_singleton_column_in_initial_basis_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.dual_small_pivot_threshold_ = from._impl_.dual_small_pivot_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.objective_lower_limit_ = from._impl_.objective_lower_limit_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.objective_upper_limit_ = from._impl_.objective_upper_limit_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.degenerate_ministep_factor_ = from._impl_.degenerate_ministep_factor_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.max_deterministic_time_ = from._impl_.max_deterministic_time_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.scaling_method_ = from._impl_.scaling_method_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.drop_tolerance_ = from._impl_.drop_tolerance_;
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _this->_impl_.relative_cost_perturbation_ = from._impl_.relative_cost_perturbation_;
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _this->_impl_.relative_max_cost_perturbation_ = from._impl_.relative_max_cost_perturbation_;
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      _this->_impl_.max_number_of_reoptimizations_ = from._impl_.max_number_of_reoptimizations_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00ff0000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      _this->_impl_.initial_condition_number_threshold_ = from._impl_.initial_condition_number_threshold_;
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      _this->_impl_.cost_scaling_ = from._impl_.cost_scaling_;
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      _this->_impl_.change_status_to_imprecise_ = from._impl_.change_status_to_imprecise_;
    }
    if (CheckHasBit(cached_has_bits, 0x00080000U)) {
      _this->_impl_.use_dedicated_dual_feasibility_algorithm_ = from._impl_.use_dedicated_dual_feasibility_algorithm_;
    }
    if (CheckHasBit(cached_has_bits, 0x00100000U)) {
      _this->_impl_.dynamically_adjust_refactorization_period_ = from._impl_.dynamically_adjust_refactorization_period_;
    }
    if (CheckHasBit(cached_has_bits, 0x00200000U)) {
      _this->_impl_.push_to_vertex_ = from._impl_.push_to_vertex_;
    }
    if (CheckHasBit(cached_has_bits, 0x00400000U)) {
      _this->_impl_.crossover_bound_snapping_distance_ = from._impl_.crossover_bound_snapping_distance_;
    }
    if (CheckHasBit(cached_has_bits, 0x00800000U)) {
      _this->_impl_.max_valid_magnitude_ = from._impl_.max_valid_magnitude_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x07000000U)) {
    if (CheckHasBit(cached_has_bits, 0x01000000U)) {
      _this->_impl_.drop_magnitude_ = from._impl_.drop_magnitude_;
    }
    if (CheckHasBit(cached_has_bits, 0x02000000U)) {
      _this->_impl_.log_to_stdout_ = from._impl_.log_to_stdout_;
    }
    if (CheckHasBit(cached_has_bits, 0x04000000U)) {
      _this->_impl_.use_implied_free_preprocessor_ = from._impl_.use_implied_free_preprocessor_;
    }
  }
  _this->_impl_._has_bits_.Or(from._impl_._has_bits_);
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void GlopParameters::CopyFrom(const GlopParameters& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:operations_research.glop.GlopParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void GlopParameters::InternalSwap(GlopParameters* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_implied_free_preprocessor_)
      + sizeof(GlopParameters::_impl_.use_implied_free_preprocessor_)
      - PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_dual_simplex_)>(
          reinterpret_cast<char*>(&_impl_.use_dual_simplex_),
          reinterpret_cast<char*>(&other->_impl_.use_dual_simplex_));
}

::google::protobuf::Metadata GlopParameters::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace glop
}  // namespace operations_research
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
