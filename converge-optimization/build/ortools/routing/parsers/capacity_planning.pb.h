// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ortools/routing/parsers/capacity_planning.proto
// Protobuf C++ Version: 6.33.1

#ifndef ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto_2epb_2eh
#define ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto OR_PROTO_DLL

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct OR_PROTO_DLL TableStruct_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
OR_PROTO_DLL extern const ::google::protobuf::internal::DescriptorTable descriptor_table_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto;
}  // extern "C"
namespace operations_research {
namespace routing {
class CapacityPlanningInstance;
struct CapacityPlanningInstanceDefaultTypeInternal;
OR_PROTO_DLL extern CapacityPlanningInstanceDefaultTypeInternal _CapacityPlanningInstance_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CapacityPlanningInstance_class_data_;
class Commodities;
struct CommoditiesDefaultTypeInternal;
OR_PROTO_DLL extern CommoditiesDefaultTypeInternal _Commodities_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull Commodities_class_data_;
class NetworkTopology;
struct NetworkTopologyDefaultTypeInternal;
OR_PROTO_DLL extern NetworkTopologyDefaultTypeInternal _NetworkTopology_default_instance_;
OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NetworkTopology_class_data_;
}  // namespace routing
}  // namespace operations_research
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace operations_research {
namespace routing {

// ===================================================================


// -------------------------------------------------------------------

class OR_PROTO_DLL NetworkTopology final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.routing.NetworkTopology) */ {
 public:
  inline NetworkTopology() : NetworkTopology(nullptr) {}
  ~NetworkTopology() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NetworkTopology* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NetworkTopology));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkTopology(::google::protobuf::internal::ConstantInitialized);

  inline NetworkTopology(const NetworkTopology& from) : NetworkTopology(nullptr, from) {}
  inline NetworkTopology(NetworkTopology&& from) noexcept
      : NetworkTopology(nullptr, ::std::move(from)) {}
  inline NetworkTopology& operator=(const NetworkTopology& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkTopology& operator=(NetworkTopology&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkTopology& default_instance() {
    return *reinterpret_cast<const NetworkTopology*>(
        &_NetworkTopology_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NetworkTopology& a, NetworkTopology& b) { a.Swap(&b); }
  inline void Swap(NetworkTopology* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkTopology* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkTopology* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NetworkTopology>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkTopology& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NetworkTopology& from) { NetworkTopology::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NetworkTopology* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.routing.NetworkTopology"; }

  explicit NetworkTopology(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NetworkTopology(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NetworkTopology& from);
  NetworkTopology(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NetworkTopology&& from) noexcept
      : NetworkTopology(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromNodeFieldNumber = 1,
    kToNodeFieldNumber = 2,
    kVariableCostFieldNumber = 3,
    kFixedCostFieldNumber = 4,
    kCapacityFieldNumber = 5,
  };
  // repeated int32 from_node = 1;
  int from_node_size() const;
  private:
  int _internal_from_node_size() const;

  public:
  void clear_from_node() ;
  ::int32_t from_node(int index) const;
  void set_from_node(int index, ::int32_t value);
  void add_from_node(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& from_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_from_node();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_from_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_from_node();

  public:
  // repeated int32 to_node = 2;
  int to_node_size() const;
  private:
  int _internal_to_node_size() const;

  public:
  void clear_to_node() ;
  ::int32_t to_node(int index) const;
  void set_to_node(int index, ::int32_t value);
  void add_to_node(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& to_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_to_node();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_to_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_to_node();

  public:
  // repeated double variable_cost = 3;
  int variable_cost_size() const;
  private:
  int _internal_variable_cost_size() const;

  public:
  void clear_variable_cost() ;
  double variable_cost(int index) const;
  void set_variable_cost(int index, double value);
  void add_variable_cost(double value);
  const ::google::protobuf::RepeatedField<double>& variable_cost() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_variable_cost();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_variable_cost() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_variable_cost();

  public:
  // repeated double fixed_cost = 4;
  int fixed_cost_size() const;
  private:
  int _internal_fixed_cost_size() const;

  public:
  void clear_fixed_cost() ;
  double fixed_cost(int index) const;
  void set_fixed_cost(int index, double value);
  void add_fixed_cost(double value);
  const ::google::protobuf::RepeatedField<double>& fixed_cost() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_fixed_cost();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_fixed_cost() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_fixed_cost();

  public:
  // repeated double capacity = 5;
  int capacity_size() const;
  private:
  int _internal_capacity_size() const;

  public:
  void clear_capacity() ;
  double capacity(int index) const;
  void set_capacity(int index, double value);
  void add_capacity(double value);
  const ::google::protobuf::RepeatedField<double>& capacity() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_capacity();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_capacity() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_capacity();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.routing.NetworkTopology)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NetworkTopology& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> from_node_;
    ::google::protobuf::internal::CachedSize _from_node_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> to_node_;
    ::google::protobuf::internal::CachedSize _to_node_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> variable_cost_;
    ::google::protobuf::RepeatedField<double> fixed_cost_;
    ::google::protobuf::RepeatedField<double> capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull NetworkTopology_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL Commodities final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.routing.Commodities) */ {
 public:
  inline Commodities() : Commodities(nullptr) {}
  ~Commodities() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Commodities* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Commodities));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Commodities(::google::protobuf::internal::ConstantInitialized);

  inline Commodities(const Commodities& from) : Commodities(nullptr, from) {}
  inline Commodities(Commodities&& from) noexcept
      : Commodities(nullptr, ::std::move(from)) {}
  inline Commodities& operator=(const Commodities& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commodities& operator=(Commodities&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commodities& default_instance() {
    return *reinterpret_cast<const Commodities*>(
        &_Commodities_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Commodities& a, Commodities& b) { a.Swap(&b); }
  inline void Swap(Commodities* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commodities* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commodities* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Commodities>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Commodities& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Commodities& from) { Commodities::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Commodities* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.routing.Commodities"; }

  explicit Commodities(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Commodities(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Commodities& from);
  Commodities(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Commodities&& from) noexcept
      : Commodities(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromNodeFieldNumber = 1,
    kToNodeFieldNumber = 2,
    kDemandFieldNumber = 3,
  };
  // repeated int32 from_node = 1;
  int from_node_size() const;
  private:
  int _internal_from_node_size() const;

  public:
  void clear_from_node() ;
  ::int32_t from_node(int index) const;
  void set_from_node(int index, ::int32_t value);
  void add_from_node(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& from_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_from_node();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_from_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_from_node();

  public:
  // repeated int32 to_node = 2;
  int to_node_size() const;
  private:
  int _internal_to_node_size() const;

  public:
  void clear_to_node() ;
  ::int32_t to_node(int index) const;
  void set_to_node(int index, ::int32_t value);
  void add_to_node(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& to_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL mutable_to_node();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_to_node() const;
  ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL _internal_mutable_to_node();

  public:
  // repeated double demand = 3;
  int demand_size() const;
  private:
  int _internal_demand_size() const;

  public:
  void clear_demand() ;
  double demand(int index) const;
  void set_demand(int index, double value);
  void add_demand(double value);
  const ::google::protobuf::RepeatedField<double>& demand() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL mutable_demand();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_demand() const;
  ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL _internal_mutable_demand();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.routing.Commodities)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Commodities& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> from_node_;
    ::google::protobuf::internal::CachedSize _from_node_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> to_node_;
    ::google::protobuf::internal::CachedSize _to_node_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> demand_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull Commodities_class_data_;
// -------------------------------------------------------------------

class OR_PROTO_DLL CapacityPlanningInstance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:operations_research.routing.CapacityPlanningInstance) */ {
 public:
  inline CapacityPlanningInstance() : CapacityPlanningInstance(nullptr) {}
  ~CapacityPlanningInstance() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CapacityPlanningInstance* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CapacityPlanningInstance));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacityPlanningInstance(::google::protobuf::internal::ConstantInitialized);

  inline CapacityPlanningInstance(const CapacityPlanningInstance& from) : CapacityPlanningInstance(nullptr, from) {}
  inline CapacityPlanningInstance(CapacityPlanningInstance&& from) noexcept
      : CapacityPlanningInstance(nullptr, ::std::move(from)) {}
  inline CapacityPlanningInstance& operator=(const CapacityPlanningInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityPlanningInstance& operator=(CapacityPlanningInstance&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacityPlanningInstance& default_instance() {
    return *reinterpret_cast<const CapacityPlanningInstance*>(
        &_CapacityPlanningInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CapacityPlanningInstance& a, CapacityPlanningInstance& b) { a.Swap(&b); }
  inline void Swap(CapacityPlanningInstance* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityPlanningInstance* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacityPlanningInstance* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CapacityPlanningInstance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacityPlanningInstance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacityPlanningInstance& from) { CapacityPlanningInstance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CapacityPlanningInstance* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "operations_research.routing.CapacityPlanningInstance"; }

  explicit CapacityPlanningInstance(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CapacityPlanningInstance(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CapacityPlanningInstance& from);
  CapacityPlanningInstance(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CapacityPlanningInstance&& from) noexcept
      : CapacityPlanningInstance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopologyFieldNumber = 1,
    kCommoditiesFieldNumber = 2,
  };
  // .operations_research.routing.NetworkTopology topology = 1;
  bool has_topology() const;
  void clear_topology() ;
  const ::operations_research::routing::NetworkTopology& topology() const;
  [[nodiscard]] ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE release_topology();
  ::operations_research::routing::NetworkTopology* PROTOBUF_NONNULL mutable_topology();
  void set_allocated_topology(::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_topology(::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE value);
  ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE unsafe_arena_release_topology();

  private:
  const ::operations_research::routing::NetworkTopology& _internal_topology() const;
  ::operations_research::routing::NetworkTopology* PROTOBUF_NONNULL _internal_mutable_topology();

  public:
  // .operations_research.routing.Commodities commodities = 2;
  bool has_commodities() const;
  void clear_commodities() ;
  const ::operations_research::routing::Commodities& commodities() const;
  [[nodiscard]] ::operations_research::routing::Commodities* PROTOBUF_NULLABLE release_commodities();
  ::operations_research::routing::Commodities* PROTOBUF_NONNULL mutable_commodities();
  void set_allocated_commodities(::operations_research::routing::Commodities* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_commodities(::operations_research::routing::Commodities* PROTOBUF_NULLABLE value);
  ::operations_research::routing::Commodities* PROTOBUF_NULLABLE unsafe_arena_release_commodities();

  private:
  const ::operations_research::routing::Commodities& _internal_commodities() const;
  ::operations_research::routing::Commodities* PROTOBUF_NONNULL _internal_mutable_commodities();

  public:
  // @@protoc_insertion_point(class_scope:operations_research.routing.CapacityPlanningInstance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CapacityPlanningInstance& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE topology_;
    ::operations_research::routing::Commodities* PROTOBUF_NULLABLE commodities_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto;
};

OR_PROTO_DLL extern const ::google::protobuf::internal::ClassDataFull CapacityPlanningInstance_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NetworkTopology

// repeated int32 from_node = 1;
inline int NetworkTopology::_internal_from_node_size() const {
  return _internal_from_node().size();
}
inline int NetworkTopology::from_node_size() const {
  return _internal_from_node_size();
}
inline void NetworkTopology::clear_from_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_node_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t NetworkTopology::from_node(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.NetworkTopology.from_node)
  return _internal_from_node().Get(index);
}
inline void NetworkTopology::set_from_node(int index, ::int32_t value) {
  _internal_mutable_from_node()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.NetworkTopology.from_node)
}
inline void NetworkTopology::add_from_node(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_from_node()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.routing.NetworkTopology.from_node)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NetworkTopology::from_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.NetworkTopology.from_node)
  return _internal_from_node();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL NetworkTopology::mutable_from_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.NetworkTopology.from_node)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_from_node();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
NetworkTopology::_internal_from_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_node_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
NetworkTopology::_internal_mutable_from_node() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.from_node_;
}

// repeated int32 to_node = 2;
inline int NetworkTopology::_internal_to_node_size() const {
  return _internal_to_node().size();
}
inline int NetworkTopology::to_node_size() const {
  return _internal_to_node_size();
}
inline void NetworkTopology::clear_to_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_node_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t NetworkTopology::to_node(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.NetworkTopology.to_node)
  return _internal_to_node().Get(index);
}
inline void NetworkTopology::set_to_node(int index, ::int32_t value) {
  _internal_mutable_to_node()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.NetworkTopology.to_node)
}
inline void NetworkTopology::add_to_node(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_to_node()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.routing.NetworkTopology.to_node)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NetworkTopology::to_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.NetworkTopology.to_node)
  return _internal_to_node();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL NetworkTopology::mutable_to_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.NetworkTopology.to_node)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_to_node();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
NetworkTopology::_internal_to_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_node_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
NetworkTopology::_internal_mutable_to_node() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.to_node_;
}

// repeated double variable_cost = 3;
inline int NetworkTopology::_internal_variable_cost_size() const {
  return _internal_variable_cost().size();
}
inline int NetworkTopology::variable_cost_size() const {
  return _internal_variable_cost_size();
}
inline void NetworkTopology::clear_variable_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.variable_cost_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double NetworkTopology::variable_cost(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.NetworkTopology.variable_cost)
  return _internal_variable_cost().Get(index);
}
inline void NetworkTopology::set_variable_cost(int index, double value) {
  _internal_mutable_variable_cost()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.NetworkTopology.variable_cost)
}
inline void NetworkTopology::add_variable_cost(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_variable_cost()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.routing.NetworkTopology.variable_cost)
}
inline const ::google::protobuf::RepeatedField<double>& NetworkTopology::variable_cost() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.NetworkTopology.variable_cost)
  return _internal_variable_cost();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL NetworkTopology::mutable_variable_cost()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.NetworkTopology.variable_cost)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_variable_cost();
}
inline const ::google::protobuf::RepeatedField<double>&
NetworkTopology::_internal_variable_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.variable_cost_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
NetworkTopology::_internal_mutable_variable_cost() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.variable_cost_;
}

// repeated double fixed_cost = 4;
inline int NetworkTopology::_internal_fixed_cost_size() const {
  return _internal_fixed_cost().size();
}
inline int NetworkTopology::fixed_cost_size() const {
  return _internal_fixed_cost_size();
}
inline void NetworkTopology::clear_fixed_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fixed_cost_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000008U);
}
inline double NetworkTopology::fixed_cost(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.NetworkTopology.fixed_cost)
  return _internal_fixed_cost().Get(index);
}
inline void NetworkTopology::set_fixed_cost(int index, double value) {
  _internal_mutable_fixed_cost()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.NetworkTopology.fixed_cost)
}
inline void NetworkTopology::add_fixed_cost(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_fixed_cost()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_add:operations_research.routing.NetworkTopology.fixed_cost)
}
inline const ::google::protobuf::RepeatedField<double>& NetworkTopology::fixed_cost() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.NetworkTopology.fixed_cost)
  return _internal_fixed_cost();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL NetworkTopology::mutable_fixed_cost()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.NetworkTopology.fixed_cost)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fixed_cost();
}
inline const ::google::protobuf::RepeatedField<double>&
NetworkTopology::_internal_fixed_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fixed_cost_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
NetworkTopology::_internal_mutable_fixed_cost() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fixed_cost_;
}

// repeated double capacity = 5;
inline int NetworkTopology::_internal_capacity_size() const {
  return _internal_capacity().size();
}
inline int NetworkTopology::capacity_size() const {
  return _internal_capacity_size();
}
inline void NetworkTopology::clear_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000010U);
}
inline double NetworkTopology::capacity(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.NetworkTopology.capacity)
  return _internal_capacity().Get(index);
}
inline void NetworkTopology::set_capacity(int index, double value) {
  _internal_mutable_capacity()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.NetworkTopology.capacity)
}
inline void NetworkTopology::add_capacity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_capacity()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_add:operations_research.routing.NetworkTopology.capacity)
}
inline const ::google::protobuf::RepeatedField<double>& NetworkTopology::capacity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.NetworkTopology.capacity)
  return _internal_capacity();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL NetworkTopology::mutable_capacity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.NetworkTopology.capacity)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capacity();
}
inline const ::google::protobuf::RepeatedField<double>&
NetworkTopology::_internal_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capacity_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
NetworkTopology::_internal_mutable_capacity() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capacity_;
}

// -------------------------------------------------------------------

// Commodities

// repeated int32 from_node = 1;
inline int Commodities::_internal_from_node_size() const {
  return _internal_from_node().size();
}
inline int Commodities::from_node_size() const {
  return _internal_from_node_size();
}
inline void Commodities::clear_from_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_node_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t Commodities::from_node(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.Commodities.from_node)
  return _internal_from_node().Get(index);
}
inline void Commodities::set_from_node(int index, ::int32_t value) {
  _internal_mutable_from_node()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.Commodities.from_node)
}
inline void Commodities::add_from_node(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_from_node()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:operations_research.routing.Commodities.from_node)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Commodities::from_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.Commodities.from_node)
  return _internal_from_node();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL Commodities::mutable_from_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.Commodities.from_node)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_from_node();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Commodities::_internal_from_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_node_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
Commodities::_internal_mutable_from_node() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.from_node_;
}

// repeated int32 to_node = 2;
inline int Commodities::_internal_to_node_size() const {
  return _internal_to_node().size();
}
inline int Commodities::to_node_size() const {
  return _internal_to_node_size();
}
inline void Commodities::clear_to_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_node_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t Commodities::to_node(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.Commodities.to_node)
  return _internal_to_node().Get(index);
}
inline void Commodities::set_to_node(int index, ::int32_t value) {
  _internal_mutable_to_node()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.Commodities.to_node)
}
inline void Commodities::add_to_node(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_to_node()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_add:operations_research.routing.Commodities.to_node)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Commodities::to_node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.Commodities.to_node)
  return _internal_to_node();
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL Commodities::mutable_to_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.Commodities.to_node)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_to_node();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
Commodities::_internal_to_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_node_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* PROTOBUF_NONNULL
Commodities::_internal_mutable_to_node() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.to_node_;
}

// repeated double demand = 3;
inline int Commodities::_internal_demand_size() const {
  return _internal_demand().size();
}
inline int Commodities::demand_size() const {
  return _internal_demand_size();
}
inline void Commodities::clear_demand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.demand_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline double Commodities::demand(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.routing.Commodities.demand)
  return _internal_demand().Get(index);
}
inline void Commodities::set_demand(int index, double value) {
  _internal_mutable_demand()->Set(index, value);
  // @@protoc_insertion_point(field_set:operations_research.routing.Commodities.demand)
}
inline void Commodities::add_demand(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_demand()->Add(value);
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_add:operations_research.routing.Commodities.demand)
}
inline const ::google::protobuf::RepeatedField<double>& Commodities::demand() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:operations_research.routing.Commodities.demand)
  return _internal_demand();
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL Commodities::mutable_demand()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_list:operations_research.routing.Commodities.demand)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_demand();
}
inline const ::google::protobuf::RepeatedField<double>&
Commodities::_internal_demand() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.demand_;
}
inline ::google::protobuf::RepeatedField<double>* PROTOBUF_NONNULL
Commodities::_internal_mutable_demand() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.demand_;
}

// -------------------------------------------------------------------

// CapacityPlanningInstance

// .operations_research.routing.NetworkTopology topology = 1;
inline bool CapacityPlanningInstance::has_topology() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.topology_ != nullptr);
  return value;
}
inline void CapacityPlanningInstance::clear_topology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.topology_ != nullptr) _impl_.topology_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::operations_research::routing::NetworkTopology& CapacityPlanningInstance::_internal_topology() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::routing::NetworkTopology* p = _impl_.topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::routing::NetworkTopology&>(::operations_research::routing::_NetworkTopology_default_instance_);
}
inline const ::operations_research::routing::NetworkTopology& CapacityPlanningInstance::topology() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.routing.CapacityPlanningInstance.topology)
  return _internal_topology();
}
inline void CapacityPlanningInstance::unsafe_arena_set_allocated_topology(
    ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.topology_);
  }
  _impl_.topology_ = reinterpret_cast<::operations_research::routing::NetworkTopology*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.routing.CapacityPlanningInstance.topology)
}
inline ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE CapacityPlanningInstance::release_topology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::routing::NetworkTopology* released = _impl_.topology_;
  _impl_.topology_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE CapacityPlanningInstance::unsafe_arena_release_topology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.routing.CapacityPlanningInstance.topology)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::routing::NetworkTopology* temp = _impl_.topology_;
  _impl_.topology_ = nullptr;
  return temp;
}
inline ::operations_research::routing::NetworkTopology* PROTOBUF_NONNULL CapacityPlanningInstance::_internal_mutable_topology() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.topology_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::routing::NetworkTopology>(GetArena());
    _impl_.topology_ = reinterpret_cast<::operations_research::routing::NetworkTopology*>(p);
  }
  return _impl_.topology_;
}
inline ::operations_research::routing::NetworkTopology* PROTOBUF_NONNULL CapacityPlanningInstance::mutable_topology()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::operations_research::routing::NetworkTopology* _msg = _internal_mutable_topology();
  // @@protoc_insertion_point(field_mutable:operations_research.routing.CapacityPlanningInstance.topology)
  return _msg;
}
inline void CapacityPlanningInstance::set_allocated_topology(::operations_research::routing::NetworkTopology* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.topology_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.topology_ = reinterpret_cast<::operations_research::routing::NetworkTopology*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.routing.CapacityPlanningInstance.topology)
}

// .operations_research.routing.Commodities commodities = 2;
inline bool CapacityPlanningInstance::has_commodities() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.commodities_ != nullptr);
  return value;
}
inline void CapacityPlanningInstance::clear_commodities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commodities_ != nullptr) _impl_.commodities_->Clear();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline const ::operations_research::routing::Commodities& CapacityPlanningInstance::_internal_commodities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::operations_research::routing::Commodities* p = _impl_.commodities_;
  return p != nullptr ? *p : reinterpret_cast<const ::operations_research::routing::Commodities&>(::operations_research::routing::_Commodities_default_instance_);
}
inline const ::operations_research::routing::Commodities& CapacityPlanningInstance::commodities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:operations_research.routing.CapacityPlanningInstance.commodities)
  return _internal_commodities();
}
inline void CapacityPlanningInstance::unsafe_arena_set_allocated_commodities(
    ::operations_research::routing::Commodities* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.commodities_);
  }
  _impl_.commodities_ = reinterpret_cast<::operations_research::routing::Commodities*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:operations_research.routing.CapacityPlanningInstance.commodities)
}
inline ::operations_research::routing::Commodities* PROTOBUF_NULLABLE CapacityPlanningInstance::release_commodities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::routing::Commodities* released = _impl_.commodities_;
  _impl_.commodities_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::operations_research::routing::Commodities* PROTOBUF_NULLABLE CapacityPlanningInstance::unsafe_arena_release_commodities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:operations_research.routing.CapacityPlanningInstance.commodities)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::routing::Commodities* temp = _impl_.commodities_;
  _impl_.commodities_ = nullptr;
  return temp;
}
inline ::operations_research::routing::Commodities* PROTOBUF_NONNULL CapacityPlanningInstance::_internal_mutable_commodities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commodities_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::operations_research::routing::Commodities>(GetArena());
    _impl_.commodities_ = reinterpret_cast<::operations_research::routing::Commodities*>(p);
  }
  return _impl_.commodities_;
}
inline ::operations_research::routing::Commodities* PROTOBUF_NONNULL CapacityPlanningInstance::mutable_commodities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::operations_research::routing::Commodities* _msg = _internal_mutable_commodities();
  // @@protoc_insertion_point(field_mutable:operations_research.routing.CapacityPlanningInstance.commodities)
  return _msg;
}
inline void CapacityPlanningInstance::set_allocated_commodities(::operations_research::routing::Commodities* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.commodities_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.commodities_ = reinterpret_cast<::operations_research::routing::Commodities*>(value);
  // @@protoc_insertion_point(field_set_allocated:operations_research.routing.CapacityPlanningInstance.commodities)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace routing
}  // namespace operations_research


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // ortools_2frouting_2fparsers_2fcapacity_5fplanning_2eproto_2epb_2eh
