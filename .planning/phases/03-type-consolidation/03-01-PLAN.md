---
phase: 03-type-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - converge-platform/converge-core/src/types/mod.rs
  - converge-platform/converge-core/src/types/id.rs
  - converge-platform/converge-core/src/types/observation.rs
  - converge-platform/converge-core/src/types/proposal.rs
  - converge-platform/converge-core/src/types/fact.rs
  - converge-platform/converge-core/src/types/provenance.rs
  - converge-platform/converge-core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Observation type exists with CaptureContext and ProviderIdentity"
    - "Proposal<Draft> can be created publicly but Proposal<Validated> cannot"
    - "Fact::new() is pub(crate) only - cannot be called from outside converge-core"
    - "PromotionRecord is required field on Fact (not optional)"
    - "All ID types are newtypes with serde transparent serialization"
  artifacts:
    - path: "converge-platform/converge-core/src/types/mod.rs"
      provides: "Module re-exports for types/"
      contains: "pub use"
    - path: "converge-platform/converge-core/src/types/id.rs"
      provides: "Newtype IDs (FactId, ObservationId, ProposalId, etc.)"
      exports: ["FactId", "ObservationId", "ProposalId", "GateId"]
    - path: "converge-platform/converge-core/src/types/observation.rs"
      provides: "Observation, CaptureContext, ProviderIdentity"
      exports: ["Observation", "ObservationKind", "CaptureContext", "ProviderIdentity"]
    - path: "converge-platform/converge-core/src/types/proposal.rs"
      provides: "Type-state Proposal<Draft> and Proposal<Validated>"
      exports: ["Proposal", "Draft", "Validated", "ProposedContent"]
    - path: "converge-platform/converge-core/src/types/fact.rs"
      provides: "Fact with private constructor and PromotionRecord"
      exports: ["Fact", "FactContent"]
    - path: "converge-platform/converge-core/src/types/provenance.rs"
      provides: "PromotionRecord, EvidenceRef, TraceLink"
      exports: ["PromotionRecord", "EvidenceRef", "TraceLink", "LocalTrace", "RemoteRef"]
  key_links:
    - from: "types/fact.rs"
      to: "types/provenance.rs"
      via: "PromotionRecord field on Fact"
      pattern: "promotion_record: PromotionRecord"
    - from: "types/proposal.rs"
      to: "types/id.rs"
      via: "ProposalId field"
      pattern: "id: ProposalId"
    - from: "lib.rs"
      to: "types/"
      via: "pub mod and re-exports"
      pattern: "pub mod types"
---

<objective>
Create the types/ module structure with core domain types following the 3-tier hierarchy (Observation -> Proposal -> Fact) with type-state pattern for proposals and private constructor for Facts.

Purpose: Establish the foundational type vocabulary that enforces "providers return observations, never facts" and "promotion requires validation" at compile-time.

Output: New types/ module with id.rs, observation.rs, proposal.rs, fact.rs, provenance.rs, and re-exports in lib.rs for backward compatibility.
</objective>

<execution_context>
@~/.claude/agents/gsd-planner.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-consolidation/03-RESEARCH.md
@.planning/phases/03-type-consolidation/03-CONTEXT.md

# Existing types to understand migration from
@converge-platform/converge-core/src/context.rs
@converge-platform/converge-core/src/kernel_boundary.rs
@converge-platform/converge-core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types/ module with ID newtypes</name>
  <files>
    converge-platform/converge-core/src/types/mod.rs
    converge-platform/converge-core/src/types/id.rs
  </files>
  <action>
Create the types/ directory and module structure.

**types/id.rs** - Create newtype ID wrappers for type safety:
```rust
use serde::{Deserialize, Serialize};

/// Unique identifier for a Fact.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct FactId(String);

impl FactId {
    pub fn new(id: impl Into<String>) -> Self { Self(id.into()) }
    pub fn as_str(&self) -> &str { &self.0 }
}

impl std::fmt::Display for FactId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

Create similar newtypes for:
- `ObservationId` - identifies raw observations
- `ProposalId` - identifies proposals in any state
- `GateId` - identifies promotion gates
- `ApprovalId` - identifies human approvals
- `ArtifactId` - identifies derived artifacts
- `ContentHash` - wraps `[u8; 32]` with hex Display (use existing Fingerprint trait pattern)
- `Timestamp` - wraps String ISO-8601 (per RESEARCH.md recommendation)

Each ID type needs: `new()`, `as_str()` (or `as_bytes()` for ContentHash), `Display`, and `#[serde(transparent)]`.

**types/mod.rs** - Create module structure with re-exports:
```rust
//! Core type vocabulary for Converge.
//!
//! This module contains the domain types that form Converge's type vocabulary:
//! - ID types (FactId, ObservationId, etc.)
//! - The 3-tier hierarchy: Observation -> Proposal -> Fact
//! - Provenance types (PromotionRecord, EvidenceRef, TraceLink)

pub mod id;
pub mod observation;
pub mod proposal;
pub mod fact;
pub mod provenance;

pub use id::*;
pub use observation::*;
pub use proposal::*;
pub use fact::*;
pub use provenance::*;
```

Note: Start with id.rs and mod.rs only. Other modules will be created in subsequent tasks but need to be declared to avoid compilation errors - create empty placeholder files with `// TODO: implement in Task N` comments.
  </action>
  <verify>
`cargo check -p converge-core` - module compiles (with warnings about unused)
`grep -r "FactId" converge-platform/converge-core/src/types/` - ID type exists
  </verify>
  <done>
types/ module exists with id.rs containing all newtype IDs, mod.rs with module declarations, and placeholder files for other modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Observation and Provenance types</name>
  <files>
    converge-platform/converge-core/src/types/observation.rs
    converge-platform/converge-core/src/types/provenance.rs
  </files>
  <action>
**types/observation.rs** - Raw provider output (evidence ledger):
```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use super::id::{ObservationId, ContentHash, Timestamp};

/// Kind of observation source.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ObservationKind {
    ApiResponse,
    UserInput,
    SystemEvent,
    ExternalFeed,
}

/// Raw provider output - the evidence ledger.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Observation {
    pub id: ObservationId,
    pub kind: ObservationKind,
    pub raw_payload_ref: ContentHash,
    pub capture_context: CaptureContext,
    pub provider: ProviderIdentity,
    pub captured_at: Timestamp,
}

impl Observation {
    /// Create from an API response.
    pub fn from_api_response(
        id: ObservationId,
        raw_payload_ref: ContentHash,
        provider: ProviderIdentity,
        capture_context: CaptureContext,
    ) -> Self {
        Self {
            id,
            kind: ObservationKind::ApiResponse,
            raw_payload_ref,
            capture_context,
            provider,
            captured_at: Timestamp::now(),
        }
    }
}

/// Context of how the observation was captured.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CaptureContext {
    pub request_params: serde_json::Value,
    pub environment: HashMap<String, String>,
    pub session_id: Option<String>,
    pub correlation_id: Option<String>,
}

impl Default for CaptureContext {
    fn default() -> Self {
        Self {
            request_params: serde_json::Value::Null,
            environment: HashMap::new(),
            session_id: None,
            correlation_id: None,
        }
    }
}

/// Provider identity and version.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderIdentity {
    pub name: String,
    pub version: String,
    pub adapter_id: Option<String>,
}
```

**types/provenance.rs** - PromotionRecord, EvidenceRef, TraceLink (per CONTEXT.md):
```rust
use serde::{Deserialize, Serialize};
use super::id::{GateId, ContentHash, Timestamp, ObservationId, ApprovalId, ArtifactId};

/// Typed reference to supporting evidence.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum EvidenceRef {
    Observation(ObservationId),
    HumanApproval(ApprovalId),
    Derived(ArtifactId),
}

/// Trace link for audit and replay.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum TraceLink {
    Local(LocalTrace),
    Remote(RemoteRef),
}

/// Local trace link - replay eligible.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalTrace {
    pub trace_id: String,
    pub span_id: String,
    pub parent_span_id: Option<String>,
    pub sampled: bool,  // Per CONTEXT.md specifics
}

/// Remote trace link - audit eligible only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteRef {
    pub system: String,  // datadog, jaeger, etc.
    pub reference: String,
    pub retrieval_auth: Option<String>,
    pub retention_hint: Option<String>,
}

/// Actor who performed an action.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Actor {
    pub id: String,
    pub kind: ActorKind,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ActorKind {
    Human,
    Agent,
    System,
}

/// Summary of validation checks that passed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationSummary {
    pub checks_passed: Vec<String>,
    pub checks_skipped: Vec<String>,
    pub warnings: Vec<String>,
}

/// Record of how a Fact was promoted (REQUIRED per CONTEXT.md).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PromotionRecord {
    pub gate_id: GateId,
    pub policy_version_hash: ContentHash,
    pub approver: Actor,
    pub validation_summary: ValidationSummary,
    pub evidence_refs: Vec<EvidenceRef>,
    pub trace_link: TraceLink,
    pub promoted_at: Timestamp,
}

impl PromotionRecord {
    /// Strict constructor - all fields required.
    pub fn new(
        gate_id: GateId,
        policy_version_hash: ContentHash,
        approver: Actor,
        validation_summary: ValidationSummary,
        evidence_refs: Vec<EvidenceRef>,
        trace_link: TraceLink,
        promoted_at: Timestamp,
    ) -> Self {
        Self {
            gate_id,
            policy_version_hash,
            approver,
            validation_summary,
            evidence_refs,
            trace_link,
            promoted_at,
        }
    }
}
```
  </action>
  <verify>
`cargo check -p converge-core` - compiles without errors
`grep "PromotionRecord" converge-platform/converge-core/src/types/provenance.rs` - type exists
  </verify>
  <done>
observation.rs has Observation, CaptureContext, ProviderIdentity with appropriate fields.
provenance.rs has PromotionRecord, EvidenceRef, TraceLink with typed enum variants per CONTEXT.md.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create type-state Proposal and private-constructor Fact</name>
  <files>
    converge-platform/converge-core/src/types/proposal.rs
    converge-platform/converge-core/src/types/fact.rs
    converge-platform/converge-core/src/lib.rs
  </files>
  <action>
**types/proposal.rs** - Type-state pattern for proposals:
```rust
use std::marker::PhantomData;
use serde::{Deserialize, Serialize};
use super::id::{ProposalId, ObservationId, ContentHash};
use super::observation::CaptureContext;

/// Marker type: proposal in draft state.
#[derive(Debug, Clone, Copy, Default)]
pub struct Draft;

/// Marker type: proposal validated and ready for promotion.
#[derive(Debug, Clone, Copy, Default)]
pub struct Validated;

/// Content of a proposal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProposedContent {
    pub kind: ProposedContentKind,
    pub content: String,
    pub structured: Option<serde_json::Value>,
    pub confidence: Option<f32>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposedContentKind {
    Claim,
    Plan,
    Classification,
    Evaluation,
    Draft,
    Reasoning,
}

/// Provenance from the source observation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObservationProvenance {
    pub observation_id: ObservationId,
    pub raw_payload_ref: ContentHash,
    pub capture_context: CaptureContext,
}

/// A proposal in a specific lifecycle state.
///
/// State transitions:
/// - Proposal<Draft> -> Proposal<Validated> via PromotionGate::validate()
/// - Proposal<Validated> -> Fact via PromotionGate::promote()
#[derive(Debug, Clone)]
pub struct Proposal<State> {
    pub id: ProposalId,
    pub content: ProposedContent,
    pub provenance: ObservationProvenance,
    _state: PhantomData<State>,
}

impl Proposal<Draft> {
    /// Public constructor for draft proposals.
    pub fn new(id: ProposalId, content: ProposedContent, provenance: ObservationProvenance) -> Self {
        Self { id, content, provenance, _state: PhantomData }
    }
}

impl Proposal<Validated> {
    /// Private constructor - only callable by PromotionGate (in gates module).
    pub(crate) fn from_validated(
        id: ProposalId,
        content: ProposedContent,
        provenance: ObservationProvenance
    ) -> Self {
        Self { id, content, provenance, _state: PhantomData }
    }
}

// Implement Serialize/Deserialize manually since PhantomData doesn't need serialization
impl<S> Serialize for Proposal<S> {
    fn serialize<Ser>(&self, serializer: Ser) -> Result<Ser::Ok, Ser::Error>
    where Ser: serde::Serializer {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("Proposal", 3)?;
        state.serialize_field("id", &self.id)?;
        state.serialize_field("content", &self.content)?;
        state.serialize_field("provenance", &self.provenance)?;
        state.end()
    }
}
```

Note: Deserialize can be impl'd similarly or left as a TODO for Phase 4 (gate pattern will need it).

**types/fact.rs** - Private constructor Fact:
```rust
use serde::{Deserialize, Serialize};
use super::id::{FactId, Timestamp};
use super::provenance::PromotionRecord;

/// Content of a promoted fact.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FactContent {
    pub kind: FactContentKind,
    pub content: String,
    pub structured: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum FactContentKind {
    Claim,
    Plan,
    Classification,
    Evaluation,
    Document,
    Reasoning,
}

/// A promoted, governed truth. Immutable after creation.
///
/// Facts can only be created via PromotionGate::promote(). Direct construction
/// is impossible outside converge-core.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fact {
    id: FactId,
    content: FactContent,
    promotion_record: PromotionRecord,  // Non-optional per CONTEXT.md
    created_at: Timestamp,
}

impl Fact {
    /// Private constructor - only callable by PromotionGate.
    pub(crate) fn new(
        id: FactId,
        content: FactContent,
        promotion_record: PromotionRecord,
        created_at: Timestamp,
    ) -> Self {
        Self { id, content, promotion_record, created_at }
    }

    // Only getter methods, no &mut self methods
    pub fn id(&self) -> &FactId { &self.id }
    pub fn content(&self) -> &FactContent { &self.content }
    pub fn promotion_record(&self) -> &PromotionRecord { &self.promotion_record }
    pub fn created_at(&self) -> &Timestamp { &self.created_at }
}
```

**lib.rs** - Add types module and re-exports:

Add near the top with other module declarations:
```rust
pub mod types;
```

Add re-exports for backward compatibility (keep existing re-exports, add new ones):
```rust
// Re-export new types for convenience
pub use types::{
    // ID types
    FactId, ObservationId, ProposalId, GateId, ApprovalId, ArtifactId,
    ContentHash, Timestamp,
    // Observation types
    Observation, ObservationKind, CaptureContext, ProviderIdentity,
    // Proposal types
    Proposal, Draft, Validated, ProposedContent, ProposedContentKind, ObservationProvenance,
    // Fact types (new Fact will coexist with old temporarily)
    // Note: types::Fact is different from context::Fact - use qualified paths
    FactContent, FactContentKind,
    // Provenance types
    PromotionRecord, EvidenceRef, TraceLink as TypesTraceLink,
    LocalTrace, RemoteRef, Actor, ActorKind, ValidationSummary,
};
```

Note: The existing `context::Fact` will remain for now (backward compatibility). The new `types::Fact` is the proper one with PromotionRecord. Migration will happen gradually in later phases.
  </action>
  <verify>
`cargo check -p converge-core` - compiles
`cargo test -p converge-core` - all existing tests pass
Test Fact::new is not accessible from outside crate by creating a test in tests/ directory (if exists) or doc-test that tries to call it
  </verify>
  <done>
Proposal<Draft> can be created publicly via Proposal::new().
Proposal<Validated> can only be created via pub(crate) from_validated().
Fact has private fields and pub(crate) new() constructor.
PromotionRecord is a required field on Fact (not Option).
lib.rs exports types module and re-exports key types.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p converge-core` - compiles without errors
2. `cargo test -p converge-core` - all tests pass
3. `cargo doc -p converge-core --no-deps` - documentation builds
4. Verify type-state pattern: Proposal<Draft>::new() is public, Proposal<Validated>::from_validated() is pub(crate)
5. Verify Fact invariant: Fact::new() is pub(crate), promotion_record field is not Option
</verification>

<success_criteria>
1. types/ module exists with id.rs, observation.rs, proposal.rs, fact.rs, provenance.rs
2. All ID types are newtypes with serde(transparent)
3. Observation has CaptureContext and ProviderIdentity
4. Proposal uses type-state pattern (Draft vs Validated marker types)
5. Fact has private fields, pub(crate) constructor, required PromotionRecord
6. EvidenceRef and TraceLink are typed enums (not String)
7. lib.rs re-exports types for convenience
8. All existing tests pass (backward compatibility maintained)
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-consolidation/03-01-SUMMARY.md` using the summary template.
</output>
