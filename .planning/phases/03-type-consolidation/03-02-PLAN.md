---
phase: 03-type-consolidation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - converge-platform/converge-core/src/types/intent.rs
  - converge-platform/converge-core/src/types/frame.rs
  - converge-platform/converge-core/src/types/tension.rs
  - converge-platform/converge-core/src/types/context.rs
  - converge-platform/converge-core/src/types/correction.rs
  - converge-platform/converge-core/src/types/error.rs
  - converge-platform/converge-core/src/types/mod.rs
  - converge-platform/converge-core/src/lib.rs
  - converge-platform/converge-core/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Frame type exists with typed constraints (not just String)"
    - "Tension type exists with explicit conflict pairs"
    - "Builder patterns exist for Frame, Intent, Context"
    - "CorrectionEvent enables append-only fact corrections"
    - "Error types use thiserror with structured variants"
  artifacts:
    - path: "converge-platform/converge-core/src/types/frame.rs"
      provides: "Frame with typed constraints and FrameBuilder"
      exports: ["Frame", "FrameConstraint", "ConstraintKind"]
    - path: "converge-platform/converge-core/src/types/intent.rs"
      provides: "RootIntent consolidation with IntentBuilder"
      exports: ["IntentBuilder"]
    - path: "converge-platform/converge-core/src/types/tension.rs"
      provides: "Tension with conflict pairs and Hypothesis"
      exports: ["Tension", "ConflictType", "Hypothesis"]
    - path: "converge-platform/converge-core/src/types/context.rs"
      provides: "Context builder pattern"
      exports: ["ContextBuilder"]
    - path: "converge-platform/converge-core/src/types/correction.rs"
      provides: "CorrectionEvent for append-only corrections"
      exports: ["CorrectionEvent", "CorrectionReason", "CorrectionScope"]
    - path: "converge-platform/converge-core/src/types/error.rs"
      provides: "Consolidated error types with thiserror"
      exports: ["TypeError", "PromotionError", "ValidationError"]
  key_links:
    - from: "types/frame.rs"
      to: "types/intent.rs"
      via: "linked_intent field"
      pattern: "linked_intent: Option<IntentId>"
    - from: "types/tension.rs"
      to: "types/proposal.rs"
      via: "conflict pairs"
      pattern: "left:.*Proposal.*right:.*Proposal"
    - from: "types/correction.rs"
      to: "types/id.rs"
      via: "FactId references"
      pattern: "new_fact_id: FactId"
---

<objective>
Add remaining types (Frame, Intent builders, Tension, Context), implement builder patterns for complex type construction, and consolidate error types using thiserror.

Purpose: Complete the type vocabulary with six-phase flow types (Frame, Tension) and ensure complex types have ergonomic builders while errors are structured and derive thiserror.

Output: Complete types/ module with all domain types, builder patterns, and consolidated errors. Full re-exports in lib.rs.
</objective>

<execution_context>
@~/.claude/agents/gsd-planner.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-consolidation/03-RESEARCH.md
@.planning/phases/03-type-consolidation/03-CONTEXT.md
@.planning/phases/03-type-consolidation/03-01-SUMMARY.md

# Existing types to reference
@converge-platform/converge-core/src/root_intent.rs
@converge-platform/converge-core/src/context.rs
@converge-platform/converge-core/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Frame and Tension types for six-phase flows</name>
  <files>
    converge-platform/converge-core/src/types/frame.rs
    converge-platform/converge-core/src/types/tension.rs
    converge-platform/converge-core/Cargo.toml
  </files>
  <action>
First, add typed-builder to Cargo.toml dependencies:
```toml
typed-builder = "0.20"
```

**types/frame.rs** - Frame with typed constraints and builder:
```rust
use typed_builder::TypedBuilder;
use serde::{Deserialize, Serialize};
use super::id::FactId;

/// Unique identifier for a Frame.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct FrameId(String);

impl FrameId {
    pub fn new(id: impl Into<String>) -> Self { Self(id.into()) }
    pub fn as_str(&self) -> &str { &self.0 }
}

impl std::fmt::Display for FrameId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Unique identifier for an Intent (re-export or local).
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct IntentId(String);

impl IntentId {
    pub fn new(id: impl Into<String>) -> Self { Self(id.into()) }
    pub fn as_str(&self) -> &str { &self.0 }
}

impl std::fmt::Display for IntentId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Kind of frame constraint.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ConstraintKind {
    /// Budget constraint with amount.
    Budget(u64),
    /// Time constraint with description.
    Time(String),
    /// Geographic constraint.
    Geography(String),
    /// Compliance requirement.
    Compliance(String),
    /// Resource limit.
    Resource { kind: String, limit: u64 },
    /// Custom constraint.
    Custom { key: String, value: String },
}

/// A constraint on a frame.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrameConstraint {
    pub kind: ConstraintKind,
    pub severity: ConstraintSeverity,
    pub description: Option<String>,
}

/// Severity of a constraint.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConstraintSeverity {
    /// Violation blocks progress.
    Hard,
    /// Violation is logged but doesn't block.
    Soft,
}

/// Success criterion for a frame.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Criterion {
    pub id: String,
    pub description: String,
    pub required: bool,
}

/// Frame - defines scope and constraints for a phase of reasoning.
///
/// Linked to Intent, contains constraints and success criteria.
#[derive(Debug, Clone, TypedBuilder, Serialize, Deserialize)]
pub struct Frame {
    pub id: FrameId,
    #[builder(setter(into))]
    pub scope: String,
    #[builder(default)]
    pub constraints: Vec<FrameConstraint>,
    #[builder(default)]
    pub success_criteria: Vec<Criterion>,
    #[builder(setter(into), default)]
    pub linked_intent: Option<IntentId>,
    #[builder(default)]
    pub parent_frame: Option<FrameId>,
}

// Example usage in doc comment:
// let frame = Frame::builder()
//     .id(FrameId::new("frame-1"))
//     .scope("Nordic B2B market")
//     .constraints(vec![FrameConstraint { kind: ConstraintKind::Budget(1_000_000), severity: ConstraintSeverity::Hard, description: None }])
//     .build();
```

**types/tension.rs** - Tension with conflict pairs:
```rust
use serde::{Deserialize, Serialize};
use super::id::{FactId, ProposalId, Timestamp};
use super::proposal::{Proposal, Draft};

/// Unique identifier for a Tension.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct TensionId(String);

impl TensionId {
    pub fn new(id: impl Into<String>) -> Self { Self(id.into()) }
    pub fn as_str(&self) -> &str { &self.0 }
}

impl std::fmt::Display for TensionId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Type of conflict between proposals.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConflictType {
    /// Direct contradiction (A says X, B says not-X).
    Contradiction,
    /// Resource competition (both need same limited resource).
    ResourceContention,
    /// Temporal conflict (mutually exclusive time windows).
    TemporalOverlap,
    /// Priority conflict (different prioritization).
    PriorityMismatch,
    /// Scope conflict (overlapping but different scopes).
    ScopeOverlap,
    /// Custom conflict type.
    Custom(String),
}

/// Reference to a proposal in a tension (by ID, not owned).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TensionSide {
    pub proposal_id: ProposalId,
    pub summary: String,
    pub supporting_evidence: Vec<FactId>,
}

/// Tension - explicit conflict between two proposals.
///
/// Per CONTEXT.md: `Tension { left: ProposedFact, right: ProposedFact, conflict_type }`
/// We use references (IDs) rather than owned proposals for flexibility.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tension {
    pub id: TensionId,
    pub left: TensionSide,
    pub right: TensionSide,
    pub conflict_type: ConflictType,
    pub detected_at: Timestamp,
    pub resolution: Option<TensionResolution>,
}

/// How a tension was resolved.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TensionResolution {
    pub chosen_side: ChosenSide,
    pub rationale: String,
    pub resolved_at: Timestamp,
    pub resolver: String,  // Actor who resolved
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ChosenSide {
    Left,
    Right,
    Neither,  // Both rejected
    Merged,   // Combined into new proposal
}

/// Hypothesis - exploration phase artifact.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hypothesis {
    pub id: String,
    pub claim: String,
    pub supporting_proposals: Vec<ProposalId>,
    pub confidence: f32,
    pub testable: bool,
}
```
  </action>
  <verify>
`cargo check -p converge-core` - typed-builder compiles
`grep "TypedBuilder" converge-platform/converge-core/src/types/frame.rs` - Frame uses builder
`grep "ConflictType" converge-platform/converge-core/src/types/tension.rs` - Tension has typed conflicts
  </verify>
  <done>
Frame type exists with typed ConstraintKind (not String), TypedBuilder derive.
Tension type exists with explicit TensionSide pairs and ConflictType enum.
Hypothesis type exists for exploration phase.
typed-builder added to Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CorrectionEvent and IntentBuilder</name>
  <files>
    converge-platform/converge-core/src/types/correction.rs
    converge-platform/converge-core/src/types/intent.rs
  </files>
  <action>
**types/correction.rs** - Append-only corrections per CONTEXT.md:
```rust
use serde::{Deserialize, Serialize};
use super::id::{FactId, ContentHash, Timestamp};
use super::provenance::Actor;

/// Why a correction was made.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CorrectionReason {
    /// Original data was incorrect.
    DataError,
    /// Policy changed, requiring re-evaluation.
    PolicyChange,
    /// Source retracted original claim.
    SourceRetraction,
    /// Human explicitly overrode.
    ManualOverride,
    /// System reconciliation process.
    SystemReconciliation,
}

/// Scope of the correction.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CorrectionScope {
    /// Applies globally.
    Global,
    /// Applies to specific tenant.
    Tenant(String),
    /// Applies to specific session.
    Session(String),
}

/// Event recording that one Fact supersedes another.
///
/// Facts are immutable - corrections create new Facts that supersede old ones.
/// "Current truth" = latest promoted Fact not superseded within scope.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CorrectionEvent {
    pub new_fact_id: FactId,
    pub supersedes_fact_id: FactId,
    pub reason_code: CorrectionReason,
    pub reason_text: String,
    pub scope: CorrectionScope,
    pub actor: Actor,
    pub policy_version: ContentHash,
    pub timestamp: Timestamp,
}

impl CorrectionEvent {
    /// Create a new correction event.
    pub fn new(
        new_fact_id: FactId,
        supersedes_fact_id: FactId,
        reason_code: CorrectionReason,
        reason_text: impl Into<String>,
        scope: CorrectionScope,
        actor: Actor,
        policy_version: ContentHash,
    ) -> Self {
        Self {
            new_fact_id,
            supersedes_fact_id,
            reason_code,
            reason_text: reason_text.into(),
            scope,
            actor,
            policy_version,
            timestamp: Timestamp::now(),
        }
    }
}
```

**types/intent.rs** - IntentBuilder using typed-builder:
```rust
use typed_builder::TypedBuilder;
use serde::{Deserialize, Serialize};
use super::frame::{IntentId, Criterion, ConstraintSeverity};
use super::id::Timestamp;

/// Kind of intent (what problem class).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[non_exhaustive]
pub enum TypesIntentKind {
    GrowthStrategy,
    Scheduling,
    ResourceOptimization,
    RiskAssessment,
    ContentGeneration,
    Custom,
}

/// Objective of the intent.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum TypesObjective {
    IncreaseDemand,
    MinimizeTime,
    MaximizeFeasibility,
    MinimizeCost,
    MaximizeCoverage,
    Balance(Vec<TypesObjective>),
    Custom(String),
}

/// Risk posture for the intent.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum RiskPosture {
    Conservative,
    Balanced,
    Aggressive,
}

impl Default for RiskPosture {
    fn default() -> Self { Self::Balanced }
}

/// Constraint on intent execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypesIntentConstraint {
    pub key: String,
    pub value: String,
    pub severity: ConstraintSeverity,
}

/// Execution budgets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypesBudgets {
    pub max_cycles: u32,
    pub max_facts: u32,
    pub max_tokens: Option<u64>,
    pub time_limit_ms: Option<u64>,
}

impl Default for TypesBudgets {
    fn default() -> Self {
        Self {
            max_cycles: 100,
            max_facts: 10_000,
            max_tokens: None,
            time_limit_ms: None,
        }
    }
}

/// Root Intent using builder pattern.
///
/// This is a modern version using typed-builder. The existing root_intent.rs
/// RootIntent remains for backward compatibility.
#[derive(Debug, Clone, TypedBuilder, Serialize, Deserialize)]
pub struct TypesRootIntent {
    pub id: IntentId,
    pub kind: TypesIntentKind,
    #[builder(default)]
    pub objective: Option<TypesObjective>,
    #[builder(setter(into))]
    pub request: String,  // The "job to be done"
    #[builder(default)]
    pub risk_posture: RiskPosture,
    #[builder(default)]
    pub constraints: Vec<TypesIntentConstraint>,
    #[builder(default)]
    pub success_criteria: Vec<Criterion>,
    #[builder(default)]
    pub budgets: TypesBudgets,
    #[builder(default)]
    pub created_at: Option<Timestamp>,
}

// Example usage:
// let intent = TypesRootIntent::builder()
//     .id(IntentId::new("intent-1"))
//     .kind(TypesIntentKind::GrowthStrategy)
//     .request("Find growth opportunities in Nordic B2B")
//     .objective(Some(TypesObjective::IncreaseDemand))
//     .risk_posture(RiskPosture::Balanced)
//     .build();
```
  </action>
  <verify>
`cargo check -p converge-core` - compiles
`grep "CorrectionEvent" converge-platform/converge-core/src/types/correction.rs` - exists
`grep "TypedBuilder" converge-platform/converge-core/src/types/intent.rs` - IntentBuilder exists
  </verify>
  <done>
CorrectionEvent exists with CorrectionReason enum and CorrectionScope enum.
TypesRootIntent exists with TypedBuilder derive for ergonomic construction.
All types follow CONTEXT.md specifications.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ContextBuilder, error consolidation, and finalize re-exports</name>
  <files>
    converge-platform/converge-core/src/types/context.rs
    converge-platform/converge-core/src/types/error.rs
    converge-platform/converge-core/src/types/mod.rs
    converge-platform/converge-core/src/lib.rs
  </files>
  <action>
**types/context.rs** - Context builder (new context type):
```rust
use typed_builder::TypedBuilder;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use super::id::FactId;
use super::fact::Fact;
use super::frame::IntentId;

/// Key for context entries (simplified from existing ContextKey).
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TypesContextKey(String);

impl TypesContextKey {
    pub fn new(key: impl Into<String>) -> Self { Self(key.into()) }
    pub fn as_str(&self) -> &str { &self.0 }

    // Common keys as constants
    pub fn seeds() -> Self { Self("seeds".to_string()) }
    pub fn hypotheses() -> Self { Self("hypotheses".to_string()) }
    pub fn strategies() -> Self { Self("strategies".to_string()) }
    pub fn constraints() -> Self { Self("constraints".to_string()) }
    pub fn signals() -> Self { Self("signals".to_string()) }
}

impl std::fmt::Display for TypesContextKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Builder for constructing immutable Context.
///
/// Provides fluent API for building context with facts and intent.
#[derive(Debug, Clone, Default)]
pub struct ContextBuilder {
    facts: HashMap<TypesContextKey, Vec<FactId>>,
    intent_id: Option<IntentId>,
    metadata: HashMap<String, String>,
}

impl ContextBuilder {
    pub fn new() -> Self { Self::default() }

    /// Add a fact reference to the context.
    pub fn add_fact(mut self, key: TypesContextKey, fact_id: FactId) -> Self {
        self.facts.entry(key).or_default().push(fact_id);
        self
    }

    /// Set the root intent.
    pub fn with_intent(mut self, intent_id: IntentId) -> Self {
        self.intent_id = Some(intent_id);
        self
    }

    /// Add metadata.
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    /// Build the context snapshot.
    pub fn build(self) -> TypesContextSnapshot {
        TypesContextSnapshot {
            facts: self.facts,
            intent_id: self.intent_id,
            metadata: self.metadata,
            version: 0,
        }
    }
}

/// Immutable context snapshot.
///
/// This represents a point-in-time view of context. The existing context::Context
/// remains for runtime mutation; this is for snapshot/serialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypesContextSnapshot {
    pub facts: HashMap<TypesContextKey, Vec<FactId>>,
    pub intent_id: Option<IntentId>,
    pub metadata: HashMap<String, String>,
    pub version: u64,
}

impl TypesContextSnapshot {
    /// Get fact IDs for a key.
    pub fn get(&self, key: &TypesContextKey) -> &[FactId] {
        self.facts.get(key).map_or(&[], Vec::as_slice)
    }

    /// Check if key has facts.
    pub fn has(&self, key: &TypesContextKey) -> bool {
        self.facts.get(key).is_some_and(|v| !v.is_empty())
    }
}
```

**types/error.rs** - Consolidated errors with thiserror:
```rust
use thiserror::Error;
use serde::{Deserialize, Serialize};

/// Core type system errors.
#[derive(Debug, Error)]
pub enum TypeError {
    #[error("invalid state transition: {from} -> {to}")]
    InvalidStateTransition { from: String, to: String },

    #[error("promotion invariant violated: {0}")]
    PromotionInvariant(String),

    #[error("missing required field: {field}")]
    MissingField { field: &'static str },

    #[error("validation failed: {reason}")]
    ValidationFailed { reason: String },

    #[error(transparent)]
    Serialization(#[from] serde_json::Error),
}

/// Errors during fact promotion.
#[derive(Debug, Error)]
pub enum PromotionError {
    #[error("proposal not validated: {proposal_id}")]
    NotValidated { proposal_id: String },

    #[error("validation failed: {reason}")]
    ValidationFailed { reason: String },

    #[error("gate rejected: {gate_id} - {reason}")]
    GateRejected { gate_id: String, reason: String },

    #[error("missing evidence: {0}")]
    MissingEvidence(String),

    #[error("human approval required")]
    HumanApprovalRequired,
}

/// Errors during validation.
#[derive(Debug, Error, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TypesValidationError {
    #[error("invalid confidence: {value} (must be 0.0-1.0)")]
    InvalidConfidence { value: f32 },

    #[error("empty content not allowed")]
    EmptyContent,

    #[error("missing required field: {field}")]
    MissingField { field: String },

    #[error("constraint violated: {constraint}")]
    ConstraintViolated { constraint: String },

    #[error("schema mismatch: {expected} vs {actual}")]
    SchemaMismatch { expected: String, actual: String },
}

/// Errors during observation capture.
#[derive(Debug, Error)]
pub enum ObservationError {
    #[error("invalid provider response: {0}")]
    InvalidProviderResponse(String),

    #[error("content hash mismatch")]
    ContentHashMismatch,

    #[error("capture context missing: {field}")]
    MissingCaptureContext { field: String },
}

/// Errors during correction.
#[derive(Debug, Error)]
pub enum CorrectionError {
    #[error("fact not found: {fact_id}")]
    FactNotFound { fact_id: String },

    #[error("already superseded by: {superseding_fact_id}")]
    AlreadySuperseded { superseding_fact_id: String },

    #[error("scope mismatch: correction scope {correction_scope} doesn't match fact scope")]
    ScopeMismatch { correction_scope: String },
}
```

**types/mod.rs** - Update with all new modules:
```rust
//! Core type vocabulary for Converge.
//!
//! This module contains the domain types that form Converge's type vocabulary:
//!
//! - **ID types** (id.rs): FactId, ObservationId, ProposalId, etc.
//! - **3-tier hierarchy**: Observation -> Proposal -> Fact
//! - **Provenance** (provenance.rs): PromotionRecord, EvidenceRef, TraceLink
//! - **Six-phase flow** (frame.rs, tension.rs): Frame, Tension, Hypothesis
//! - **Intent** (intent.rs): TypesRootIntent with builder
//! - **Context** (context.rs): ContextBuilder, TypesContextSnapshot
//! - **Corrections** (correction.rs): CorrectionEvent for append-only
//! - **Errors** (error.rs): TypeError, PromotionError, etc.

pub mod id;
pub mod observation;
pub mod proposal;
pub mod fact;
pub mod provenance;
pub mod frame;
pub mod tension;
pub mod intent;
pub mod context;
pub mod correction;
pub mod error;

// Re-export everything for convenience
pub use id::*;
pub use observation::*;
pub use proposal::*;
pub use fact::*;
pub use provenance::*;
pub use frame::*;
pub use tension::*;
pub use intent::*;
pub use context::*;
pub use correction::*;
pub use error::*;
```

**lib.rs** - Update re-exports to include all new types:

Add to the existing types re-export block:
```rust
// Re-export types module
pub use types::{
    // ID types
    FactId, ObservationId, ProposalId, GateId, ApprovalId, ArtifactId,
    ContentHash, Timestamp,
    // Observation types
    Observation, ObservationKind, CaptureContext, ProviderIdentity,
    // Proposal types
    Proposal, Draft, Validated, ProposedContent, ProposedContentKind, ObservationProvenance,
    // Fact types
    FactContent, FactContentKind,
    // Provenance types
    PromotionRecord, EvidenceRef, TraceLink as TypesTraceLink,
    LocalTrace, RemoteRef, Actor, ActorKind, ValidationSummary,
    // Frame types
    FrameId, Frame, FrameConstraint, ConstraintKind, Criterion,
    // Tension types
    TensionId, Tension, TensionSide, ConflictType, TensionResolution, ChosenSide, Hypothesis,
    // Intent types
    TypesIntentKind, TypesObjective, RiskPosture, TypesIntentConstraint,
    TypesBudgets, TypesRootIntent,
    // Context types
    TypesContextKey, ContextBuilder, TypesContextSnapshot,
    // Correction types
    CorrectionEvent, CorrectionReason, CorrectionScope,
    // Error types
    TypeError, PromotionError, TypesValidationError, ObservationError, CorrectionError,
};
```

Note: Some types have "Types" prefix to avoid collision with existing types. Once migration is complete in later phases, these can be renamed.
  </action>
  <verify>
`cargo check -p converge-core` - all compiles
`cargo test -p converge-core` - all tests pass
`cargo doc -p converge-core --no-deps` - docs build
`grep "thiserror" converge-platform/converge-core/src/types/error.rs` - thiserror used
  </verify>
  <done>
ContextBuilder exists for fluent context construction.
TypesContextSnapshot exists for immutable context snapshots.
All error types use thiserror derive macros.
types/mod.rs exports all modules.
lib.rs re-exports all types for convenience.
All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check -p converge-core` - compiles without errors
2. `cargo test -p converge-core` - all tests pass
3. `cargo doc -p converge-core --no-deps` - documentation builds without warnings
4. Verify typed-builder works: Frame::builder().id(...).scope(...).build() compiles
5. Verify thiserror works: TypeError variants have Display impl from derive
6. Verify all types are re-exported from lib.rs
</verification>

<success_criteria>
1. Frame type exists with typed ConstraintKind enum (not String)
2. Tension type exists with TensionSide pairs and ConflictType enum
3. CorrectionEvent exists for append-only fact corrections
4. TypesRootIntent uses TypedBuilder derive
5. ContextBuilder provides fluent construction
6. All error types in types/error.rs use #[derive(Error)] from thiserror
7. types/mod.rs exports all submodules
8. lib.rs re-exports all types (with Types prefix where needed for collision avoidance)
9. All existing tests pass (backward compatibility)
10. typed-builder is in Cargo.toml dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-consolidation/03-02-SUMMARY.md` using the summary template.
</output>
