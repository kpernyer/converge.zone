---
phase: 06-testing-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - converge-platform/converge-core/tests/common/mod.rs
  - converge-platform/converge-core/tests/common/ids.rs
  - converge-platform/converge-core/tests/common/time.rs
  - converge-platform/converge-core/tests/common/normalize.rs
  - converge-platform/converge-core/tests/common/harness.rs
  - converge-platform/converge-core/tests/common/strategies.rs
  - converge-platform/converge-core/tests/common/replay.rs
autonomous: true

must_haves:
  truths:
    - "All test helpers compile and are importable from tests/common"
    - "Proptest strategies generate valid instances of all core types"
    - "FrozenClock produces deterministic timestamps"
    - "DeterministicIdGenerator produces repeatable sequences"
    - "JSON normalizer handles dynamic fields (timestamps, IDs)"
  artifacts:
    - path: "converge-platform/converge-core/tests/common/mod.rs"
      provides: "Re-exports all test helpers"
      contains: "pub mod"
    - path: "converge-platform/converge-core/tests/common/strategies.rs"
      provides: "Proptest strategies for all types"
      min_lines: 150
    - path: "converge-platform/converge-core/tests/common/harness.rs"
      provides: "In-memory test harness for gates"
      contains: "TestHarness"
    - path: "converge-platform/converge-core/tests/common/time.rs"
      provides: "Frozen clock for deterministic tests"
      contains: "FrozenClock"
    - path: "converge-platform/converge-core/tests/common/ids.rs"
      provides: "Deterministic ID generator"
      contains: "DeterministicIdGenerator"
  key_links:
    - from: "tests/common/strategies.rs"
      to: "converge_core::types"
      via: "use statements importing core types"
      pattern: "use converge_core::types::"
    - from: "tests/common/harness.rs"
      to: "converge_core::gates"
      via: "gate type imports"
      pattern: "use converge_core::gates::"
---

<objective>
Create the test harness infrastructure for Phase 6 testing. This plan builds the foundation that all other test plans depend on: proptest strategies for every type, frozen clock/deterministic ID helpers, JSON normalization for snapshots, and an in-memory gate harness.

Purpose: Without shared test infrastructure, each test file would duplicate strategy definitions and helper code. Centralizing in tests/common/ ensures consistency and reduces maintenance burden.

Output: tests/common/ module with all helpers needed by property tests, snapshot tests, and determinism verification.
</objective>

<execution_context>
@/Users/kpernyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kpernyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-testing-infrastructure/06-RESEARCH.md

# Source files to reference for type definitions
@converge-platform/converge-core/src/types/mod.rs
@converge-platform/converge-core/src/types/id.rs
@converge-platform/converge-core/src/types/provenance.rs
@converge-platform/converge-core/src/types/proposal.rs
@converge-platform/converge-core/src/types/fact.rs
@converge-platform/converge-core/src/types/observation.rs
@converge-platform/converge-core/src/types/correction.rs
@converge-platform/converge-core/src/gates/mod.rs
@converge-platform/converge-core/src/gates/budget.rs
@converge-platform/converge-core/src/gates/stop.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure directory and core helpers</name>
  <files>
    converge-platform/converge-core/tests/common/mod.rs
    converge-platform/converge-core/tests/common/ids.rs
    converge-platform/converge-core/tests/common/time.rs
    converge-platform/converge-core/tests/common/normalize.rs
  </files>
  <action>
Create the tests/common/ directory structure with these files:

**mod.rs**: Re-export all submodules
```rust
pub mod ids;
pub mod time;
pub mod normalize;
pub mod harness;
pub mod strategies;
pub mod replay;
```

**ids.rs**: Deterministic ID generator
- `DeterministicIdGenerator` struct with atomic counter and prefix
- Methods: `new(prefix: &str)`, `next_fact_id()`, `next_observation_id()`, `next_proposal_id()`, `next_gate_id()`, `next_approval_id()`, `next_artifact_id()`
- Thread-safe via AtomicU64
- IDs formatted as `{prefix}-{counter:06}` (e.g., "test-000001")

**time.rs**: Frozen clock for deterministic timestamps
- `FrozenClock` struct with AtomicU64 for unix seconds
- Methods: `new(initial_unix_secs: u64)`, `now() -> Timestamp`, `tick(seconds: u64)`, `reset(unix_secs: u64)`
- `now()` returns ISO-8601 formatted timestamp from internal counter
- Thread-safe via AtomicU64

**normalize.rs**: JSON normalization for snapshot stability
- `IdNormalizer` struct with HashMaps for fact_ids, timestamps, observation_ids, etc.
- Method: `normalize_json(&mut self, value: &mut serde_json::Value)`
- Recursively traverse JSON, replace dynamic values with placeholders
- Format: `"<FACT_ID:1>"`, `"<TIMESTAMP:1>"`, etc.
- Preserves structure while making snapshots deterministic

Use copyright header from existing source files. All helpers must be `pub` for test access.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo check --tests 2>&1 | head -50
```
Files exist and compile without errors.
  </verify>
  <done>
- tests/common/mod.rs exists with all module declarations
- DeterministicIdGenerator generates sequential IDs
- FrozenClock produces stable timestamps
- IdNormalizer can normalize JSON values
  </done>
</task>

<task type="auto">
  <name>Task 2: Create proptest strategies for all types</name>
  <files>
    converge-platform/converge-core/tests/common/strategies.rs
  </files>
  <action>
Create comprehensive proptest strategies following 06-RESEARCH.md specifications:

**ID Type Strategies:**
- `arb_fact_id()`, `arb_observation_id()`, `arb_proposal_id()`, `arb_gate_id()`, `arb_approval_id()`, `arb_artifact_id()`
- Pattern: `"[a-z][a-z0-9_-]{0,31}".prop_map(TypeName::new)`
- `arb_content_hash()`: 32-byte array via `prop::collection::vec(any::<u8>(), 32..=32)`
- `arb_timestamp()`: Generate valid ISO-8601 dates (1970-2100 range)

**Content Strategies:**
- `arb_proposed_content_kind()`: `prop_oneof!` for all ProposedContentKind variants
- `arb_proposed_content()`: Combine kind, content string (1-200 chars), optional confidence (0.0-1.0)
- `arb_fact_content_kind()`: Similar for FactContentKind
- `arb_fact_content()`: For FactContent type

**Provenance Strategies:**
- `arb_evidence_ref()`: `prop_oneof!` for observation/human_approval/derived variants
- `arb_local_trace()`: trace_id (hex), span_id, optional parent, sampled flag
- `arb_remote_ref()`: system name + reference URL
- `arb_trace_link()`: `prop_oneof![local, remote]`
- `arb_actor()`, `arb_actor_kind()`: Actor type with Human/Agent/System variants
- `arb_validation_summary()`: checks passed/skipped/warnings lists

**Budget Strategies:**
- `arb_cycle_budget()`: 1-1000 range
- `arb_fact_budget()`: 1-100_000 range
- `arb_token_budget()`: 1-10_000_000 range
- `arb_execution_budget()`: Combine budgets with optional token budget

**Stop Reason Strategy:**
- `arb_stop_reason()`: `prop_oneof!` for all StopReason variants including Converged, CriteriaMet, UserCancelled, budget exhaustion variants

**Composite Strategies:**
- `arb_promotion_record()`: Combine gate_id, approver, evidence, trace, validation, timestamp
- `arb_observation()`: Full Observation with kind, content, provenance
- `arb_correction_event()`: new_fact_id, supersedes, reason, scope, actor, timestamp, evidence

Use `impl Strategy<Value = T>` return types. Import from converge_core::types and converge_core::gates.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo check --tests 2>&1 | head -50
```
All strategies compile and are importable.
  </verify>
  <done>
- strategies.rs contains 15+ strategy functions
- All core types have corresponding strategies
- Strategies use proper proptest patterns (prop_oneof!, prop_map, etc.)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test harness and replay infrastructure</name>
  <files>
    converge-platform/converge-core/tests/common/harness.rs
    converge-platform/converge-core/tests/common/replay.rs
  </files>
  <action>
**harness.rs**: In-memory test harness for gate testing
```rust
pub struct TestHarness {
    pub clock: FrozenClock,
    pub ids: DeterministicIdGenerator,
    drafts: HashMap<ProposalId, Proposal<Draft>>,
    validated: HashMap<ProposalId, Proposal<Validated>>,
    facts: Vec<Fact>,
    // Internal PromotionGate instance
}

impl TestHarness {
    pub fn new() -> Self
    pub fn with_clock(clock: FrozenClock) -> Self
    pub fn create_draft(&mut self, content: ProposedContent) -> ProposalId
    pub fn validate(&mut self, id: &ProposalId) -> Result<(), ValidationError>
    pub fn promote(&mut self, id: &ProposalId) -> Result<FactId, PromotionError>
    pub fn try_promote_unvalidated(&self, id: &ProposalId) -> Result<FactId, PromotionError>
    pub fn get_fact(&self, id: &FactId) -> Option<&Fact>
    pub fn fact_count(&self) -> usize
    pub fn get_all_facts(&self) -> &[Fact]
}
```
Note: The harness internally uses the PromotionGate. `try_promote_unvalidated` attempts to bypass validation (should always fail).

**replay.rs**: Record/replay infrastructure for determinism tests
```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ScenarioInput {
    pub draft_proposal: serde_json::Value,
    pub gate_id: String,
    pub policy: serde_json::Value,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ScenarioOutput {
    pub fact: Option<serde_json::Value>,
    pub error: Option<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GoldenScenario {
    pub name: String,
    pub input: ScenarioInput,
    pub expected_output: ScenarioOutput,
}

pub struct ReplayRunner {
    harness: TestHarness,
}

impl ReplayRunner {
    pub fn new() -> Self
    pub fn run_scenario(&mut self, scenario: &GoldenScenario) -> ScenarioOutput
    pub fn verify_determinism(&mut self, scenario: &GoldenScenario) -> bool
}

pub fn load_golden_scenario(path: &Path) -> Result<GoldenScenario, std::io::Error>
```
Use serde_json for scenario file parsing. Scenarios stored as JSON files in tests/golden/.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo check --tests 2>&1 | head -50
```
Harness and replay infrastructure compile without errors.
  </verify>
  <done>
- TestHarness provides complete gate testing API
- ReplayRunner can load and execute golden scenarios
- All structures derive necessary traits (Clone, Debug, Serialize, Deserialize where needed)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test --no-run 2>&1 | tail -20
```
All test code compiles. No runtime verification needed for infrastructure.
</verification>

<success_criteria>
- [ ] tests/common/ directory exists with 6 files (mod.rs, ids.rs, time.rs, normalize.rs, harness.rs, strategies.rs, replay.rs)
- [ ] `cargo check --tests` passes with no errors
- [ ] All proptest strategies are defined for P0 and P1 types
- [ ] FrozenClock and DeterministicIdGenerator are thread-safe
- [ ] TestHarness wraps PromotionGate with convenient API
- [ ] ReplayRunner can load JSON scenario files
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-infrastructure/06-01-SUMMARY.md`
</output>
