---
phase: 06-testing-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - converge-platform/converge-core/tests/gates/mod.rs
  - converge-platform/converge-core/tests/gates/promotion_proptest.rs
  - converge-platform/converge-core/tests/gates/append_only_proptest.rs
  - converge-platform/converge-core/tests/gates/budget_exhaustion_proptest.rs
  - converge-platform/converge-core/tests/types/id_timestamp_ordering_proptest.rs
autonomous: true

must_haves:
  truths:
    - "Property tests prove: cannot promote Proposal<Draft> without validation"
    - "Property tests prove: Facts have no &mut methods (append-only)"
    - "Property tests prove: Budget exhaustion returns StopReason"
    - "Property tests prove: ID ordering is consistent with timestamp ordering"
  artifacts:
    - path: "converge-platform/converge-core/tests/gates/promotion_proptest.rs"
      provides: "No-promotion-without-validation invariant tests"
      contains: "proptest!"
    - path: "converge-platform/converge-core/tests/gates/append_only_proptest.rs"
      provides: "Facts-are-append-only invariant tests"
      contains: "proptest!"
    - path: "converge-platform/converge-core/tests/gates/budget_exhaustion_proptest.rs"
      provides: "Budget exhaustion returns StopReason tests"
      contains: "proptest!"
    - path: "converge-platform/converge-core/tests/types/id_timestamp_ordering_proptest.rs"
      provides: "ID timestamp ordering consistency tests"
      contains: "proptest!"
  key_links:
    - from: "tests/gates/promotion_proptest.rs"
      to: "tests/common/harness.rs"
      via: "TestHarness import"
      pattern: "use crate::common::harness::TestHarness"
    - from: "tests/gates/budget_exhaustion_proptest.rs"
      to: "converge_core::gates::ExecutionBudget"
      via: "budget type import"
      pattern: "use converge_core::gates::"
---

<objective>
Implement proptest invariant tests for the three core gate invariants plus type ordering. These tests use generated inputs to prove invariants hold across all valid inputs, not just hand-picked examples.

Purpose: Property-based tests catch edge cases that unit tests miss. They prove invariants hold universally, not just for a few examples.

Output: tests/gates/ and tests/types/ with proptest tests covering all gate invariants.
</objective>

<execution_context>
@/Users/kpernyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kpernyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-testing-infrastructure/06-RESEARCH.md
@.planning/phases/06-testing-infrastructure/06-01-SUMMARY.md

# Test infrastructure from Plan 01
@converge-platform/converge-core/tests/common/strategies.rs
@converge-platform/converge-core/tests/common/harness.rs

# Source files for gate behavior
@converge-platform/converge-core/src/gates/promotion.rs
@converge-platform/converge-core/src/gates/validation.rs
@converge-platform/converge-core/src/gates/budget.rs
@converge-platform/converge-core/src/gates/stop.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create promotion invariant proptest</name>
  <files>
    converge-platform/converge-core/tests/gates/mod.rs
    converge-platform/converge-core/tests/gates/promotion_proptest.rs
  </files>
  <action>
**mod.rs**: Module declarations for gates tests
```rust
mod promotion_proptest;
mod append_only_proptest;
mod budget_exhaustion_proptest;
```

**promotion_proptest.rs**: Test "no promotion without validation" invariant

Two test approaches per 06-RESEARCH.md:

1. **Single-call boundary test**: Generate arbitrary Proposal<Draft>, attempt direct promotion, assert failure
```rust
proptest! {
    #[test]
    fn cannot_promote_draft_directly(content in arb_proposed_content()) {
        let mut harness = TestHarness::new();
        let id = harness.create_draft(content);

        // Attempting to promote without validation MUST fail
        let result = harness.try_promote_unvalidated(&id);
        prop_assert!(result.is_err());
    }
}
```

2. **Sequence/state-machine test**: Generate sequence of operations, verify invariant holds throughout
```rust
#[derive(Clone, Debug)]
enum GateOp {
    CreateDraft(ProposedContent),
    ValidateDraft(usize), // index into drafts
    TryPromoteWithoutValidation(usize),
    PromoteValidated(usize),
}

fn arb_gate_op() -> impl Strategy<Value = GateOp> {
    prop_oneof![
        arb_proposed_content().prop_map(GateOp::CreateDraft),
        (0usize..10).prop_map(GateOp::ValidateDraft),
        (0usize..10).prop_map(GateOp::TryPromoteWithoutValidation),
        (0usize..10).prop_map(GateOp::PromoteValidated),
    ]
}

proptest! {
    #[test]
    fn gate_sequence_maintains_invariant(ops in prop::collection::vec(arb_gate_op(), 1..50)) {
        let mut harness = TestHarness::new();
        let mut draft_ids: Vec<ProposalId> = vec![];
        let mut validated_ids: Vec<ProposalId> = vec![];

        for op in ops {
            match op {
                GateOp::CreateDraft(content) => {
                    let id = harness.create_draft(content);
                    draft_ids.push(id);
                }
                GateOp::ValidateDraft(idx) => {
                    if let Some(id) = draft_ids.get(idx % draft_ids.len().max(1)) {
                        if harness.validate(id).is_ok() {
                            validated_ids.push(id.clone());
                        }
                    }
                }
                GateOp::TryPromoteWithoutValidation(idx) => {
                    if let Some(id) = draft_ids.get(idx % draft_ids.len().max(1)) {
                        // This MUST always fail - the invariant
                        prop_assert!(harness.try_promote_unvalidated(id).is_err());
                    }
                }
                GateOp::PromoteValidated(idx) => {
                    if let Some(id) = validated_ids.get(idx % validated_ids.len().max(1)) {
                        // This may succeed (valid path)
                        let _ = harness.promote(id);
                    }
                }
            }
        }
    }
}
```

3. **Happy path test**: Validate then promote succeeds
```rust
proptest! {
    #[test]
    fn validate_then_promote_succeeds(content in arb_proposed_content()) {
        let mut harness = TestHarness::new();
        let id = harness.create_draft(content);

        // Valid path: validate first
        prop_assert!(harness.validate(&id).is_ok());

        // Then promotion succeeds
        let fact_id = harness.promote(&id);
        prop_assert!(fact_id.is_ok());
    }
}
```

Use proptest config: `ProptestConfig { cases: 256, ..Default::default() }` for sequence tests (shorter but more cases).
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test gates::promotion_proptest --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- promotion_proptest.rs has 3+ proptest functions
- Single-call and sequence tests both verify the invariant
- Happy path test confirms valid flow works
  </done>
</task>

<task type="auto">
  <name>Task 2: Create append-only and budget exhaustion proptests</name>
  <files>
    converge-platform/converge-core/tests/gates/append_only_proptest.rs
    converge-platform/converge-core/tests/gates/budget_exhaustion_proptest.rs
  </files>
  <action>
**append_only_proptest.rs**: Test "facts are append-only" invariant

Tests per 06-RESEARCH.md:
1. **API immutability**: Fact has no `&mut self` methods - this is a compile-time guarantee, but we test that all accessors return immutable references
2. **Correction semantics**: Corrections create NEW facts, don't modify existing

```rust
proptest! {
    #[test]
    fn fact_accessors_are_immutable(
        content in arb_proposed_content(),
    ) {
        let mut harness = TestHarness::new();
        let id = harness.create_draft(content);
        harness.validate(&id).unwrap();
        let fact_id = harness.promote(&id).unwrap();

        let fact = harness.get_fact(&fact_id).unwrap();

        // All accessors return owned or immutable data
        let _id: &FactId = fact.id();
        let _content: &FactContent = fact.content();
        let _record: &PromotionRecord = fact.promotion_record();
        let _ts: &Timestamp = fact.created_at();

        // No &mut methods exist - compile-time guarantee
        // This test documents the immutability contract
        prop_assert!(true);
    }

    #[test]
    fn correction_creates_new_fact_not_mutation(
        content in arb_proposed_content(),
        reason in arb_correction_reason(),
    ) {
        let mut harness = TestHarness::new();

        // Create original fact
        let id1 = harness.create_draft(content.clone());
        harness.validate(&id1).unwrap();
        let fact_id1 = harness.promote(&id1).unwrap();
        let original_count = harness.fact_count();

        // Create correction (new fact that supersedes)
        let id2 = harness.create_draft(content);
        harness.validate(&id2).unwrap();
        let fact_id2 = harness.promote(&id2).unwrap();

        // Correction creates a NEW fact
        prop_assert_eq!(harness.fact_count(), original_count + 1);

        // Original fact still exists, unchanged
        let original = harness.get_fact(&fact_id1).unwrap();
        let correction = harness.get_fact(&fact_id2).unwrap();

        prop_assert_ne!(original.id(), correction.id());
    }
}
```

**budget_exhaustion_proptest.rs**: Test "budget exhaustion returns StopReason"

```rust
proptest! {
    #[test]
    fn cycle_budget_exhaustion_returns_stop_reason(
        initial in 1u32..100,
        ticks in 0u32..200,
    ) {
        let mut budget = CycleBudget::new(initial);

        for _ in 0..ticks {
            if let Some(reason) = budget.tick() {
                // When exhausted, we get a StopReason
                match reason {
                    StopReason::CycleBudgetExhausted { executed, limit } => {
                        prop_assert_eq!(limit, initial);
                        prop_assert!(executed >= initial);
                    }
                    _ => prop_assert!(false, "Expected CycleBudgetExhausted"),
                }
                return Ok(());
            }
        }

        // If we didn't exhaust, remaining should be positive
        prop_assert!(budget.remaining() > 0 || ticks < initial);
    }

    #[test]
    fn fact_budget_exhaustion_returns_stop_reason(
        initial in 1u32..1000,
        facts_to_add in 0u32..2000,
    ) {
        let mut budget = FactBudget::new(initial);

        for _ in 0..facts_to_add {
            if let Some(reason) = budget.record_fact() {
                match reason {
                    StopReason::FactBudgetExhausted { count, limit } => {
                        prop_assert_eq!(limit, initial);
                        prop_assert!(count >= initial);
                    }
                    _ => prop_assert!(false, "Expected FactBudgetExhausted"),
                }
                return Ok(());
            }
        }

        prop_assert!(budget.remaining() > 0 || facts_to_add < initial);
    }

    #[test]
    fn token_budget_exhaustion_returns_stop_reason(
        initial in 1u64..10000,
        tokens_to_consume in prop::collection::vec(1u64..100, 0..200),
    ) {
        let mut budget = TokenBudget::new(initial);

        for tokens in tokens_to_consume {
            if let Some(reason) = budget.consume(tokens) {
                match reason {
                    StopReason::TokenBudgetExhausted { consumed, limit } => {
                        prop_assert_eq!(limit, initial);
                        prop_assert!(consumed >= initial);
                    }
                    _ => prop_assert!(false, "Expected TokenBudgetExhausted"),
                }
                return Ok(());
            }
        }

        // Either we didn't exhaust or remaining is positive
        prop_assert!(budget.remaining() > 0);
    }

    #[test]
    fn execution_budget_tracks_all_resources(
        cycles in 1u32..50,
        facts in 1u32..100,
        tokens in prop::option::of(1u64..1000),
    ) {
        let mut budget = ExecutionBudget::new(cycles, facts);
        if let Some(t) = tokens {
            budget = budget.with_tokens(t);
        }

        // Initial state
        prop_assert_eq!(budget.cycles().remaining(), cycles);
        prop_assert_eq!(budget.facts().remaining(), facts);

        // Tick should decrement
        let _ = budget.tick();
        prop_assert!(budget.cycles().remaining() < cycles || cycles == 0);
    }
}
```
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test gates:: --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- append_only_proptest.rs tests immutability contract
- budget_exhaustion_proptest.rs tests all budget types
- All tests verify invariants with generated inputs
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ID timestamp ordering proptest</name>
  <files>
    converge-platform/converge-core/tests/types/mod.rs
    converge-platform/converge-core/tests/types/id_timestamp_ordering_proptest.rs
  </files>
  <action>
**tests/types/mod.rs**: Module declarations
```rust
mod id_timestamp_ordering_proptest;
```

**id_timestamp_ordering_proptest.rs**: Test ID and timestamp ordering consistency

```rust
use proptest::prelude::*;
use converge_core::types::{FactId, Timestamp};
use crate::common::time::FrozenClock;
use crate::common::ids::DeterministicIdGenerator;

proptest! {
    /// IDs generated in sequence have consistent ordering with timestamps
    #[test]
    fn sequential_ids_match_timestamp_order(count in 1usize..100) {
        let clock = FrozenClock::new(1700000000); // Fixed start time
        let ids = DeterministicIdGenerator::new("test");

        let mut pairs: Vec<(FactId, Timestamp)> = vec![];

        for _ in 0..count {
            let id = ids.next_fact_id();
            let ts = clock.now();
            pairs.push((id, ts));
            clock.tick(1); // Advance time
        }

        // IDs should be in lexicographic order (due to counter)
        for window in pairs.windows(2) {
            let (id1, ts1) = &window[0];
            let (id2, ts2) = &window[1];

            // Later ID should be "greater" (lexicographic on padded counter)
            prop_assert!(id1.as_str() < id2.as_str());

            // Later timestamp should be "greater"
            prop_assert!(ts1.as_str() < ts2.as_str());
        }
    }

    /// Timestamps are totally ordered (ISO-8601 lexicographic = chronological)
    #[test]
    fn timestamps_are_lexicographically_chronological(
        base_secs in 0u64..2000000000,
        offsets in prop::collection::vec(0u64..1000, 2..20),
    ) {
        let clock = FrozenClock::new(base_secs);
        let mut timestamps: Vec<(u64, Timestamp)> = vec![];

        let mut current_offset = 0u64;
        for delta in offsets {
            current_offset += delta;
            clock.reset(base_secs + current_offset);
            timestamps.push((base_secs + current_offset, clock.now()));
        }

        // Sort by string (lexicographic)
        let mut by_string = timestamps.clone();
        by_string.sort_by(|a, b| a.1.as_str().cmp(b.1.as_str()));

        // Sort by numeric (chronological)
        let mut by_numeric = timestamps.clone();
        by_numeric.sort_by_key(|t| t.0);

        // They should be the same order
        for (a, b) in by_string.iter().zip(by_numeric.iter()) {
            prop_assert_eq!(a.0, b.0);
        }
    }

    /// Content hash ordering is deterministic
    #[test]
    fn content_hash_ordering_is_deterministic(
        bytes1 in prop::collection::vec(any::<u8>(), 32),
        bytes2 in prop::collection::vec(any::<u8>(), 32),
    ) {
        use converge_core::types::ContentHash;

        let hash1 = ContentHash::new(bytes1.clone().try_into().unwrap());
        let hash2 = ContentHash::new(bytes2.clone().try_into().unwrap());

        // Re-create from same bytes
        let hash1_copy = ContentHash::new(bytes1.try_into().unwrap());
        let hash2_copy = ContentHash::new(bytes2.try_into().unwrap());

        // Same bytes = same hash
        prop_assert_eq!(hash1.as_hex(), hash1_copy.as_hex());
        prop_assert_eq!(hash2.as_hex(), hash2_copy.as_hex());

        // Ordering is consistent
        let cmp1 = hash1.as_hex().cmp(&hash2.as_hex());
        let cmp2 = hash1_copy.as_hex().cmp(&hash2_copy.as_hex());
        prop_assert_eq!(cmp1, cmp2);
    }
}
```
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test types::id_timestamp_ordering_proptest --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- id_timestamp_ordering_proptest.rs tests ordering consistency
- Tests verify deterministic ID generator and frozen clock work together
- Content hash ordering is deterministic
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test gates:: types::id_timestamp 2>&1 | tail -30
```
All property tests pass.
</verification>

<success_criteria>
- [ ] tests/gates/ contains promotion_proptest.rs, append_only_proptest.rs, budget_exhaustion_proptest.rs
- [ ] tests/types/ contains id_timestamp_ordering_proptest.rs
- [ ] "No promotion without validation" tested with single-call and sequence approaches
- [ ] "Facts are append-only" tested via accessor immutability and correction semantics
- [ ] Budget exhaustion tested for all budget types
- [ ] All proptest tests pass: `cargo test --test gates --test types`
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-infrastructure/06-02-SUMMARY.md`
</output>
