---
phase: 06-testing-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - converge-platform/converge-core/tests/gates/determinism_replay.rs
  - converge-platform/converge-core/tests/golden/promotion_happy_path.json
  - converge-platform/converge-core/tests/golden/correction_supersedes.json
  - converge-platform/converge-core/tests/golden/tracelink_local_vs_remote.json
autonomous: true

must_haves:
  truths:
    - "Replayability honesty is verified: same inputs produce same outputs"
    - "TraceLink::Local is replay-eligible, TraceLink::Remote is not"
    - "Golden scenarios verify known promotion and correction paths"
    - "Determinism harness uses frozen clock and deterministic IDs"
  artifacts:
    - path: "converge-platform/converge-core/tests/gates/determinism_replay.rs"
      provides: "Determinism verification tests"
      contains: "ReplayRunner"
    - path: "converge-platform/converge-core/tests/golden/promotion_happy_path.json"
      provides: "Golden scenario for successful promotion"
      contains: "expected_output"
    - path: "converge-platform/converge-core/tests/golden/tracelink_local_vs_remote.json"
      provides: "Golden scenario for TraceLink separation"
      contains: "local_is_replay_eligible"
  key_links:
    - from: "tests/gates/determinism_replay.rs"
      to: "tests/common/replay.rs"
      via: "ReplayRunner import"
      pattern: "use crate::common::replay::ReplayRunner"
    - from: "tests/gates/determinism_replay.rs"
      to: "tests/golden/*.json"
      via: "load_golden_scenario"
      pattern: "load_golden_scenario"
---

<objective>
Implement determinism verification tests using golden scenarios and the replay harness. These tests prove that the system tells the truth about determinism (replayability honesty) - TraceLink::Local means deterministically replayable, and same inputs always produce same outputs.

Purpose: Determinism guarantees are critical for debugging and auditing. This plan verifies those guarantees hold via reproducible golden scenarios.

Output: tests/gates/determinism_replay.rs with replay tests, tests/golden/ with scenario JSON files.
</objective>

<execution_context>
@/Users/kpernyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kpernyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-testing-infrastructure/06-RESEARCH.md
@.planning/phases/06-testing-infrastructure/06-01-SUMMARY.md
@.planning/phases/06-testing-infrastructure/06-02-SUMMARY.md

# Replay infrastructure from Plan 01
@converge-platform/converge-core/tests/common/replay.rs
@converge-platform/converge-core/tests/common/harness.rs

# Types for TraceLink testing
@converge-platform/converge-core/src/types/provenance.rs
@converge-platform/converge-core/src/kernel_boundary.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create golden scenario files</name>
  <files>
    converge-platform/converge-core/tests/golden/promotion_happy_path.json
    converge-platform/converge-core/tests/golden/correction_supersedes.json
    converge-platform/converge-core/tests/golden/tracelink_local_vs_remote.json
  </files>
  <action>
Create tests/golden/ directory and golden scenario files per 06-RESEARCH.md:

```bash
mkdir -p converge-platform/converge-core/tests/golden
```

**promotion_happy_path.json**: Golden scenario for successful promotion flow

```json
{
  "name": "promotion_happy_path",
  "description": "Verify that a valid draft proposal can be validated and promoted to a fact",
  "frozen_clock_start": 1700000000,
  "id_generator_prefix": "golden",
  "input": {
    "draft_proposal": {
      "content": {
        "kind": "Claim",
        "content": "Test claim for golden scenario"
      }
    },
    "gate_id": "golden-gate-001",
    "policy": {
      "required_checks": ["content_not_empty"]
    }
  },
  "expected_output": {
    "success": true,
    "fact": {
      "content": {
        "kind": "Claim",
        "content": "Test claim for golden scenario"
      },
      "promotion_record": {
        "gate_id": "golden-gate-001"
      }
    },
    "error": null
  },
  "assertions": {
    "fact_created": true,
    "promotion_record_present": true,
    "content_matches_input": true
  }
}
```

**correction_supersedes.json**: Golden scenario for correction creating new fact

```json
{
  "name": "correction_supersedes",
  "description": "Verify that corrections create new facts that supersede old ones",
  "frozen_clock_start": 1700000000,
  "id_generator_prefix": "correction",
  "input": {
    "original_fact": {
      "content": {
        "kind": "Claim",
        "content": "Original claim with error"
      }
    },
    "correction": {
      "content": {
        "kind": "Claim",
        "content": "Corrected claim"
      },
      "reason": "DataError",
      "scope": "SingleFact",
      "actor": {
        "id": "admin",
        "kind": "Human"
      }
    }
  },
  "expected_output": {
    "success": true,
    "correction_event": {
      "reason_code": "DataError",
      "scope": "SingleFact"
    },
    "facts_count": 2,
    "original_exists": true,
    "corrected_exists": true
  },
  "assertions": {
    "two_facts_exist": true,
    "original_not_modified": true,
    "correction_has_supersedes_link": true
  }
}
```

**tracelink_local_vs_remote.json**: Golden scenario for TraceLink separation

```json
{
  "name": "tracelink_local_vs_remote",
  "description": "Verify TraceLink::Local is replay-eligible, TraceLink::Remote is not",
  "traces": {
    "local_trace": {
      "type": "Local",
      "trace_id": "abc123def456789012345678901234",
      "span_id": "span0001",
      "parent_span_id": null,
      "sampled": true
    },
    "remote_trace": {
      "type": "Remote",
      "system": "datadog",
      "reference": "https://app.datadoghq.com/apm/trace/abc123"
    }
  },
  "expected_properties": {
    "local_is_replay_eligible": true,
    "remote_is_replay_eligible": false,
    "local_has_trace_id": true,
    "local_has_span_id": true,
    "remote_has_system": true,
    "remote_has_reference": true
  },
  "assertions": {
    "local_replayability": "Deterministic",
    "remote_replayability": "NotDeterministic"
  }
}
```
  </action>
  <verify>
```bash
ls -la /Users/kpernyer/repo/converge.zone/converge-platform/converge-core/tests/golden/
```
Golden scenario files exist.
  </verify>
  <done>
- tests/golden/ directory exists
- promotion_happy_path.json defines successful promotion scenario
- correction_supersedes.json defines correction scenario
- tracelink_local_vs_remote.json defines TraceLink separation scenario
  </done>
</task>

<task type="auto">
  <name>Task 2: Create determinism replay tests</name>
  <files>
    converge-platform/converge-core/tests/gates/determinism_replay.rs
  </files>
  <action>
Update tests/gates/mod.rs to include determinism_replay:
```rust
mod promotion_proptest;
mod append_only_proptest;
mod budget_exhaustion_proptest;
mod determinism_replay;
```

**determinism_replay.rs**: Determinism verification tests

```rust
//! Determinism verification tests.
//!
//! These tests verify "replayability honesty" - that the system tells the
//! truth about what can and cannot be deterministically replayed.

use std::path::Path;
use converge_core::types::{TraceLink, LocalTrace, RemoteRef};
use converge_core::kernel_boundary::{
    TraceLink as KernelTraceLink,
    LocalTraceLink, RemoteTraceLink, Replayability,
};
use crate::common::replay::{ReplayRunner, GoldenScenario, load_golden_scenario};
use crate::common::harness::TestHarness;
use crate::common::time::FrozenClock;
use crate::common::ids::DeterministicIdGenerator;

// =============================================================================
// TRACELINK REPLAY ELIGIBILITY TESTS
// =============================================================================

#[test]
fn local_trace_is_replay_eligible() {
    let trace = TraceLink::local(LocalTrace::new("trace123", "span456"));

    // Local traces are always replay-eligible (deterministic)
    assert!(trace.is_local(), "Local trace should be classified as local");
    // If TraceLink has is_replay_eligible() method:
    // assert!(trace.is_replay_eligible());
}

#[test]
fn remote_trace_is_not_replay_eligible() {
    let trace = TraceLink::remote(RemoteRef::new("datadog", "https://..."));

    // Remote traces are NOT replay-eligible (external system)
    assert!(trace.is_remote(), "Remote trace should be classified as remote");
    // If TraceLink has is_replay_eligible() method:
    // assert!(!trace.is_replay_eligible());
}

#[test]
fn kernel_local_trace_replayability() {
    let trace = KernelTraceLink::Local(LocalTraceLink {
        trace_id: "kernel-trace".into(),
        span_id: "kernel-span".into(),
        parent_span_id: None,
        sampled: true,
    });

    match trace {
        KernelTraceLink::Local(_) => {
            // Local traces have implicit Deterministic replayability
            assert!(true);
        }
        _ => panic!("Expected Local trace"),
    }
}

#[test]
fn kernel_remote_trace_explicit_replayability() {
    let not_deterministic = KernelTraceLink::Remote(RemoteTraceLink {
        system: "external".into(),
        reference: "ref123".into(),
        replayability: Replayability::NotDeterministic,
    });

    match not_deterministic {
        KernelTraceLink::Remote(r) => {
            assert_eq!(r.replayability, Replayability::NotDeterministic);
        }
        _ => panic!("Expected Remote trace"),
    }

    let deterministic = KernelTraceLink::Remote(RemoteTraceLink {
        system: "cached-api".into(),
        reference: "cache-hit-123".into(),
        replayability: Replayability::Deterministic,
    });

    match deterministic {
        KernelTraceLink::Remote(r) => {
            assert_eq!(r.replayability, Replayability::Deterministic);
        }
        _ => panic!("Expected Remote trace"),
    }
}

// =============================================================================
// GOLDEN SCENARIO TESTS
// =============================================================================

fn golden_path(name: &str) -> std::path::PathBuf {
    std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("golden")
        .join(name)
}

#[test]
fn golden_tracelink_local_vs_remote() {
    let scenario_path = golden_path("tracelink_local_vs_remote.json");
    let scenario: serde_json::Value = serde_json::from_str(
        &std::fs::read_to_string(&scenario_path).expect("Failed to read golden file")
    ).expect("Failed to parse golden file");

    let expected = &scenario["expected_properties"];

    // Verify local trace properties
    let local_trace = TraceLink::local(LocalTrace::new(
        scenario["traces"]["local_trace"]["trace_id"].as_str().unwrap(),
        scenario["traces"]["local_trace"]["span_id"].as_str().unwrap(),
    ));

    assert!(local_trace.is_local());
    assert_eq!(
        expected["local_is_replay_eligible"].as_bool().unwrap(),
        true, // Local is always replay eligible
        "Local trace replay eligibility mismatch"
    );

    // Verify remote trace properties
    let remote_trace = TraceLink::remote(RemoteRef::new(
        scenario["traces"]["remote_trace"]["system"].as_str().unwrap(),
        scenario["traces"]["remote_trace"]["reference"].as_str().unwrap(),
    ));

    assert!(remote_trace.is_remote());
    assert_eq!(
        expected["remote_is_replay_eligible"].as_bool().unwrap(),
        false, // Remote is never replay eligible (by default)
        "Remote trace replay eligibility mismatch"
    );
}

// =============================================================================
// DETERMINISM PROPERTY TESTS
// =============================================================================

#[test]
fn same_inputs_produce_same_outputs() {
    // Run the same scenario twice with identical configuration
    let clock1 = FrozenClock::new(1700000000);
    let ids1 = DeterministicIdGenerator::new("replay");
    let mut harness1 = TestHarness::with_clock_and_ids(clock1, ids1);

    let clock2 = FrozenClock::new(1700000000);
    let ids2 = DeterministicIdGenerator::new("replay");
    let mut harness2 = TestHarness::with_clock_and_ids(clock2, ids2);

    use converge_core::types::{ProposedContent, ProposedContentKind};

    let content = ProposedContent::new(ProposedContentKind::Claim, "Determinism test");

    // Run identical operations
    let id1 = harness1.create_draft(content.clone());
    harness1.validate(&id1).unwrap();
    let fact_id1 = harness1.promote(&id1).unwrap();
    let fact1 = harness1.get_fact(&fact_id1).unwrap();

    let id2 = harness2.create_draft(content);
    harness2.validate(&id2).unwrap();
    let fact_id2 = harness2.promote(&id2).unwrap();
    let fact2 = harness2.get_fact(&fact_id2).unwrap();

    // Same IDs
    assert_eq!(fact1.id(), fact2.id(), "Fact IDs should match");

    // Same content
    assert_eq!(fact1.content().content(), fact2.content().content());

    // Same timestamps
    assert_eq!(fact1.created_at(), fact2.created_at());
}

#[test]
fn promotion_sequence_is_deterministic() {
    // Create multiple facts in sequence, verify deterministic ordering
    let clock = FrozenClock::new(1700000000);
    let ids = DeterministicIdGenerator::new("seq");
    let mut harness = TestHarness::with_clock_and_ids(clock, ids);

    use converge_core::types::{ProposedContent, ProposedContentKind};

    let fact_ids: Vec<_> = (0..5).map(|i| {
        let content = ProposedContent::new(
            ProposedContentKind::Claim,
            format!("Fact number {}", i)
        );
        let id = harness.create_draft(content);
        harness.validate(&id).unwrap();
        harness.clock.tick(1); // Advance time
        harness.promote(&id).unwrap()
    }).collect();

    // IDs should be in order
    for window in fact_ids.windows(2) {
        let prev = window[0].as_str();
        let next = window[1].as_str();
        assert!(prev < next, "IDs should be lexicographically ordered: {} < {}", prev, next);
    }

    // Timestamps should also be ordered
    for window in fact_ids.windows(2) {
        let fact1 = harness.get_fact(&window[0]).unwrap();
        let fact2 = harness.get_fact(&window[1]).unwrap();
        assert!(
            fact1.created_at().as_str() < fact2.created_at().as_str(),
            "Timestamps should be ordered"
        );
    }
}

// =============================================================================
// GOLDEN SCENARIO REPLAY VERIFICATION
// =============================================================================

#[test]
fn golden_promotion_happy_path() {
    let scenario_path = golden_path("promotion_happy_path.json");
    let scenario: serde_json::Value = serde_json::from_str(
        &std::fs::read_to_string(&scenario_path).expect("Failed to read golden file")
    ).expect("Failed to parse golden file");

    let clock_start = scenario["frozen_clock_start"].as_u64().unwrap();
    let prefix = scenario["id_generator_prefix"].as_str().unwrap();

    let clock = FrozenClock::new(clock_start);
    let ids = DeterministicIdGenerator::new(prefix);
    let mut harness = TestHarness::with_clock_and_ids(clock, ids);

    use converge_core::types::{ProposedContent, ProposedContentKind};

    // Execute the scenario
    let content_kind = match scenario["input"]["draft_proposal"]["content"]["kind"].as_str().unwrap() {
        "Claim" => ProposedContentKind::Claim,
        "Plan" => ProposedContentKind::Plan,
        _ => ProposedContentKind::Claim,
    };
    let content_text = scenario["input"]["draft_proposal"]["content"]["content"].as_str().unwrap();
    let content = ProposedContent::new(content_kind, content_text);

    let proposal_id = harness.create_draft(content);
    let validation_result = harness.validate(&proposal_id);
    assert!(validation_result.is_ok(), "Validation should succeed");

    let promotion_result = harness.promote(&proposal_id);
    assert!(promotion_result.is_ok(), "Promotion should succeed");

    let fact_id = promotion_result.unwrap();
    let fact = harness.get_fact(&fact_id).unwrap();

    // Verify assertions from golden file
    let assertions = &scenario["assertions"];
    assert_eq!(
        assertions["fact_created"].as_bool().unwrap(),
        true,
        "Fact should be created"
    );
    assert!(
        fact.promotion_record().gate_id().as_str().len() > 0,
        "Promotion record should be present"
    );
    assert_eq!(
        fact.content().content(),
        content_text,
        "Content should match input"
    );
}
```

Note: The exact API calls depend on how TestHarness and the types are implemented. Adjust method names (`.as_str()`, `.content()`, etc.) to match actual implementations.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test gates::determinism_replay --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- determinism_replay.rs has TraceLink replay eligibility tests
- Golden scenario loading and verification implemented
- Same-inputs-same-outputs property tested
- Promotion sequence determinism verified
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test gates::determinism_replay 2>&1 | tail -30
```
All determinism verification tests pass.
</verification>

<success_criteria>
- [ ] tests/golden/ contains 3 golden scenario JSON files
- [ ] tests/gates/determinism_replay.rs exists with replay tests
- [ ] TraceLink::Local is verified as replay-eligible
- [ ] TraceLink::Remote is verified as NOT replay-eligible
- [ ] Same inputs produce identical outputs when clock/IDs are frozen
- [ ] Golden scenario tests verify expected outcomes
- [ ] `cargo test gates::determinism_replay` passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-infrastructure/06-05-SUMMARY.md`
</output>
