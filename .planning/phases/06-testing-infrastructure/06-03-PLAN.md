---
phase: 06-testing-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - converge-platform/converge-core/tests/types/fact_snapshots.rs
  - converge-platform/converge-core/tests/types/promotion_record_snapshots.rs
  - converge-platform/converge-core/tests/types/tracelink_snapshots.rs
  - converge-platform/converge-core/tests/types/observation_snapshots.rs
  - converge-platform/converge-core/tests/types/correction_event_snapshots.rs
  - converge-platform/converge-core/tests/snapshots/.gitkeep
autonomous: true

must_haves:
  truths:
    - "Snapshot tests exist for all P0 API types (Fact, Proposal, ValidationReport, StopReason)"
    - "Snapshot tests exist for all P1 persistence types (IDs, PromotionRecord, EvidenceRef, TraceLink)"
    - "TraceLink::Local and TraceLink::Remote have distinct JSON shapes"
    - "All snapshots use JSON format"
  artifacts:
    - path: "converge-platform/converge-core/tests/types/fact_snapshots.rs"
      provides: "Fact and FactContent snapshot tests"
      contains: "insta::assert_json_snapshot!"
    - path: "converge-platform/converge-core/tests/types/tracelink_snapshots.rs"
      provides: "TraceLink variant snapshots"
      contains: "insta::assert_json_snapshot!"
    - path: "converge-platform/converge-core/tests/types/promotion_record_snapshots.rs"
      provides: "PromotionRecord and evidence snapshot tests"
      contains: "insta::assert_json_snapshot!"
    - path: "converge-platform/converge-core/tests/snapshots/"
      provides: "Snapshot storage directory"
  key_links:
    - from: "tests/types/fact_snapshots.rs"
      to: "converge_core::types::Fact"
      via: "type import for serialization"
      pattern: "use converge_core::types::.*Fact"
    - from: "tests/types/tracelink_snapshots.rs"
      to: "converge_core::types::TraceLink"
      via: "both TraceLink types"
      pattern: "use converge_core::types::TraceLink"
---

<objective>
Create insta snapshot tests for all serializable types in P0 and P1 tiers. Snapshots lock down the JSON serialization format to prevent accidental breaking changes.

Purpose: Serialization stability is critical for persistence and API compatibility. Snapshot tests catch format drift immediately.

Output: tests/types/*_snapshots.rs files with insta snapshot tests for all serializable types.
</objective>

<execution_context>
@/Users/kpernyer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kpernyer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-testing-infrastructure/06-RESEARCH.md
@.planning/phases/06-testing-infrastructure/06-01-SUMMARY.md

# Source files for type definitions
@converge-platform/converge-core/src/types/fact.rs
@converge-platform/converge-core/src/types/proposal.rs
@converge-platform/converge-core/src/types/provenance.rs
@converge-platform/converge-core/src/types/observation.rs
@converge-platform/converge-core/src/types/correction.rs
@converge-platform/converge-core/src/types/id.rs
@converge-platform/converge-core/src/gates/budget.rs
@converge-platform/converge-core/src/gates/stop.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Fact and content type snapshots</name>
  <files>
    converge-platform/converge-core/tests/types/fact_snapshots.rs
  </files>
  <action>
Update tests/types/mod.rs to include snapshot modules:
```rust
mod id_timestamp_ordering_proptest;
mod fact_snapshots;
mod promotion_record_snapshots;
mod tracelink_snapshots;
mod observation_snapshots;
mod correction_event_snapshots;
```

**fact_snapshots.rs**: Snapshot tests for Fact and FactContent

Note from 06-RESEARCH.md: Fact has pub(crate) constructor, so we need to create via TestHarness.

```rust
use insta::assert_json_snapshot;
use converge_core::types::*;
use crate::common::harness::TestHarness;
use crate::common::time::FrozenClock;

/// Helper to create a Fact via the proper promotion path
fn create_test_fact(harness: &mut TestHarness, content: ProposedContent) -> Fact {
    let id = harness.create_draft(content);
    harness.validate(&id).unwrap();
    let fact_id = harness.promote(&id).unwrap();
    harness.get_fact(&fact_id).unwrap().clone()
}

#[test]
fn snapshot_fact_claim() {
    let clock = FrozenClock::new(1700000000);
    let mut harness = TestHarness::with_clock(clock);

    let content = ProposedContent::new(ProposedContentKind::Claim, "Test claim content");
    let fact = create_test_fact(&mut harness, content);

    // Normalize dynamic fields before snapshot
    let mut json = serde_json::to_value(&fact).unwrap();
    let mut normalizer = crate::common::normalize::IdNormalizer::new();
    normalizer.normalize_json(&mut json);

    assert_json_snapshot!("fact_claim", json);
}

#[test]
fn snapshot_fact_plan() {
    let clock = FrozenClock::new(1700000000);
    let mut harness = TestHarness::with_clock(clock);

    let content = ProposedContent::new(ProposedContentKind::Plan, "Execute step 1, then step 2");
    let fact = create_test_fact(&mut harness, content);

    let mut json = serde_json::to_value(&fact).unwrap();
    let mut normalizer = crate::common::normalize::IdNormalizer::new();
    normalizer.normalize_json(&mut json);

    assert_json_snapshot!("fact_plan", json);
}

#[test]
fn snapshot_fact_with_confidence() {
    let clock = FrozenClock::new(1700000000);
    let mut harness = TestHarness::with_clock(clock);

    let content = ProposedContent::new(ProposedContentKind::Evaluation, "High quality result")
        .with_confidence(0.95);
    let fact = create_test_fact(&mut harness, content);

    let mut json = serde_json::to_value(&fact).unwrap();
    let mut normalizer = crate::common::normalize::IdNormalizer::new();
    normalizer.normalize_json(&mut json);

    assert_json_snapshot!("fact_with_confidence", json);
}

#[test]
fn snapshot_fact_content_all_kinds() {
    // Test each FactContentKind variant
    let kinds = [
        (FactContentKind::Claim, "A factual claim"),
        (FactContentKind::Plan, "An action plan"),
        (FactContentKind::Classification, "Category: A"),
        (FactContentKind::Evaluation, "Score: 8/10"),
        (FactContentKind::Draft, "Work in progress"),
        (FactContentKind::Reasoning, "Because X, therefore Y"),
    ];

    for (kind, text) in kinds {
        let content = FactContent::new(kind, text);
        let json = serde_json::to_value(&content).unwrap();
        let name = format!("fact_content_{:?}", kind).to_lowercase();
        insta::with_settings!({snapshot_suffix => name}, {
            assert_json_snapshot!(json);
        });
    }
}
```

Snapshot files will be created in `tests/snapshots/` by insta.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test types::fact_snapshots --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- fact_snapshots.rs has tests for Fact with different content kinds
- Facts created via TestHarness (respects pub(crate) constructor)
- Dynamic fields normalized before snapshot
  </done>
</task>

<task type="auto">
  <name>Task 2: Create provenance and TraceLink snapshots</name>
  <files>
    converge-platform/converge-core/tests/types/promotion_record_snapshots.rs
    converge-platform/converge-core/tests/types/tracelink_snapshots.rs
  </files>
  <action>
**promotion_record_snapshots.rs**: Snapshot tests for PromotionRecord and EvidenceRef

```rust
use insta::assert_json_snapshot;
use converge_core::types::*;
use crate::common::time::FrozenClock;
use crate::common::ids::DeterministicIdGenerator;

#[test]
fn snapshot_promotion_record_minimal() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let record = PromotionRecord::builder()
        .gate_id(ids.next_gate_id())
        .approver(Actor::new("system", ActorKind::System))
        .validation(ValidationSummary::new().with_passed("content_not_empty"))
        .promoted_at(clock.now())
        .build();

    assert_json_snapshot!("promotion_record_minimal", record);
}

#[test]
fn snapshot_promotion_record_full() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let record = PromotionRecord::builder()
        .gate_id(ids.next_gate_id())
        .approver(Actor::new("admin@example.com", ActorKind::Human))
        .evidence(vec![
            EvidenceRef::observation(ids.next_observation_id()),
            EvidenceRef::human_approval(ids.next_approval_id()),
        ])
        .trace(TraceLink::local(LocalTrace::new("abc123def456", "span001")))
        .validation(ValidationSummary::new()
            .with_passed("content_not_empty")
            .with_passed("format_valid")
            .with_warning("confidence_low"))
        .promoted_at(clock.now())
        .build();

    assert_json_snapshot!("promotion_record_full", record);
}

#[test]
fn snapshot_evidence_ref_observation() {
    let ids = DeterministicIdGenerator::new("test");
    let evidence = EvidenceRef::observation(ids.next_observation_id());
    assert_json_snapshot!("evidence_ref_observation", evidence);
}

#[test]
fn snapshot_evidence_ref_human_approval() {
    let ids = DeterministicIdGenerator::new("test");
    let evidence = EvidenceRef::human_approval(ids.next_approval_id());
    assert_json_snapshot!("evidence_ref_human_approval", evidence);
}

#[test]
fn snapshot_evidence_ref_derived() {
    let ids = DeterministicIdGenerator::new("test");
    let evidence = EvidenceRef::derived(ids.next_artifact_id());
    assert_json_snapshot!("evidence_ref_derived", evidence);
}

#[test]
fn snapshot_actor_variants() {
    let actors = [
        Actor::new("user@example.com", ActorKind::Human),
        Actor::new("research-agent-01", ActorKind::Agent),
        Actor::new("converge-engine", ActorKind::System),
    ];

    for actor in actors {
        let kind_name = format!("{:?}", actor.kind()).to_lowercase();
        insta::with_settings!({snapshot_suffix => kind_name}, {
            assert_json_snapshot!(actor);
        });
    }
}

#[test]
fn snapshot_validation_summary() {
    let summary = ValidationSummary::new()
        .with_passed("rule_1")
        .with_passed("rule_2")
        .with_skipped("rule_3")
        .with_warning("low confidence detected");

    assert_json_snapshot!("validation_summary", summary);
}
```

**tracelink_snapshots.rs**: Snapshot tests for TraceLink (both Local and Remote)

Per 06-RESEARCH.md: TraceLink::Local vs Remote must have distinct JSON shapes.

```rust
use insta::assert_json_snapshot;
use converge_core::types::{TraceLink, LocalTrace, RemoteRef};

#[test]
fn snapshot_tracelink_local_minimal() {
    let trace = TraceLink::local(LocalTrace::new("abc123def456789012345678901234", "span0001"));
    assert_json_snapshot!("tracelink_local_minimal", trace);
}

#[test]
fn snapshot_tracelink_local_with_parent() {
    let trace = TraceLink::local(
        LocalTrace::new("abc123def456789012345678901234", "span0001")
            .with_parent("parent01")
            .with_sampled(true)
    );
    assert_json_snapshot!("tracelink_local_with_parent", trace);
}

#[test]
fn snapshot_tracelink_remote_datadog() {
    let trace = TraceLink::remote(RemoteRef::new(
        "datadog",
        "https://app.datadoghq.com/apm/trace/abc123"
    ));
    assert_json_snapshot!("tracelink_remote_datadog", trace);
}

#[test]
fn snapshot_tracelink_remote_jaeger() {
    let trace = TraceLink::remote(RemoteRef::new(
        "jaeger",
        "http://jaeger.internal:16686/trace/def456"
    ));
    assert_json_snapshot!("tracelink_remote_jaeger", trace);
}

#[test]
fn snapshot_local_vs_remote_distinct_shapes() {
    // This test documents that Local and Remote have different JSON structures
    let local = TraceLink::local(LocalTrace::new("trace123", "span456"));
    let remote = TraceLink::remote(RemoteRef::new("datadog", "ref123"));

    let local_json = serde_json::to_value(&local).unwrap();
    let remote_json = serde_json::to_value(&remote).unwrap();

    // They should have different structure (tagged enum)
    assert_ne!(
        local_json.get("type"),
        remote_json.get("type"),
        "Local and Remote should have distinct type tags"
    );

    // Local has trace_id, span_id
    assert!(local_json.get("trace_id").is_some() || local_json.get("Local").is_some());

    // Remote has system, reference
    assert!(remote_json.get("system").is_some() || remote_json.get("Remote").is_some());
}

// Also test kernel_boundary TraceLink if different
#[test]
fn snapshot_kernel_tracelink_local() {
    use converge_core::kernel_boundary::TraceLink as KernelTraceLink;
    use converge_core::kernel_boundary::{LocalTraceLink, Replayability};

    let trace = KernelTraceLink::Local(LocalTraceLink {
        trace_id: "kernel-trace-001".into(),
        span_id: "kernel-span-001".into(),
        parent_span_id: None,
        sampled: true,
    });

    assert_json_snapshot!("kernel_tracelink_local", trace);
}

#[test]
fn snapshot_kernel_tracelink_remote() {
    use converge_core::kernel_boundary::TraceLink as KernelTraceLink;
    use converge_core::kernel_boundary::{RemoteTraceLink, Replayability};

    let trace = KernelTraceLink::Remote(RemoteTraceLink {
        system: "external-system".into(),
        reference: "ext-ref-001".into(),
        replayability: Replayability::NotDeterministic,
    });

    assert_json_snapshot!("kernel_tracelink_remote", trace);
}
```
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test types::promotion_record_snapshots types::tracelink_snapshots --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- promotion_record_snapshots.rs covers PromotionRecord, EvidenceRef, Actor, ValidationSummary
- tracelink_snapshots.rs covers both types::TraceLink and kernel_boundary::TraceLink
- Local vs Remote shapes are explicitly tested for distinctness
  </done>
</task>

<task type="auto">
  <name>Task 3: Create observation and correction snapshots</name>
  <files>
    converge-platform/converge-core/tests/types/observation_snapshots.rs
    converge-platform/converge-core/tests/types/correction_event_snapshots.rs
    converge-platform/converge-core/tests/snapshots/.gitkeep
  </files>
  <action>
**observation_snapshots.rs**: Snapshot tests for Observation types

```rust
use insta::assert_json_snapshot;
use converge_core::types::*;
use crate::common::time::FrozenClock;
use crate::common::ids::DeterministicIdGenerator;

#[test]
fn snapshot_observation_user_input() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let obs = Observation::builder()
        .id(ids.next_observation_id())
        .kind(ObservationKind::UserInput)
        .content("User typed: hello world".into())
        .captured_at(clock.now())
        .build();

    assert_json_snapshot!("observation_user_input", obs);
}

#[test]
fn snapshot_observation_llm_response() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let obs = Observation::builder()
        .id(ids.next_observation_id())
        .kind(ObservationKind::LlmResponse)
        .content("The answer is 42.".into())
        .captured_at(clock.now())
        .provenance(CaptureContext::builder()
            .provider(ProviderIdentity::new("openai", "gpt-4"))
            .build())
        .build();

    assert_json_snapshot!("observation_llm_response", obs);
}

#[test]
fn snapshot_observation_tool_output() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let obs = Observation::builder()
        .id(ids.next_observation_id())
        .kind(ObservationKind::ToolOutput)
        .content(r#"{"status": "success", "data": [1, 2, 3]}"#.into())
        .captured_at(clock.now())
        .build();

    assert_json_snapshot!("observation_tool_output", obs);
}

#[test]
fn snapshot_observation_all_kinds() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let kinds = [
        ObservationKind::UserInput,
        ObservationKind::LlmResponse,
        ObservationKind::ToolOutput,
        ObservationKind::SystemEvent,
        ObservationKind::ExternalData,
    ];

    for kind in kinds {
        clock.tick(1);
        let obs = Observation::builder()
            .id(ids.next_observation_id())
            .kind(kind)
            .content(format!("Content for {:?}", kind))
            .captured_at(clock.now())
            .build();

        let kind_name = format!("{:?}", kind).to_lowercase();
        insta::with_settings!({snapshot_suffix => kind_name}, {
            assert_json_snapshot!(obs);
        });
    }
}

#[test]
fn snapshot_provider_identity() {
    let provider = ProviderIdentity::new("anthropic", "claude-3-opus");
    assert_json_snapshot!("provider_identity", provider);
}

#[test]
fn snapshot_capture_context_full() {
    let ctx = CaptureContext::builder()
        .provider(ProviderIdentity::new("openai", "gpt-4-turbo"))
        .trace(TraceLink::local(LocalTrace::new("ctx-trace", "ctx-span")))
        .build();

    assert_json_snapshot!("capture_context_full", ctx);
}
```

**correction_event_snapshots.rs**: Snapshot tests for correction types

```rust
use insta::assert_json_snapshot;
use converge_core::types::*;
use crate::common::time::FrozenClock;
use crate::common::ids::DeterministicIdGenerator;

#[test]
fn snapshot_correction_event_data_error() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let event = CorrectionEvent::builder()
        .new_fact_id(ids.next_fact_id())
        .supersedes_fact_id(ids.next_fact_id())
        .reason(CorrectionReason::DataError)
        .scope(CorrectionScope::SingleFact)
        .actor(Actor::new("admin", ActorKind::Human))
        .corrected_at(clock.now())
        .build();

    assert_json_snapshot!("correction_event_data_error", event);
}

#[test]
fn snapshot_correction_event_policy_change() {
    let ids = DeterministicIdGenerator::new("test");
    let clock = FrozenClock::new(1700000000);

    let event = CorrectionEvent::builder()
        .new_fact_id(ids.next_fact_id())
        .supersedes_fact_id(ids.next_fact_id())
        .reason(CorrectionReason::PolicyChange)
        .scope(CorrectionScope::Chain)
        .actor(Actor::new("policy-engine", ActorKind::System))
        .corrected_at(clock.now())
        .evidence(vec![EvidenceRef::derived(ids.next_artifact_id())])
        .build();

    assert_json_snapshot!("correction_event_policy_change", event);
}

#[test]
fn snapshot_correction_reason_all_variants() {
    let reasons = [
        CorrectionReason::DataError,
        CorrectionReason::PolicyChange,
        CorrectionReason::UserRequest,
        CorrectionReason::SystemRecovery,
    ];

    for reason in reasons {
        let reason_name = format!("{:?}", reason).to_lowercase();
        insta::with_settings!({snapshot_suffix => reason_name}, {
            assert_json_snapshot!(reason);
        });
    }
}

#[test]
fn snapshot_correction_scope_all_variants() {
    let scopes = [
        CorrectionScope::SingleFact,
        CorrectionScope::Chain,
        CorrectionScope::Session,
    ];

    for scope in scopes {
        let scope_name = format!("{:?}", scope).to_lowercase();
        insta::with_settings!({snapshot_suffix => scope_name}, {
            assert_json_snapshot!(scope);
        });
    }
}
```

**Create snapshots directory placeholder:**
```bash
mkdir -p converge-platform/converge-core/tests/snapshots
touch converge-platform/converge-core/tests/snapshots/.gitkeep
```

Insta will automatically create snapshot files in `tests/snapshots/` when tests are run with `cargo insta test`.
  </action>
  <verify>
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo test types::observation_snapshots types::correction_event_snapshots --no-run 2>&1 | tail -20
```
Tests compile.
  </verify>
  <done>
- observation_snapshots.rs covers all ObservationKind variants
- correction_event_snapshots.rs covers CorrectionEvent, CorrectionReason, CorrectionScope
- tests/snapshots/ directory exists for snapshot storage
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
```bash
cd /Users/kpernyer/repo/converge.zone/converge-platform/converge-core && cargo insta test --accept 2>&1 | tail -30
```
Run with `--accept` first to create baseline snapshots, then subsequent runs verify stability.
</verification>

<success_criteria>
- [ ] tests/types/ contains all snapshot test files
- [ ] All P0 types have snapshot tests (Fact, Proposal via Fact, StopReason)
- [ ] All P1 types have snapshot tests (IDs, PromotionRecord, EvidenceRef, TraceLink, Actor, Observation, CorrectionEvent)
- [ ] TraceLink Local vs Remote distinct shapes documented and tested
- [ ] Both types::TraceLink and kernel_boundary::TraceLink covered
- [ ] `cargo insta test` creates/verifies all snapshots
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-infrastructure/06-03-SUMMARY.md`
</output>
