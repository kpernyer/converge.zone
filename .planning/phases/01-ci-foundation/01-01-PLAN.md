---
phase: 01-ci-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - converge-platform/converge-core/deny.toml
  - converge-platform/converge-core/PURITY.md
  - .github/workflows/ci.yml
autonomous: true

must_haves:
  truths:
    - "cargo deny check runs and reports violations for forbidden dependencies"
    - "PURITY.md documents allowed and forbidden dependency boundaries"
    - "CI pipeline blocks PRs that add forbidden dependencies"
  artifacts:
    - path: "converge-platform/converge-core/deny.toml"
      provides: "Dependency policy enforcement configuration"
      contains: "deny = ["
    - path: "converge-platform/converge-core/PURITY.md"
      provides: "Human-readable purity contract"
      contains: "## FORBIDDEN Dependencies"
    - path: ".github/workflows/ci.yml"
      provides: "CI pipeline with cargo-deny step"
      contains: "cargo-deny-action"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "converge-platform/converge-core/deny.toml"
      via: "manifest-path argument"
      pattern: "manifest-path.*converge-core"
    - from: "converge-platform/converge-core/PURITY.md"
      to: "converge-platform/converge-core/deny.toml"
      via: "policy alignment"
      pattern: "deny.toml"
---

<objective>
Establish automated dependency enforcement for converge-core to prevent purity violations.

Purpose: This is the foundation for all subsequent phases. Without enforcement in place, any code changes could reintroduce forbidden dependencies. By establishing cargo-deny and CI integration FIRST, we create a guardrail that will immediately catch any drift.

Output: Three files that form the enforcement infrastructure:
1. deny.toml - The machine-enforced policy
2. PURITY.md - The human-readable contract
3. ci.yml - The automation that runs enforcement on every PR
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-ci-foundation/01-RESEARCH.md
@converge-platform/converge-core/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deny.toml with forbidden dependency list</name>
  <files>converge-platform/converge-core/deny.toml</files>
  <action>
Create deny.toml in converge-platform/converge-core/ with the following configuration:

1. [graph] section:
   - all-features = true (catches feature-gated dependencies)

2. [advisories] section:
   - Standard rustsec configuration
   - unmaintained = "warn", yanked = "warn"

3. [licenses] section:
   - Allow standard permissive licenses: MIT, Apache-2.0, BSD variants, ISC, Zlib, CC0-1.0, MPL-2.0, Unicode licenses
   - unlicensed = "deny"

4. [bans] section:
   - multiple-versions = "deny" (prevent dependency bloat)
   - wildcards = "deny" (require explicit versions)
   - deny = [...] with all forbidden crates:
     * Async runtimes: tokio, async-std, async-trait
     * HTTP/Network: reqwest, hyper, axum
     * gRPC: tonic, prost
     * Parallelism: rayon
     * Randomness: rand, rand_core
     * Hashing: sha2, hex
     * ML/Data: burn, polars, ndarray
   - Each deny entry MUST include "reason" field explaining WHY it's forbidden
   - Include "use-instead" where applicable
   - For tonic: { crate = "tonic", reason = "gRPC runtime violates purity", use-instead = "converge-runtime" }
   - For prost: { crate = "prost", reason = "protobuf codegen violates purity", use-instead = "converge-runtime" }

5. [sources] section:
   - unknown-registry = "deny"
   - unknown-git = "deny"
   - allow-registry = ["https://github.com/rust-lang/crates.io-index"]

Use the template from 01-RESEARCH.md as reference but ensure all entries from PROJECT.md forbidden list are included.
  </action>
  <verify>
Run: cd converge-platform/converge-core && cargo deny check bans 2>&1
Expected: Command runs and FAILS because rayon, rand, sha2, hex are currently in Cargo.toml
This failure proves the deny.toml is working correctly - it will pass after Phase 2 removes these deps
  </verify>
  <done>
deny.toml exists with deny list containing all 15 forbidden crates (tokio, async-std, async-trait, reqwest, hyper, axum, tonic, prost, rayon, rand, rand_core, sha2, hex, burn, polars, ndarray). Each entry has a reason field. cargo deny check runs and reports violations for the 4 currently-present forbidden deps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PURITY.md contract document</name>
  <files>converge-platform/converge-core/PURITY.md</files>
  <action>
Create PURITY.md in converge-platform/converge-core/ as the human-readable purity contract.

Structure:
1. Title: "# converge-core Purity Contract"

2. Overview section explaining:
   - What purity means for converge-core (no I/O, no runtime, no implementation logic)
   - Why purity matters (portability, testability, stability)
   - How this document relates to deny.toml (machine-enforced policy)

3. "## ALLOWED Dependencies" section with table:
   | Crate | Version | Purpose | Justification |
   Include: thiserror, serde, serde_json, tracing, strum
   Each with clear justification for why it's allowed

4. "## FORBIDDEN Dependencies" section with table:
   | Crate | Category | Reason | Alternative |
   Categories: Async Runtime, HTTP/Network, gRPC, Parallelism, Randomness, Hashing, ML/Data
   List all 15 forbidden crates with reasons and alternatives

5. "## The Nine Design Tenets" section:
   Brief reference to the tenets that purity supports (link to main docs)

6. "## Enforcement" section explaining:
   - cargo deny check runs in CI
   - PRs that add forbidden deps are blocked
   - Exception process requires RFC and amendment to this document

7. "## Exception Process" section:
   - How to request an exception (RFC required)
   - What justifies an exception (nothing - redirect to capability crates)
   - Review process
  </action>
  <verify>
File exists at converge-platform/converge-core/PURITY.md
Contains "## ALLOWED Dependencies" section
Contains "## FORBIDDEN Dependencies" section with all 15 forbidden crates
Contains "## Enforcement" section referencing deny.toml
  </verify>
  <done>
PURITY.md exists with ALLOWED table (5 crates with justifications), FORBIDDEN table (15 crates with reasons/alternatives), Enforcement section referencing deny.toml and CI pipeline. Document is self-contained and explains the purity philosophy.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CI workflow with cargo-deny step</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Create .github/workflows/ci.yml with cargo-deny integration.

First, create the .github/workflows/ directory if it doesn't exist.

CI workflow structure:
```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always

jobs:
  deny:
    name: Dependency Policy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check dependency policy
        uses: EmbarkStudios/cargo-deny-action@v2
        with:
          command: check bans licenses sources
          arguments: --all-features
          manifest-path: converge-platform/converge-core/Cargo.toml
```

Important:
- Use cargo-deny-action@v2 (not v1)
- Do NOT use continue-on-error: true (enforcement must be blocking)
- Use manifest-path pointing to converge-core specifically
- Check bans, licenses, and sources (not just bans)
- Use --all-features to catch feature-gated dependencies

NOTE: This CI step will FAIL until Phase 2 removes the forbidden dependencies. This is intentional - we want the enforcement in place BEFORE the cleanup, so the cleanup has a clear success criterion.
  </action>
  <verify>
Run: ls -la .github/workflows/ci.yml
Run: grep "cargo-deny-action" .github/workflows/ci.yml
Run: grep "manifest-path" .github/workflows/ci.yml

All three commands should succeed, confirming:
1. File exists
2. Uses cargo-deny-action
3. Points to converge-core manifest
  </verify>
  <done>
ci.yml exists at .github/workflows/ci.yml with:
- Triggers on push to main and pull_request to main
- cargo-deny-action@v2 job
- manifest-path pointing to converge-platform/converge-core/Cargo.toml
- No continue-on-error (blocking enforcement)
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full enforcement chain:

1. **deny.toml validation:**
   ```bash
   cd converge-platform/converge-core
   cargo deny check bans 2>&1 | head -50
   ```
   Should show violations for rayon, rand, sha2, hex (proving deny.toml works)

2. **PURITY.md content check:**
   ```bash
   grep -c "FORBIDDEN" converge-platform/converge-core/PURITY.md
   grep -c "ALLOWED" converge-platform/converge-core/PURITY.md
   ```
   Both should return at least 1

3. **CI workflow syntax:**
   ```bash
   # If yq is available:
   yq eval '.jobs.deny.steps[1].uses' .github/workflows/ci.yml
   # Otherwise:
   grep "EmbarkStudios/cargo-deny-action@v2" .github/workflows/ci.yml
   ```
   Should confirm cargo-deny-action@v2 is used
</verification>

<success_criteria>
Phase 1 success criteria (from ROADMAP.md):

1. [x] `cargo deny check` runs and would fail on forbidden dependencies
   - VERIFIED BY: Task 1 verify step shows violations for rayon/rand/sha2/hex

2. [x] PURITY.md exists with explicit ALLOWED/FORBIDDEN dependency lists
   - VERIFIED BY: Task 2 creates the document with both sections

3. [x] CI pipeline includes cargo-deny step that blocks forbidden dependencies
   - VERIFIED BY: Task 3 creates ci.yml with cargo-deny-action (no continue-on-error)

4. [x] deny.toml covers all forbidden patterns from PROJECT.md
   - VERIFIED BY: Task 1 includes all 15 forbidden crates from PROJECT.md
</success_criteria>

<output>
After completion, create `.planning/phases/01-ci-foundation/01-01-SUMMARY.md` using the summary template.

Key information to capture:
- All three files created: deny.toml, PURITY.md, ci.yml
- cargo deny check reports expected violations (rayon, rand, sha2, hex)
- CI is ready but will fail until Phase 2 cleans up dependencies
- No blockers for Phase 2
</output>
