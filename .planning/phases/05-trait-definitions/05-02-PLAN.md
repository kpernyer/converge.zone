---
phase: 05-trait-definitions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - converge-platform/converge-core/src/traits/recall.rs
  - converge-platform/converge-core/src/traits/store.rs
  - converge-platform/converge-core/src/traits/mod.rs
autonomous: true

must_haves:
  truths:
    - "RecallReader trait provides query-only read access"
    - "RecallWriter trait provides store/delete mutation access"
    - "Recall umbrella combines RecallReader + RecallWriter"
    - "ExperienceAppender trait provides append-only event storage"
    - "ExperienceReplayer trait provides streaming replay access"
    - "All traits use GAT async pattern with Send + 'a future"
  artifacts:
    - path: "converge-platform/converge-core/src/traits/recall.rs"
      provides: "RecallReader, RecallWriter, Recall traits and RecallError"
      contains: "pub trait RecallReader"
    - path: "converge-platform/converge-core/src/traits/store.rs"
      provides: "ExperienceAppender, ExperienceReplayer traits and StoreError"
      contains: "pub trait ExperienceAppender"
  key_links:
    - from: "traits/recall.rs"
      to: "traits/error.rs"
      via: "RecallError implements CapabilityError"
      pattern: "impl CapabilityError for RecallError"
    - from: "traits/store.rs"
      to: "traits/error.rs"
      via: "StoreError implements CapabilityError"
      pattern: "impl CapabilityError for StoreError"
---

<objective>
Create Recall and ExperienceStore capability boundary traits following the split trait pattern.

Purpose: Define read/write separated traits for Recall (semantic memory) and ExperienceStore (event sourcing) per CONTEXT.md decisions. Split by authority boundary: read-only contexts get RecallReader, mutation contexts get RecallWriter.

Output: traits/recall.rs with RecallReader + RecallWriter + Recall, traits/store.rs with ExperienceAppender + ExperienceReplayer
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-trait-definitions/05-CONTEXT.md
@.planning/phases/05-trait-definitions/05-RESEARCH.md
@converge-platform/converge-core/src/traits/mod.rs
@converge-platform/converge-core/src/recall.rs
@converge-platform/converge-core/src/experience_store.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Recall capability traits with read/write separation</name>
  <files>converge-platform/converge-core/src/traits/recall.rs</files>
  <action>
Create `src/traits/recall.rs` with:

1. **RecallError enum** (implements CapabilityError):
```rust
use std::time::Duration;
use super::error::{CapabilityError, ErrorCategory};

#[derive(Debug, Clone)]
pub enum RecallError {
    IndexUnavailable { message: String },
    DimensionMismatch { expected: u32, got: u32 },
    QueryFailed { message: String },
    StoreFailed { message: String },
    NotFound { id: String },
    Timeout { elapsed: Duration, deadline: Duration },
}

impl std::fmt::Display for RecallError { ... }
impl std::error::Error for RecallError {}
impl CapabilityError for RecallError {
    fn category(&self) -> ErrorCategory {
        match self {
            Self::IndexUnavailable { .. } => ErrorCategory::Unavailable,
            Self::DimensionMismatch { .. } => ErrorCategory::InvalidInput,
            Self::QueryFailed { .. } => ErrorCategory::Internal,
            Self::StoreFailed { .. } => ErrorCategory::Internal,
            Self::NotFound { .. } => ErrorCategory::NotFound,
            Self::Timeout { .. } => ErrorCategory::Timeout,
        }
    }
    fn is_transient(&self) -> bool {
        matches!(self, Self::IndexUnavailable { .. } | Self::Timeout { .. })
    }
    fn is_retryable(&self) -> bool { self.is_transient() }
    fn retry_after(&self) -> Option<Duration> { None }
}
```

2. **Query/Result types** (reference existing recall.rs for inspiration):
```rust
#[derive(Debug, Clone)]
pub struct RecallQuery {
    pub query_text: String,
    pub max_results: usize,
    pub min_score: f64,
    pub filter: Option<RecallFilter>,
}

#[derive(Debug, Clone, Default)]
pub struct RecallFilter {
    pub corpus: Option<String>,
    pub metadata: Option<std::collections::HashMap<String, String>>,
}

#[derive(Debug, Clone)]
pub struct RecallCandidate {
    pub id: String,
    pub content: String,
    pub score: f64,
    pub metadata: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct RecallRecord {
    pub id: String,
    pub content: String,
    pub embedding: Option<Vec<f32>>,
    pub metadata: std::collections::HashMap<String, String>,
}
```

3. **RecallReader trait** (GAT async, read-only):
```rust
use std::future::Future;

pub trait RecallReader: Send + Sync {
    type QueryFut<'a>: Future<Output = Result<Vec<RecallCandidate>, RecallError>> + Send + 'a
    where
        Self: 'a;

    fn query<'a>(&'a self, query: RecallQuery) -> Self::QueryFut<'a>;
}
```

4. **RecallWriter trait** (GAT async, mutation):
```rust
pub trait RecallWriter: Send + Sync {
    type StoreFut<'a>: Future<Output = Result<(), RecallError>> + Send + 'a
    where
        Self: 'a;

    type DeleteFut<'a>: Future<Output = Result<(), RecallError>> + Send + 'a
    where
        Self: 'a;

    fn store<'a>(&'a self, record: RecallRecord) -> Self::StoreFut<'a>;
    fn delete<'a>(&'a self, id: &'a str) -> Self::DeleteFut<'a>;
}
```

5. **Recall umbrella trait**:
```rust
pub trait Recall: RecallReader + RecallWriter {}
impl<T: RecallReader + RecallWriter> Recall for T {}
```

Include module docs explaining:
- Split rationale (read vs write is governance boundary)
- Many contexts should be read-only (validation, audit, replay)
- RecallCandidate provides hints, NOT evidence (Recall â‰  Evidence axiom)
  </action>
  <verify>`cargo check -p converge-core` compiles without errors</verify>
  <done>traits/recall.rs exists with RecallReader, RecallWriter, Recall traits and RecallError</done>
</task>

<task type="auto">
  <name>Task 2: Create ExperienceStore capability traits with append/replay separation</name>
  <files>converge-platform/converge-core/src/traits/store.rs</files>
  <action>
Create `src/traits/store.rs` with:

1. **StoreError enum** (implements CapabilityError):
```rust
use std::time::Duration;
use super::error::{CapabilityError, ErrorCategory};

#[derive(Debug, Clone)]
pub enum StoreError {
    Conflict { message: String },
    SerializationFailed { message: String },
    StorageUnavailable { message: String },
    NotFound { id: String },
    Timeout { elapsed: Duration, deadline: Duration },
    InvalidQuery { message: String },
}

impl std::fmt::Display for StoreError { ... }
impl std::error::Error for StoreError {}
impl CapabilityError for StoreError {
    fn category(&self) -> ErrorCategory {
        match self {
            Self::Conflict { .. } => ErrorCategory::Conflict,
            Self::SerializationFailed { .. } => ErrorCategory::InvalidInput,
            Self::StorageUnavailable { .. } => ErrorCategory::Unavailable,
            Self::NotFound { .. } => ErrorCategory::NotFound,
            Self::Timeout { .. } => ErrorCategory::Timeout,
            Self::InvalidQuery { .. } => ErrorCategory::InvalidInput,
        }
    }
    fn is_transient(&self) -> bool {
        matches!(self, Self::StorageUnavailable { .. } | Self::Timeout { .. })
    }
    fn is_retryable(&self) -> bool { self.is_transient() }
    fn retry_after(&self) -> Option<Duration> { None }
}
```

2. **Event types** (minimal, implementations provide concrete):
```rust
#[derive(Debug, Clone)]
pub struct EventBatch {
    pub events: Vec<Event>,
    pub correlation_id: Option<String>,
}

#[derive(Debug, Clone)]
pub struct Event {
    pub id: String,
    pub event_type: String,
    pub payload: serde_json::Value,
    pub occurred_at: String,
}

#[derive(Debug, Clone, Default)]
pub struct ReplayRange {
    pub start: Option<String>,
    pub end: Option<String>,
    pub event_types: Vec<String>,
    pub limit: Option<usize>,
}
```

3. **ExperienceAppender trait** (GAT async, append-only):
```rust
use std::future::Future;

pub trait ExperienceAppender: Send + Sync {
    type AppendFut<'a>: Future<Output = Result<(), StoreError>> + Send + 'a
    where
        Self: 'a;

    fn append<'a>(&'a self, batch: EventBatch) -> Self::AppendFut<'a>;
}
```

4. **ExperienceReplayer trait** (GAT async, streaming replay):
```rust
pub trait ExperienceReplayer: Send + Sync {
    type ReplayFut<'a>: Future<Output = Result<Vec<Event>, StoreError>> + Send + 'a
    where
        Self: 'a;

    fn replay<'a>(&'a self, range: ReplayRange) -> Self::ReplayFut<'a>;
}
```

5. **Optional snapshotter traits** (from CONTEXT.md):
```rust
pub trait ExperienceSnapshotter: Send + Sync {
    type SnapshotFut<'a>: Future<Output = Result<String, StoreError>> + Send + 'a
    where
        Self: 'a;

    fn snapshot<'a>(&'a self, at: &'a str) -> Self::SnapshotFut<'a>;
}

pub trait ExperienceSnapshotReader: Send + Sync {
    type LoadFut<'a>: Future<Output = Result<serde_json::Value, StoreError>> + Send + 'a
    where
        Self: 'a;

    fn load_snapshot<'a>(&'a self, snapshot_id: &'a str) -> Self::LoadFut<'a>;
}
```

Include module docs explaining:
- Append authority is a hard governance boundary
- Replay needed for audit, debugging, deterministic re-execution
- Events are append-only, corrections are new events (not mutations)
  </action>
  <verify>`cargo check -p converge-core` compiles without errors</verify>
  <done>traits/store.rs exists with ExperienceAppender, ExperienceReplayer traits and StoreError</done>
</task>

<task type="auto">
  <name>Task 3: Update traits/mod.rs to re-export Recall and Store modules</name>
  <files>converge-platform/converge-core/src/traits/mod.rs</files>
  <action>
Update `src/traits/mod.rs`:

1. Add module declarations (after existing error, llm):
```rust
mod recall;
mod store;
```

2. Add re-exports:
```rust
pub use recall::{
    RecallReader, RecallWriter, Recall,
    RecallQuery, RecallFilter, RecallCandidate, RecallRecord,
    RecallError,
};
pub use store::{
    ExperienceAppender, ExperienceReplayer, ExperienceSnapshotter, ExperienceSnapshotReader,
    EventBatch, Event, ReplayRange,
    StoreError,
};
```

3. Update module doc comment to include new traits:
```rust
//! - [`RecallReader`]: Read-only semantic memory access
//! - [`RecallWriter`]: Semantic memory mutation
//! - [`Recall`]: Umbrella trait combining reader + writer
//! - [`ExperienceAppender`]: Append-only event storage
//! - [`ExperienceReplayer`]: Streaming event replay
```

Keep all existing content (Executor, Randomness, Fingerprint, CapabilityError, LLM traits).
  </action>
  <verify>`cargo check -p converge-core` compiles and `cargo test -p converge-core` passes</verify>
  <done>traits/mod.rs re-exports RecallReader, RecallWriter, ExperienceAppender, ExperienceReplayer and related types</done>
</task>

</tasks>

<verification>
1. `cargo check -p converge-core` compiles without errors
2. `cargo test -p converge-core` passes
3. `grep -r "pub trait RecallReader" converge-platform/converge-core/src/traits/` returns recall.rs
4. `grep -r "pub trait ExperienceAppender" converge-platform/converge-core/src/traits/` returns store.rs
5. `grep -r "impl CapabilityError for RecallError" converge-platform/converge-core/src/traits/` confirms implementation
6. `grep -r "impl CapabilityError for StoreError" converge-platform/converge-core/src/traits/` confirms implementation
</verification>

<success_criteria>
- RecallReader trait uses GAT pattern with query() method
- RecallWriter trait uses GAT pattern with store() and delete() methods
- Recall umbrella combines RecallReader + RecallWriter via supertraits
- RecallError implements CapabilityError with proper classification
- ExperienceAppender trait uses GAT pattern with append() method
- ExperienceReplayer trait uses GAT pattern with replay() method
- StoreError implements CapabilityError with proper classification
- All traits have Send + Sync bounds
- Module re-exports work (can do `use converge_core::traits::RecallReader`)
</success_criteria>

<output>
After completion, create `.planning/phases/05-trait-definitions/05-02-SUMMARY.md`
</output>
