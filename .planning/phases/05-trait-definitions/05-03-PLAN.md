---
phase: 05-trait-definitions
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - converge-platform/converge-core/src/traits/validator.rs
  - converge-platform/converge-core/src/traits/promoter.rs
  - converge-platform/converge-core/src/traits/mod.rs
  - converge-platform/converge-core/src/llm.rs
  - converge-platform/converge-core/src/backend.rs
  - converge-platform/converge-core/src/experience_store.rs
  - converge-platform/converge-core/BOUNDARY.md
autonomous: true

must_haves:
  truths:
    - "Validator trait validates Proposal<Draft> producing ValidationReport"
    - "Promoter trait promotes Proposal<Validated> to Fact"
    - "Existing LlmProvider trait marked #[deprecated] with migration note"
    - "Existing LlmBackend trait marked #[deprecated] with migration note"
    - "Existing ExperienceStore trait marked #[deprecated] with migration note"
    - "BOUNDARY.md documents trait ownership table"
  artifacts:
    - path: "converge-platform/converge-core/src/traits/validator.rs"
      provides: "Validator trait definition"
      contains: "pub trait Validator"
    - path: "converge-platform/converge-core/src/traits/promoter.rs"
      provides: "Promoter trait definition"
      contains: "pub trait Promoter"
    - path: "converge-platform/converge-core/BOUNDARY.md"
      provides: "Trait ownership documentation"
      contains: "| Trait | Owner |"
  key_links:
    - from: "traits/validator.rs"
      to: "gates/validation.rs"
      via: "returns ValidationReport"
      pattern: "ValidationReport"
    - from: "traits/promoter.rs"
      to: "gates/promotion.rs"
      via: "references Proposal<Validated>"
      pattern: "Proposal.*Validated"
---

<objective>
Create Validator/Promoter traits, deprecate existing implementations, and document trait ownership in BOUNDARY.md.

Purpose: Complete the trait definitions by adding Validator and Promoter (which work with type-state proposals from Phase 4), mark existing implementations as deprecated with actionable migration notes, and create BOUNDARY.md per REQ-DOC-02.

Output: traits/validator.rs, traits/promoter.rs, deprecation attributes on llm.rs/backend.rs/experience_store.rs, BOUNDARY.md
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-trait-definitions/05-CONTEXT.md
@.planning/phases/05-trait-definitions/05-RESEARCH.md
@converge-platform/converge-core/src/traits/mod.rs
@converge-platform/converge-core/src/gates/validation.rs
@converge-platform/converge-core/src/gates/promotion.rs
@converge-platform/converge-core/src/llm.rs
@converge-platform/converge-core/src/backend.rs
@converge-platform/converge-core/src/experience_store.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Validator and Promoter capability traits</name>
  <files>converge-platform/converge-core/src/traits/validator.rs, converge-platform/converge-core/src/traits/promoter.rs</files>
  <action>
**Create `src/traits/validator.rs`:**

```rust
//! Validator trait for the validation capability boundary.
//!
//! The Validator trait defines the interface for validating proposals.
//! Implementations exist in converge-core (ValidationAgent) and potentially
//! in other crates for custom validation logic.
//!
//! # Type-State Flow
//!
//! ```text
//! Proposal<Draft> --[Validator::validate]--> ValidationReport
//!                                           (if all_passed: Proposal<Validated>)
//! ```

use std::future::Future;
use crate::gates::validation::{ValidationReport, ValidationPolicy, ValidationContext, ValidationError};
use crate::types::Proposal;

/// Validator trait for proposal validation.
///
/// Validators examine `Proposal<Draft>` and produce a `ValidationReport`.
/// The report contains all check results and can be used to determine
/// whether promotion should proceed.
///
/// # Thread Safety
///
/// Validators must be `Send + Sync` for concurrent validation contexts.
pub trait Validator: Send + Sync {
    /// Associated future type for validation (GAT async pattern).
    type ValidateFut<'a>: Future<Output = Result<ValidationReport, ValidationError>> + Send + 'a
    where
        Self: 'a;

    /// Validate a proposal according to the given policy.
    ///
    /// Returns a `ValidationReport` that contains:
    /// - Results of all validation checks
    /// - Policy version hash (for audit)
    /// - Timestamp of validation
    ///
    /// # Arguments
    ///
    /// * `proposal` - The draft proposal to validate
    /// * `policy` - The validation policy to apply
    /// * `context` - Additional validation context
    fn validate<'a>(
        &'a self,
        proposal: &'a Proposal<crate::types::proposal::Draft>,
        policy: &'a ValidationPolicy,
        context: &'a ValidationContext,
    ) -> Self::ValidateFut<'a>;
}
```

**Create `src/traits/promoter.rs`:**

```rust
//! Promoter trait for the promotion capability boundary.
//!
//! The Promoter trait defines the interface for promoting validated proposals
//! into facts. This is the final gate in the "agents suggest, engine decides" pattern.
//!
//! # Type-State Flow
//!
//! ```text
//! Proposal<Validated> + ValidationReport --[Promoter::promote]--> Fact
//! ```

use std::future::Future;
use crate::gates::validation::ValidationReport;
use crate::gates::promotion::PromotionError;
use crate::types::{Proposal, Fact};
use crate::types::proposal::Validated;

/// Promoter trait for fact promotion.
///
/// Promoters take a `Proposal<Validated>` with its `ValidationReport` and
/// produce a `Fact`. This enforces the invariant that facts can only be
/// created through the promotion gate.
///
/// # Thread Safety
///
/// Promoters must be `Send + Sync` for concurrent promotion contexts.
pub trait Promoter: Send + Sync {
    /// Associated future type for promotion (GAT async pattern).
    type PromoteFut<'a>: Future<Output = Result<Fact, PromotionError>> + Send + 'a
    where
        Self: 'a;

    /// Promote a validated proposal to a fact.
    ///
    /// # Arguments
    ///
    /// * `proposal` - The validated proposal to promote
    /// * `report` - The validation report proving validation occurred
    ///
    /// # Invariant
    ///
    /// This is the ONLY path to create a `Fact`. The private constructor
    /// on `Fact` ensures external code cannot bypass this gate.
    fn promote<'a>(
        &'a self,
        proposal: Proposal<Validated>,
        report: &'a ValidationReport,
    ) -> Self::PromoteFut<'a>;
}
```

Include comprehensive module docs in both files explaining the type-state flow and invariants.
  </action>
  <verify>`cargo check -p converge-core` compiles without errors</verify>
  <done>traits/validator.rs and traits/promoter.rs exist with Validator and Promoter traits</done>
</task>

<task type="auto">
  <name>Task 2: Deprecate existing implementations with actionable notes</name>
  <files>converge-platform/converge-core/src/llm.rs, converge-platform/converge-core/src/backend.rs, converge-platform/converge-core/src/experience_store.rs</files>
  <action>
**Update `src/llm.rs`:**

Add `#[deprecated]` attribute to `LlmProvider` trait:
```rust
#[deprecated(
    since = "2.0.0",
    note = "Use converge_core::traits::ChatBackend instead. See BOUNDARY.md for migration guide."
)]
pub trait LlmProvider: Send + Sync {
    // ... existing methods unchanged ...
}
```

Do NOT deprecate:
- `LlmRequest`, `LlmResponse` (still useful, may be aliased)
- `MockProvider` (testing utility, keep for backward compat)
- `LlmError` (keep, but new traits use their own error)
- `LlmAgent`, `LlmRouter`, etc. (concrete implementations, not traits)

**Update `src/backend.rs`:**

Add `#[deprecated]` attribute to `LlmBackend` trait:
```rust
#[deprecated(
    since = "2.0.0",
    note = "Use converge_core::traits::LlmBackend (the umbrella trait combining ChatBackend + EmbedBackend) instead. See BOUNDARY.md for migration guide."
)]
pub trait LlmBackend: Send + Sync {
    // ... existing methods unchanged ...
}
```

Do NOT deprecate:
- `BackendError`, `BackendCapability`, etc. (still useful)
- `BackendRequest`, `BackendResponse` (request/response types)
- Configuration types (`RetryPolicy`, `CircuitBreakerConfig`, etc.)

**Update `src/experience_store.rs`:**

Add `#[deprecated]` attribute to `ExperienceStore` trait:
```rust
#[deprecated(
    since = "2.0.0",
    note = "Use converge_core::traits::ExperienceAppender and ExperienceReplayer instead. See BOUNDARY.md for migration guide."
)]
pub trait ExperienceStore: Send + Sync {
    // ... existing methods unchanged ...
}
```

Do NOT deprecate:
- `ExperienceEvent`, `ExperienceEventEnvelope` (event types)
- `ExperienceStoreError` (keep, but new traits use StoreError)
- Query types (`EventQuery`, `ArtifactQuery`, etc.)

**Deprecation message format (from CONTEXT.md):**
- Must include: what to use instead (exact path)
- Must include: where to read migration guide (BOUNDARY.md)
  </action>
  <verify>`cargo check -p converge-core 2>&1 | grep -q "deprecated"` shows deprecation warnings for traits</verify>
  <done>LlmProvider, LlmBackend (backend.rs), and ExperienceStore traits marked deprecated</done>
</task>

<task type="auto">
  <name>Task 3: Create BOUNDARY.md and update traits/mod.rs</name>
  <files>converge-platform/converge-core/BOUNDARY.md, converge-platform/converge-core/src/traits/mod.rs</files>
  <action>
**Create `converge-platform/converge-core/BOUNDARY.md`:**

```markdown
# Capability Boundary Documentation

This document defines which crates own trait definitions vs implementations
for converge-core's capability boundaries.

## Ownership Principle

- **converge-core**: Defines traits (interfaces only)
- **Capability crates**: Provide implementations

This separation keeps converge-core dependency-free and focused on correctness axioms.

## Trait Ownership Table

| Trait | Owner | Implementor(s) | Status | Replaces | Notes |
|-------|-------|----------------|--------|----------|-------|
| ChatBackend | converge-core | converge-llm, converge-provider | Stable | LlmProvider | GAT async, chat completions |
| EmbedBackend | converge-core | converge-llm, converge-provider | Stable | - | GAT async, embeddings |
| LlmBackend | converge-core | converge-llm, converge-provider | Stable | backend::LlmBackend | Umbrella: ChatBackend + EmbedBackend |
| RecallReader | converge-core | converge-recall-* | Experimental | - | Read-only semantic memory |
| RecallWriter | converge-core | converge-recall-* | Experimental | - | Semantic memory mutation |
| Recall | converge-core | converge-recall-* | Experimental | - | Umbrella: Reader + Writer |
| ExperienceAppender | converge-core | converge-store-* | Experimental | ExperienceStore::append_event | Append-only events |
| ExperienceReplayer | converge-core | converge-store-* | Experimental | ExperienceStore::query_events | Streaming replay |
| Validator | converge-core | converge-core | Stable | ValidationAgent | Type-state validation |
| Promoter | converge-core | converge-core | Stable | PromotionGate | Type-state promotion |
| Executor | converge-core | converge-runtime | Stable | - | Parallel/sequential execution |
| Randomness | converge-core | converge-runtime | Stable | - | RNG abstraction |
| Fingerprint | converge-core | converge-runtime | Stable | - | Hashing abstraction |

## Per-Capability Details

### LLM Capabilities (ChatBackend, EmbedBackend)

**Intent**: Abstract LLM chat and embedding operations without binding to specific providers.

**Invariants**:
- All futures must be Send (multi-threaded runtime support)
- Implementations must handle their own retry logic
- Errors must implement CapabilityError for classification

**Migration from LlmProvider**:
```rust
// Old (deprecated)
impl LlmProvider for MyProvider {
    fn complete(&self, req: &LlmRequest) -> Result<LlmResponse, LlmError> { ... }
}

// New
impl ChatBackend for MyProvider {
    type ChatFut<'a> = impl Future<Output = Result<ChatResponse, LlmError>> + Send + 'a where Self: 'a;
    fn chat<'a>(&'a self, req: ChatRequest) -> Self::ChatFut<'a> { ... }
}
```

### Recall Capabilities (RecallReader, RecallWriter)

**Intent**: Semantic memory for "hints" (NOT evidence). Read/write separation enforces governance.

**Invariants**:
- Recall provides hints, NOT citations
- Read-only contexts (validation, audit) use RecallReader only
- Mutation requires explicit RecallWriter access

**Migration from existing recall code**:
The existing `recall.rs` module defines types only (RecallQuery, RecallCandidate, etc.).
The new traits provide the interface for implementations.

### Store Capabilities (ExperienceAppender, ExperienceReplayer)

**Intent**: Append-only event sourcing. Corrections are new events, not mutations.

**Invariants**:
- Append-only (no update, no delete)
- Replay must be deterministic given same range
- Events include full provenance

**Migration from ExperienceStore**:
```rust
// Old (deprecated)
impl ExperienceStore for MyStore {
    fn append_event(&self, event: ExperienceEventEnvelope) -> ExperienceStoreResult<()> { ... }
    fn query_events(&self, query: &EventQuery) -> ExperienceStoreResult<Vec<ExperienceEventEnvelope>> { ... }
}

// New (split into two traits)
impl ExperienceAppender for MyStore {
    type AppendFut<'a> = impl Future<...> + Send + 'a where Self: 'a;
    fn append<'a>(&'a self, batch: EventBatch) -> Self::AppendFut<'a> { ... }
}

impl ExperienceReplayer for MyStore {
    type ReplayFut<'a> = impl Future<...> + Send + 'a where Self: 'a;
    fn replay<'a>(&'a self, range: ReplayRange) -> Self::ReplayFut<'a> { ... }
}
```

### Validation/Promotion (Validator, Promoter)

**Intent**: Type-state enforcement of "agents suggest, engine decides" pattern.

**Invariants**:
- Cannot create Fact without ValidationReport
- Cannot create ValidationReport outside converge-core
- Type-state: Draft -> Validated -> Fact

## Error Classification

All capability errors implement `CapabilityError`:

```rust
pub trait CapabilityError: std::error::Error + Send + Sync {
    fn category(&self) -> ErrorCategory;
    fn is_transient(&self) -> bool;
    fn is_retryable(&self) -> bool;
    fn retry_after(&self) -> Option<Duration>;
}
```

This enables generic retry and circuit-breaker logic.

---
*Last updated: Phase 5 (Trait Definitions)*
```

**Update `src/traits/mod.rs`:**

Add module declarations:
```rust
mod validator;
mod promoter;
```

Add re-exports:
```rust
pub use validator::Validator;
pub use promoter::Promoter;
```

Update module doc to include:
```rust
//! - [`Validator`]: Validates proposals producing ValidationReport
//! - [`Promoter`]: Promotes validated proposals to facts
```
  </action>
  <verify>
1. `cat converge-platform/converge-core/BOUNDARY.md | grep -q "ChatBackend"` confirms table exists
2. `cargo check -p converge-core` compiles
3. `cargo test -p converge-core` passes
  </verify>
  <done>BOUNDARY.md created with trait ownership table, traits/mod.rs exports Validator and Promoter</done>
</task>

</tasks>

<verification>
1. `cargo check -p converge-core` compiles without errors
2. `cargo test -p converge-core` passes
3. `grep -r "pub trait Validator" converge-platform/converge-core/src/traits/` returns validator.rs
4. `grep -r "pub trait Promoter" converge-platform/converge-core/src/traits/` returns promoter.rs
5. `grep -r "#\[deprecated" converge-platform/converge-core/src/llm.rs` shows LlmProvider deprecated
6. `grep -r "#\[deprecated" converge-platform/converge-core/src/backend.rs` shows LlmBackend deprecated
7. `grep -r "#\[deprecated" converge-platform/converge-core/src/experience_store.rs` shows ExperienceStore deprecated
8. `cat converge-platform/converge-core/BOUNDARY.md | head -30` shows trait ownership table
</verification>

<success_criteria>
- Validator trait exists with validate() method using GAT async pattern
- Promoter trait exists with promote() method using GAT async pattern
- LlmProvider, LlmBackend (backend.rs), ExperienceStore marked #[deprecated] with actionable notes
- Deprecation notes include: (1) what to use instead, (2) reference to BOUNDARY.md
- BOUNDARY.md exists with trait ownership table (all 12+ traits listed)
- BOUNDARY.md includes per-capability sections with migration examples
- Module re-exports work (can do `use converge_core::traits::Validator`)
- No impl blocks in traits/ for capability traits (signatures only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-trait-definitions/05-03-SUMMARY.md`
</output>
