---
phase: 05-trait-definitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - converge-platform/converge-core/src/traits/error.rs
  - converge-platform/converge-core/src/traits/llm.rs
  - converge-platform/converge-core/src/traits/mod.rs
autonomous: true

must_haves:
  truths:
    - "CapabilityError trait provides is_transient() and is_retryable() classification"
    - "ChatBackend trait uses GAT async pattern with Send + 'a future"
    - "EmbedBackend trait uses GAT async pattern with Send + 'a future"
    - "LlmBackend umbrella combines ChatBackend + EmbedBackend"
    - "LlmError enum implements CapabilityError with all variants"
  artifacts:
    - path: "converge-platform/converge-core/src/traits/error.rs"
      provides: "CapabilityError trait and ErrorCategory enum"
      contains: "pub trait CapabilityError"
    - path: "converge-platform/converge-core/src/traits/llm.rs"
      provides: "ChatBackend, EmbedBackend, LlmBackend traits and LlmError"
      contains: "pub trait ChatBackend"
  key_links:
    - from: "traits/llm.rs"
      to: "traits/error.rs"
      via: "LlmError implements CapabilityError"
      pattern: "impl CapabilityError for LlmError"
    - from: "traits/mod.rs"
      to: "traits/error.rs"
      via: "re-export"
      pattern: "pub use error::"
---

<objective>
Create the error infrastructure and LLM capability boundary traits using GAT async pattern.

Purpose: Establish the foundational CapabilityError interface and define LLM traits (ChatBackend, EmbedBackend) that follow the split trait pattern decided in CONTEXT.md. These traits enable static dispatch async without tokio dependency.

Output: traits/error.rs with CapabilityError + ErrorCategory, traits/llm.rs with ChatBackend + EmbedBackend + LlmBackend + LlmError
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-trait-definitions/05-CONTEXT.md
@.planning/phases/05-trait-definitions/05-RESEARCH.md
@converge-platform/converge-core/src/traits/mod.rs
@converge-platform/converge-core/src/backend.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CapabilityError trait and ErrorCategory enum</name>
  <files>converge-platform/converge-core/src/traits/error.rs</files>
  <action>
Create `src/traits/error.rs` with:

1. **ErrorCategory enum** (from CONTEXT.md):
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ErrorCategory {
    Timeout,
    RateLimit,
    Auth,
    InvalidInput,
    NotFound,
    Conflict,
    Unavailable,
    InvariantViolation,
    Internal,
}
```

2. **CapabilityError trait** (from CONTEXT.md):
```rust
pub trait CapabilityError: std::error::Error + Send + Sync {
    fn category(&self) -> ErrorCategory;
    fn is_transient(&self) -> bool;
    fn is_retryable(&self) -> bool;
    fn retry_after(&self) -> Option<Duration>;
}
```

Include comprehensive doc comments explaining:
- Purpose of CapabilityError (shared classification interface)
- When is_transient() vs is_retryable() differ
- How ErrorCategory enables generic retry/circuit breaker logic

Add `use std::time::Duration;` import. Add serde derives to ErrorCategory.
  </action>
  <verify>`cargo check -p converge-core` compiles without errors</verify>
  <done>traits/error.rs exists with CapabilityError trait and ErrorCategory enum</done>
</task>

<task type="auto">
  <name>Task 2: Create LLM capability traits with GAT async pattern</name>
  <files>converge-platform/converge-core/src/traits/llm.rs</files>
  <action>
Create `src/traits/llm.rs` with:

1. **Request/Response types** (minimal, signatures only):
```rust
// Placeholder types - implementations provide concrete versions
#[derive(Debug, Clone)]
pub struct ChatRequest {
    pub messages: Vec<ChatMessage>,
    pub max_tokens: Option<u32>,
    pub temperature: Option<f64>,
}

#[derive(Debug, Clone)]
pub struct ChatMessage {
    pub role: ChatRole,
    pub content: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChatRole { System, User, Assistant }

#[derive(Debug, Clone)]
pub struct ChatResponse {
    pub content: String,
    pub finish_reason: ChatFinishReason,
    pub usage: Option<ChatUsage>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChatFinishReason { Stop, MaxTokens, ContentFilter }

#[derive(Debug, Clone, Default)]
pub struct ChatUsage {
    pub input_tokens: u32,
    pub output_tokens: u32,
}

#[derive(Debug, Clone)]
pub struct EmbedRequest {
    pub input: Vec<String>,
    pub dimensions: Option<u32>,
}

#[derive(Debug, Clone)]
pub struct EmbedResponse {
    pub embeddings: Vec<Vec<f32>>,
}
```

2. **LlmError enum** (implements CapabilityError):
```rust
#[derive(Debug, Clone)]
pub enum LlmError {
    RateLimited { retry_after: Duration },
    Timeout { elapsed: Duration, deadline: Duration },
    AuthDenied { message: String },
    InvalidRequest { message: String },
    ProviderError { message: String },
    NetworkError { message: String },
}

impl std::fmt::Display for LlmError { ... }
impl std::error::Error for LlmError {}
impl CapabilityError for LlmError { ... }
```

3. **ChatBackend trait** (GAT async pattern from CONTEXT.md):
```rust
use std::future::Future;

pub trait ChatBackend: Send + Sync {
    type ChatFut<'a>: Future<Output = Result<ChatResponse, LlmError>> + Send + 'a
    where
        Self: 'a;

    fn chat<'a>(&'a self, req: ChatRequest) -> Self::ChatFut<'a>;
}
```

4. **EmbedBackend trait** (GAT async pattern):
```rust
pub trait EmbedBackend: Send + Sync {
    type EmbedFut<'a>: Future<Output = Result<EmbedResponse, LlmError>> + Send + 'a
    where
        Self: 'a;

    fn embed<'a>(&'a self, req: EmbedRequest) -> Self::EmbedFut<'a>;
}
```

5. **LlmBackend umbrella trait** (optional convenience):
```rust
pub trait LlmBackend: ChatBackend + EmbedBackend {}
impl<T: ChatBackend + EmbedBackend> LlmBackend for T {}
```

6. **DynChatBackend for runtime polymorphism** (from CONTEXT.md):
```rust
use std::pin::Pin;
pub type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

pub trait DynChatBackend: Send + Sync {
    fn chat(&self, req: ChatRequest) -> BoxFuture<'_, Result<ChatResponse, LlmError>>;
}

impl<T: ChatBackend> DynChatBackend for T {
    fn chat(&self, req: ChatRequest) -> BoxFuture<'_, Result<ChatResponse, LlmError>> {
        Box::pin(ChatBackend::chat(self, req))
    }
}
```

Include comprehensive module docs explaining:
- GAT async pattern (why, benefits over async_trait)
- Split trait rationale (ChatBackend vs EmbedBackend)
- When to use DynChatBackend (runtime polymorphism)
- `where Self: 'a` lifetime bound requirement

Use `use super::error::{CapabilityError, ErrorCategory};` import.
  </action>
  <verify>`cargo check -p converge-core` compiles without errors</verify>
  <done>traits/llm.rs exists with ChatBackend, EmbedBackend, LlmBackend traits and LlmError</done>
</task>

<task type="auto">
  <name>Task 3: Update traits/mod.rs to re-export new modules</name>
  <files>converge-platform/converge-core/src/traits/mod.rs</files>
  <action>
Update `src/traits/mod.rs`:

1. Add module declarations at the top (after existing Executor/Randomness/Fingerprint content):
```rust
mod error;
mod llm;
```

2. Add re-exports:
```rust
pub use error::{CapabilityError, ErrorCategory};
pub use llm::{
    ChatBackend, EmbedBackend, LlmBackend, DynChatBackend,
    ChatRequest, ChatMessage, ChatRole, ChatResponse, ChatFinishReason, ChatUsage,
    EmbedRequest, EmbedResponse,
    LlmError,
    BoxFuture,
};
```

3. Update module doc comment to include new traits:
```rust
//! - [`CapabilityError`]: Shared error classification for capability traits
//! - [`ChatBackend`]: Chat completions capability
//! - [`EmbedBackend`]: Embeddings capability
//! - [`LlmBackend`]: Umbrella trait combining chat + embed
```

Keep existing Executor, Randomness, Fingerprint, FingerprintError content unchanged.
  </action>
  <verify>`cargo check -p converge-core` compiles and `cargo test -p converge-core` passes</verify>
  <done>traits/mod.rs re-exports CapabilityError, ErrorCategory, and all LLM traits</done>
</task>

</tasks>

<verification>
1. `cargo check -p converge-core` compiles without errors
2. `cargo test -p converge-core` passes (no new tests required, but existing tests must pass)
3. `grep -r "pub trait ChatBackend" converge-platform/converge-core/src/traits/` returns llm.rs
4. `grep -r "pub trait CapabilityError" converge-platform/converge-core/src/traits/` returns error.rs
5. `grep -r "impl CapabilityError for LlmError" converge-platform/converge-core/src/traits/` confirms implementation
</verification>

<success_criteria>
- CapabilityError trait exists with category(), is_transient(), is_retryable(), retry_after() methods
- ErrorCategory enum has all 9 variants from CONTEXT.md
- ChatBackend trait uses GAT pattern with `type ChatFut<'a>: Future<...> + Send + 'a where Self: 'a`
- EmbedBackend trait uses same GAT pattern
- LlmBackend umbrella trait combines ChatBackend + EmbedBackend via supertraits
- LlmError implements CapabilityError with proper classification
- DynChatBackend provides dyn-safe wrapper with BoxFuture
- All traits have Send + Sync bounds
- Module re-exports work (can do `use converge_core::traits::ChatBackend`)
</success_criteria>

<output>
After completion, create `.planning/phases/05-trait-definitions/05-01-SUMMARY.md`
</output>
